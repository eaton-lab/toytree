{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to toytree","text":"<p>Welcome to toytree, a Python library for tree visualization, manipulation, and numerical and evolutionary analyses. If you are new to toytree, head to  the User Guide to see examples and learn about its  features.</p>"},{"location":"#history","title":"History","text":"<p><code>toytree</code> is an object-oriented library built to meet the desire for a framework that combines a Python-based tree object (similar to ete3) with a more modern and minimalist graphical design framework (e.g., like toyplot). <code>toytree</code> has since expanded far beyond this simple goal, and now also provides a suite of subpackages for additional features such as tree manipulation, enumeration, comparison, and evolutionary analyses. In this respect, <code>toytree</code> aims to fill a similar role for Python as the packages 'ape' and 'phytools' do in the R language. </p>"},{"location":"#usage","title":"Usage","text":"<p><code>toytree</code> is purposefully designed to promote interactive use within jupyter notebooks where users can make use of modern Python and web development features such as tab-completion and interactive plotting that make it easy to learn and use. <code>toytree</code> can also serve as a powerful but lightweight addition to other Python projects to provide efficient tree-based and phylogenetic algorithms.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>style: beautiful \"out-of-the-box\u201d tree drawings that require minimal styling.</li> <li>customization: drawings are highly customizable and export to PDF, SVG, or HTML.</li> <li>extendable: tree drawings are easily combined with scatterplots, barplots, etc.</li> <li>io: easily and flexibly parse tree data from newick, nexus, or extended NHX formats.</li> <li>mod: manipulate tree topology, rooting, and data using efficient algorithms.</li> <li>distance: calculate distances between trees (e.g., RF) or nodes on trees (e.g., paths).</li> <li>enum: enumerate tree partitions (e.g., quartets, bipartitions) or tree space.</li> <li>multitree: visualize or analyze sets of trees (e.g., cloud_trees, consensus).</li> <li>rtree: efficiently generate random trees for testing, demonstration, or research.</li> <li>network: parse and plot phylogenetic networks.</li> <li>reproducibility: simple and readable code.</li> <li>minimalism: few dependencies, easy installation, organized modular code base.</li> <li>and more: Have a feature request? Raise a ticket on GitHub.</li> </ul>"},{"location":"FAQs/","title":"Frequently Asked Questions","text":""},{"location":"FAQs/#how-do-i-get-help","title":"How do I get help?","text":"<p>The first place to look for help or answers is in here in the documentation. You can use the search bar in the navigation to search for terms or function names. The next place is in the source documentation strings. Some of the  source code is available here in the docs, but the rest can be accessed in an interactive environment (e.g., jupyter) by executing a function name followed by one or two question marks. The docstrings often contain detailed descriptions of parameters and example usage. Finally, you can seek further help or advice by raising an Issue on GitHub. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"help wanted\" or \"question\" as the category for your issue.</p>"},{"location":"FAQs/#how-do-i-report-bug","title":"How do I report bug?","text":"<p>If you believe you have encountered a bug in toytree please let us know by raising an Issue on GitHub. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"bug\".</p>"},{"location":"FAQs/#how-can-i-request-a-new-feature","title":"How can I request a new feature","text":"<p>We are happy to implement new useful methods in toytree that will help to  grow its userbase. To request the implementation of a new method please do so by raising an Issue on GitHub. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"enhancement\". </p>"},{"location":"FAQs/#how-can-i-contribute-to-toytree","title":"How can I contribute to toytree","text":"<p>We welcome contributors! If you are interested in contributing to toytree please first read our contributor's guide. This describes a shared framework and style to ensure a cohesive coding style throughout the source code. Then, you can raise an Issue on GitHub to indicate the project you are working on. This way, you can find if others are already working on the method, or find additional contributors for help. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"enhancement\", and under Assignees, assign your self.</p>"},{"location":"annotate-intro/","title":"<i>.annotate</i> - add to drawings","text":"In\u00a0[177]: Copied! <pre>import toytree\n\n# a tree to use for examples\ntree = toytree.rtree.unittree(8, seed=123)\n</pre> import toytree  # a tree to use for examples tree = toytree.rtree.unittree(8, seed=123) In\u00a0[178]: Copied! <pre># store the objects returned from a drawing\ncanvas, axes, mark1 = tree.draw()\n\n# call annotate method w/ 'axes' as an arg\nmark2 = tree.annotate.add_tip_markers(axes=axes, size=8, color=\"red\", marker=\"o\");\n</pre> # store the objects returned from a drawing canvas, axes, mark1 = tree.draw()  # call annotate method w/ 'axes' as an arg mark2 = tree.annotate.add_tip_markers(axes=axes, size=8, color=\"red\", marker=\"o\"); r0r1r2r3r4r5r6r7 In\u00a0[179]: Copied! <pre># draw a tree\ncanvas, axes, m0 = tree.draw()\n\n# add tip markers using module-level annotate API\ntoytree.annotate.add_tip_markers(tree, axes, color=\"blue\")\n\n# add node markers using tree-level annotate API\ntree.annotate.add_node_markers(axes, color=\"orange\");\n</pre> # draw a tree canvas, axes, m0 = tree.draw()  # add tip markers using module-level annotate API toytree.annotate.add_tip_markers(tree, axes, color=\"blue\")  # add node markers using tree-level annotate API tree.annotate.add_node_markers(axes, color=\"orange\"); r0r1r2r3r4r5r6r7 In\u00a0[180]: Copied! <pre># draw the tree\ncanvas, axes, m0 = tree.draw(tip_labels=False)\n# add markers to all nodes \nm2 = tree.annotate.add_node_markers(axes, mask=False, color=(\"height\", \"Spectral\"), size=(\"dist\", 5, 15))\n</pre> # draw the tree canvas, axes, m0 = tree.draw(tip_labels=False) # add markers to all nodes  m2 = tree.annotate.add_node_markers(axes, mask=False, color=(\"height\", \"Spectral\"), size=(\"dist\", 5, 15)) In\u00a0[181]: Copied! <pre># draw the tree without tip labels initially\ncanvas, axes, m0 = tree.draw(tip_labels=False)\n\n# add name label to each leaf\nm1 = tree.annotate.add_tip_labels(axes, labels=\"name\", color=\"red\", xshift=10)\n\n# add height label to each node\nm2 = tree.annotate.add_node_labels(axes, labels=\"height\", color=\"purple\", font_size=10, xshift=18)\n\n# add idx label above each edge \nm3 = tree.annotate.add_edge_labels(axes, labels=\"idx\", color=\"blue\", yshift=10, mask=False)\n</pre> # draw the tree without tip labels initially canvas, axes, m0 = tree.draw(tip_labels=False)  # add name label to each leaf m1 = tree.annotate.add_tip_labels(axes, labels=\"name\", color=\"red\", xshift=10)  # add height label to each node m2 = tree.annotate.add_node_labels(axes, labels=\"height\", color=\"purple\", font_size=10, xshift=18)  # add idx label above each edge  m3 = tree.annotate.add_edge_labels(axes, labels=\"idx\", color=\"blue\", yshift=10, mask=False) r0r1r2r3r4r5r6r70.250.250.50.50.750.7510123456789101112 In\u00a0[182]: Copied! <pre># draw the tree\ncanvas, axes, m0 = tree.draw()\n\n# add markers to one or more leaf nodes\nm1 = tree.annotate.add_tip_markers(axes, marker=\"o\", size=10, color=\"red\")\n\n# add markers to the right of each leaf node colored by 'dist' feature\nm2 = tree.annotate.add_tip_markers(axes, marker=\"s\", size=14, color=(\"dist\",), xshift=45)\n\n# add markers to one or more nodes\nm3 = tree.annotate.add_node_markers(axes, marker=\"^\", size=14, color=\"blue\")\n\n# add markers one or more edges\nm4 = tree.annotate.add_edge_markers(axes, marker=\"s\", size=10, color=\"purple\", mask=False)\n</pre> # draw the tree canvas, axes, m0 = tree.draw()  # add markers to one or more leaf nodes m1 = tree.annotate.add_tip_markers(axes, marker=\"o\", size=10, color=\"red\")  # add markers to the right of each leaf node colored by 'dist' feature m2 = tree.annotate.add_tip_markers(axes, marker=\"s\", size=14, color=(\"dist\",), xshift=45)  # add markers to one or more nodes m3 = tree.annotate.add_node_markers(axes, marker=\"^\", size=14, color=\"blue\")  # add markers one or more edges m4 = tree.annotate.add_edge_markers(axes, marker=\"s\", size=10, color=\"purple\", mask=False) r0r1r2r3r4r5r6r7 In\u00a0[183]: Copied! <pre># draw tree with unrooted layout\ncanvas, axes, m0 = tree.draw()\n\n# add rectangle markers to edges \nm1 = tree.annotate.add_edge_markers(axes, marker=\"r2x1\", size=15, color=\"lightgrey\", mask=False)\n# add labels on top of edge markers\nm2 = tree.annotate.add_edge_labels(axes, labels=\"idx\", font_size=10, mask=False)\n</pre> # draw tree with unrooted layout canvas, axes, m0 = tree.draw()  # add rectangle markers to edges  m1 = tree.annotate.add_edge_markers(axes, marker=\"r2x1\", size=15, color=\"lightgrey\", mask=False) # add labels on top of edge markers m2 = tree.annotate.add_edge_labels(axes, labels=\"idx\", font_size=10, mask=False) r0r1r2r3r4r5r6r70123456789101112 In\u00a0[188]: Copied! <pre># draw tree with unrooted layout\ncanvas, axes, m0 = tree.draw()\n\n# default: adds markers to internal nodes only\nm1 = tree.annotate.add_node_markers(axes, color=\"red\")\n\n# mask=False: add markers to all nodes\nm2 = tree.annotate.add_node_markers(axes, color=\"blue\", mask=False, xshift=8)\n\n# mask=boolean array: add markers to subset of nodes\nmask = tree.get_node_mask(8, 9, 10)\nm3 = tree.annotate.add_node_markers(axes, color=\"yellow\", mask=mask, xshift=-8)\n\n# mask=boolean array: add a single marker and shift position by n pixels\nmask = tree.get_node_mask(5)\nm4 = tree.annotate.add_node_markers(axes, color=\"orange\", mask=mask, xshift=-35, size=15)\n</pre> # draw tree with unrooted layout canvas, axes, m0 = tree.draw()  # default: adds markers to internal nodes only m1 = tree.annotate.add_node_markers(axes, color=\"red\")  # mask=False: add markers to all nodes m2 = tree.annotate.add_node_markers(axes, color=\"blue\", mask=False, xshift=8)  # mask=boolean array: add markers to subset of nodes mask = tree.get_node_mask(8, 9, 10) m3 = tree.annotate.add_node_markers(axes, color=\"yellow\", mask=mask, xshift=-8)  # mask=boolean array: add a single marker and shift position by n pixels mask = tree.get_node_mask(5) m4 = tree.annotate.add_node_markers(axes, color=\"orange\", mask=mask, xshift=-35, size=15) r0r1r2r3r4r5r6r7 In\u00a0[220]: Copied! <pre># ...\n</pre> # ... In\u00a0[245]: Copied! <pre># draw tree with unrooted layout\ncanvas, axes, m0 = tree.draw(layout='d')\n\n# create new features to serve as min, max of trait\ntree.set_node_data(\"min_b\", [i.height * 0.5 for i in tree], inplace=True)\ntree.set_node_data(\"max_b\", [i.height * 1.5 for i in tree], inplace=True)\n\n# add bars at nodes\ntree.annotate.add_node_bars(\n    axes=axes,\n    bar_min=\"min_b\",\n    bar_max=\"max_b\",\n    size=0.33,\n    color='purple', \n    opacity=0.4,\n);\n</pre> # draw tree with unrooted layout canvas, axes, m0 = tree.draw(layout='d')  # create new features to serve as min, max of trait tree.set_node_data(\"min_b\", [i.height * 0.5 for i in tree], inplace=True) tree.set_node_data(\"max_b\", [i.height * 1.5 for i in tree], inplace=True)  # add bars at nodes tree.annotate.add_node_bars(     axes=axes,     bar_min=\"min_b\",     bar_max=\"max_b\",     size=0.33,     color='purple',      opacity=0.4, ); r0r1r2r3r4r5r6r7 In\u00a0[288]: Copied! <pre># draw tree with unrooted layout\ncanvas, axes, m0 = tree.draw()\n\n# generate random pie-like (proportion) data array\nimport numpy as np\nncategories = 3\narr = np.random.random(size=(tree.nnodes, ncategories))\narr = (arr.T / arr.sum(axis=1)).T\nprint(arr)\n\n# add pie charts to all internal Nodes\ntree.annotate.add_node_pie_charts(\n    axes=axes,\n    data=arr, \n    size=18,\n    istroke_width=0.75,\n    istroke=\"black\",\n);\n</pre> # draw tree with unrooted layout canvas, axes, m0 = tree.draw()  # generate random pie-like (proportion) data array import numpy as np ncategories = 3 arr = np.random.random(size=(tree.nnodes, ncategories)) arr = (arr.T / arr.sum(axis=1)).T print(arr)  # add pie charts to all internal Nodes tree.annotate.add_node_pie_charts(     axes=axes,     data=arr,      size=18,     istroke_width=0.75,     istroke=\"black\", ); <pre>[[0.36180951 0.45225489 0.18593559]\n [0.44447308 0.01321342 0.5423135 ]\n [0.19423139 0.44688936 0.35887925]\n [0.39241973 0.1865384  0.42104187]\n [0.38266124 0.41678049 0.20055826]\n [0.74203503 0.1523099  0.10565506]\n [0.3349279  0.50101126 0.16406084]\n [0.26827169 0.30950003 0.42222828]\n [0.42639113 0.15933704 0.41427182]\n [0.49071719 0.18627327 0.32300954]\n [0.03971906 0.75128547 0.20899547]]\n</pre> r0r1r2r3r4r5"},{"location":"annotate-intro/#annotating-tree-drawings","title":"Annotating tree drawings\u00b6","text":"<p>The <code>.annotate</code> subpackage offers a simple way to add additional drawing Marks to an existing toytree drawing. This provides an alternative syntax to add node or tip labels to a drawing, outside of the ToyTree <code>draw</code> function, but also includes many additional methods for adding complex Marks to highlight parts of a tree drawing, or represent additional data on trees, such as text, markers, pie charts, histograms, and barplots.</p> <p>Recall that you can use the general purpose plotting library <code>toyplot</code> to combine almost any type of plot with a toytree drawing. But that requires a learning curve. The <code>toytree.annotate</code> module instead provides many simple functions for achieving simple but flexible drawing operations. If you are interested in a particular type of annotation that we do not yet support, please reach out and raise a ticket on Github at https://github.com/eaton-lab/toytree/discussions.</p>"},{"location":"annotate-intro/#context","title":"Context\u00b6","text":"<p>When adding annotations (additional markers) to a tree drawing, it is necessary to provide the context of how the tree is positioned and oriented in the drawing space. This information is provided by the <code>Cartesian</code> axes object that is returned when you create a toytree drawing, as one of the three returned objects (Canvas, Cartesian, Mark). You can store this object to a variable (I usually name it \"axes\") and then pass it to the annotation method. This allows the annotation drawing functions to know where the edges and nodes of the tree drawing are positioned, and thus additional marks can be drawn on the tree without having to specify their positions manually. Below is an example, where we add tip markers to the tree drawing as an annotation.</p>"},{"location":"annotate-intro/#module-and-tree-level-apis","title":"Module and Tree-level APIs\u00b6","text":"<p>You can access methods from the <code>annotate</code> module from either the <code>toytree.annotate</code> module, or from <code>ToyTree</code> objects directly. These are simply two different syntax style options. In the former case you must provide the ToyTree as an argument, whereas in the latter the tree itself is known from the context.</p>"},{"location":"annotate-intro/#data-annotations","title":"Data annotations\u00b6","text":"<p>Annotations are commonly used to display data on trees, such as support values on edges of a tree and trait values on the leaf or internal nodes of a tree. As discussed in our documentation section about tree Data, it is important to be careful when entering data manually to ensure the correct data is assigned to the correct Nodes in a tree. This is often best accomplished by assigning data to the Nodes of a tree directly, and then extracting the data in the correct plotting order using <code>get_node_data()</code>, or selecting the feature by name within a drawing function. Below is an example annotation function where we select the \"height\" and \"dist\" features of Nodes directly from the tree, and use toytree's \"tuple syntax\" to indicate that these values should be color mapped and range mapped, respectively, to translate them to colors and appropriate ranges of values for plotting.</p>"},{"location":"annotate-intro/#textlabel-annotations","title":"Text/Label annotations\u00b6","text":"<p>Text can be added to plots using <code>add_node_labels</code>, <code>add_edge_labels</code>, or <code>add_tip_labels</code>. These are particularly useful for adding names or metrics mapped to particular parts of a tree, from which the labels can then be further styled and shifted in position. These three functions target different sets of nodes in a tree. In reality, you can accomplish all three methods using just the <code>add_node_labels</code> method while providing an optional <code>mask</code> argument to subselect which nodes to target. However, the <code>add_tip_labels</code> method provides a slightly faster and simpler way to target only the tip nodes, and <code>add_edge_labels</code> to target the internal nodes - 1 (i.e., the edges). Edge labels are placed at the midpoint of an edge by default, but this can be modified with optional args.</p> <p>Note that feature to be mapped is selected by providing the feature name to the <code>labels</code> arg here (e.g., \"height\", \"idx\"). This is a simple way to extract the feature data directly from the ToyTree object. Alternatively, the labels arg can be passed in as a collection of values of the appropriate length (e.g., ntips, nnodes, or nedges).</p>"},{"location":"annotate-intro/#marker-annotations","title":"Marker annotations\u00b6","text":"<p>Markers (shapes) can be added to nodes or edges of a tree, or positioned relative to these, as in the case of showing markers near the tips of a tree to display trait values. Below we demonstrate <code>add_tip_markers</code> to add markers either at the tips or extending to the right past the name labels to show trait values. We also show <code>add_node_markers</code> and <code>add_edge_markers</code> which work similar to the similar methods above for adding labels to these positions of a tree.</p>"},{"location":"annotate-intro/#combining-annotations","title":"Combining annotations\u00b6","text":"<p>You can layer annotations on top of each other. For example, it may often be useful to draw markers on nodes or edges to serve as a container or background for labels. Here edge markers and edge labels are combined to label each of the edges in the tree.</p>"},{"location":"annotate-intro/#using-a-mask","title":"Using a mask\u00b6","text":"<p>The <code>mask</code> argument can be used to select a subset of nodes or edges to add annotations to. This argument accepts True, False, or a boolean array of size nnodes (or optionally of size nedges or ntips for those associated functions). There is a convenience function of ToyTree objects named <code>get_node_mask</code> that provides an easy way to generate a boolean array in node idx order containing True or False for each Node. This can be used to select to include all tip nodes, all internal nodes, and/or the root node, and also to select nodes individually by name, regular expression, or idx label. Below we show several examples.</p>"},{"location":"annotate-intro/#axes-annotations","title":"Axes annotations\u00b6","text":"<p>The <code>annotation</code> module also includes several methods for annotating or styling the axes of a drawing. [Still in development] These are convenience functions. Remember that you also have the full suite of options from the toyplot library at your disposal to further modify and style the axes of a drawing.</p>"},{"location":"annotate-intro/#add_node_bars","title":"add_node_bars\u00b6","text":"<p>The <code>add_node_bars</code> method can be used to add barplots spanning from a min to max value from a node. This is typically used to show uncertainty in node ages, and can be extracted from the feature data stored in the extended newick file output by a phylogenetic inference program for inferring a time tree. As you can see in the example below, if the tree is rotated the bars will also be rotated appropriately.</p>"},{"location":"annotate-intro/#pie-charts","title":"Pie charts\u00b6","text":"<p>Pie charts are useful for showing categorical data on a tree. You can easily create pie charts using the <code>add_node_pie_charts</code> or <code>add_edge_pie_charts</code> methods. Here each value mapped to a node should a sequence of float values that sum to 1.</p>"},{"location":"barplot/","title":"ToyTree with barplot","text":"In\u00a0[2]: Copied! <pre>import numpy as np\nimport toytree\nimport toyplot\n\n# generate a random tree and data\nntips = 20\nrseed = 123456\nrng = np.random.default_rng(rseed)\n\n# get tree and data\nrtre = toytree.rtree.unittree(ntips=ntips, seed=rseed).ladderize()\nrandomdata = rng.uniform(20, 200, ntips)\n\n# set up a toyplot Canvas with 2 axes: (x1, x2, y1, y2)\ncanvas = toyplot.Canvas(width=375, height=350)\nax0 = canvas.cartesian(bounds=(50, 200, 50, 300), padding=15, ymin=0, ymax=20)\nax1 = canvas.cartesian(bounds=(225, 325, 50, 300), padding=15, ymin=0, ymax=20)\n\n# add tree to first axes\nrtre.draw(axes=ax0);\nax0.show = False\n\n# plot the barplot on the second axes\n# (y-axis is range 0-ntips);\n# (x-axis is bar values transformed to be 0-1)\n# baseline is the space between tipnames and bars\nax1.bars(\n    np.arange(ntips),\n    randomdata,\n    along='y',\n);\n\n# style axes\nax1.show = True\nax1.y.show = False\nax1.x.ticks.show = True\n</pre> import numpy as np import toytree import toyplot  # generate a random tree and data ntips = 20 rseed = 123456 rng = np.random.default_rng(rseed)  # get tree and data rtre = toytree.rtree.unittree(ntips=ntips, seed=rseed).ladderize() randomdata = rng.uniform(20, 200, ntips)  # set up a toyplot Canvas with 2 axes: (x1, x2, y1, y2) canvas = toyplot.Canvas(width=375, height=350) ax0 = canvas.cartesian(bounds=(50, 200, 50, 300), padding=15, ymin=0, ymax=20) ax1 = canvas.cartesian(bounds=(225, 325, 50, 300), padding=15, ymin=0, ymax=20)  # add tree to first axes rtre.draw(axes=ax0); ax0.show = False  # plot the barplot on the second axes # (y-axis is range 0-ntips); # (x-axis is bar values transformed to be 0-1) # baseline is the space between tipnames and bars ax1.bars(     np.arange(ntips),     randomdata,     along='y', );  # style axes ax1.show = True ax1.y.show = False ax1.x.ticks.show = True r0r1r14r15r19r18r16r17r13r5r6r4r2r3r7r8r9r10r11r12050100150200"},{"location":"barplot/#toytree-barplot","title":"ToyTree + barplot\u00b6","text":"<p>Aligning a tree with data is sometimes easier on one axis versus two. See the (#1) and (#2) for comparison. Here when plotting on one axis the tree coordinates which map to treeheight and the number of tips can be difficult to align with data (e.g., a barplot) since the data values may be much greater than the treeheight. This can be fixed by tranforming the data and the axis labels. The example on a two axes is a bit easier in this case.</p>"},{"location":"bipartitions/","title":"bipartition methods","text":"In\u00a0[370]: Copied! <pre>import toytree\n\n# unrooted tree w/ internal Node labels used in examples\ntree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)T;\")\n</pre> import toytree  # unrooted tree w/ internal Node labels used in examples tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)T;\") In\u00a0[371]: Copied! <pre># visualize the example tree w/ node and edge labels\nc, a, m = tree.draw(use_edge_lengths=False)\ntree.annotate.add_edge_markers(a, size=18)\ntree.annotate.add_edge_labels(a)\ntree.annotate.add_node_markers(a, size=18, marker=\"s\", color=\"orange\")\ntree.annotate.add_node_labels(a, \"name\");\n</pre> # visualize the example tree w/ node and edge labels c, a, m = tree.draw(use_edge_lengths=False) tree.annotate.add_edge_markers(a, size=18) tree.annotate.add_edge_labels(a) tree.annotate.add_node_markers(a, size=18, marker=\"s\", color=\"orange\") tree.annotate.add_node_labels(a, \"name\"); abcdef678CDEFXT <p>When run with the default arguments this returns only the bipartitions created by internal edges in the tree. The three edges labeled in green above correspond to the three bipartitions shown below, where each is returned as a tuple with two sets of tip Node names that exist on either side of each split.</p> In\u00a0[372]: Copied! <pre># iterate and print the bipartitions\nfor bipartition in tree.iter_bipartitions():\n    print(bipartition)\n</pre> # iterate and print the bipartitions for bipartition in tree.iter_bipartitions():     print(bipartition) <pre>({'c', 'd'}, {'b', 'e', 'a', 'f'})\n({'f', 'e'}, {'b', 'c', 'a', 'd'})\n({'c', 'f', 'e', 'd'}, {'b', 'a'})\n</pre> In\u00a0[373]: Copied! <pre>toytree.enum.iter_bipartitions(tree)\n</pre> toytree.enum.iter_bipartitions(tree) Out[373]: <pre>&lt;generator object iter_bipartitions at 0x78d181191800&gt;</pre> In\u00a0[374]: Copied! <pre>tree.enum.iter_bipartitions()\n</pre> tree.enum.iter_bipartitions() Out[374]: <pre>&lt;generator object iter_bipartitions at 0x78d181191f80&gt;</pre> In\u00a0[375]: Copied! <pre>tree.iter_bipartitions()\n</pre> tree.iter_bipartitions() Out[375]: <pre>&lt;generator object iter_bipartitions at 0x78d181191e40&gt;</pre> In\u00a0[376]: Copied! <pre># default: feature=name\nfor bipart in tree.iter_bipartitions():\n    print(bipart)\n</pre> # default: feature=name for bipart in tree.iter_bipartitions():     print(bipart) <pre>({'c', 'd'}, {'b', 'e', 'a', 'f'})\n({'f', 'e'}, {'b', 'c', 'a', 'd'})\n({'c', 'f', 'e', 'd'}, {'b', 'a'})\n</pre> In\u00a0[377]: Copied! <pre># feature=idx is better when names are not unique\nfor bipart in tree.iter_bipartitions(feature='idx'):\n    print(bipart)\n</pre> # feature=idx is better when names are not unique for bipart in tree.iter_bipartitions(feature='idx'):     print(bipart) <pre>({2, 3}, {0, 1, 4, 5})\n({4, 5}, {0, 1, 2, 3})\n({2, 3, 4, 5}, {0, 1})\n</pre> In\u00a0[378]: Copied! <pre># or feature=None to get Node objects\nfor bipart in tree.iter_bipartitions(feature=None):\n    print(bipart)\n</pre> # or feature=None to get Node objects for bipart in tree.iter_bipartitions(feature=None):     print(bipart) <pre>({&lt;Node(idx=2, name='c')&gt;, &lt;Node(idx=3, name='d')&gt;}, {&lt;Node(idx=4, name='e')&gt;, &lt;Node(idx=1, name='b')&gt;, &lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=5, name='f')&gt;})\n({&lt;Node(idx=4, name='e')&gt;, &lt;Node(idx=5, name='f')&gt;}, {&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=1, name='b')&gt;, &lt;Node(idx=2, name='c')&gt;, &lt;Node(idx=3, name='d')&gt;})\n({&lt;Node(idx=4, name='e')&gt;, &lt;Node(idx=2, name='c')&gt;, &lt;Node(idx=5, name='f')&gt;, &lt;Node(idx=3, name='d')&gt;}, {&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=1, name='b')&gt;})\n</pre> In\u00a0[379]: Copied! <pre># tuples of tuples\nfor bipart in tree.iter_bipartitions(type=tuple):\n    print(bipart)\n</pre> # tuples of tuples for bipart in tree.iter_bipartitions(type=tuple):     print(bipart) <pre>(('c', 'd'), ('a', 'b', 'e', 'f'))\n(('e', 'f'), ('a', 'b', 'c', 'd'))\n(('c', 'd', 'e', 'f'), ('a', 'b'))\n</pre> In\u00a0[380]: Copied! <pre># tuples of lists\nfor bipart in tree.iter_bipartitions(type=list):\n    print(bipart)\n</pre> # tuples of lists for bipart in tree.iter_bipartitions(type=list):     print(bipart) <pre>(['c', 'd'], ['a', 'b', 'e', 'f'])\n(['e', 'f'], ['a', 'b', 'c', 'd'])\n(['c', 'd', 'e', 'f'], ['a', 'b'])\n</pre> In\u00a0[381]: Copied! <pre># beware when selecting node features stored as a set (default)\nfor bipart in tree.iter_bipartitions(feature=\"dist\"):\n    print(bipart)\n</pre> # beware when selecting node features stored as a set (default) for bipart in tree.iter_bipartitions(feature=\"dist\"):     print(bipart) <pre>({1.0}, {1.0})\n({1.0}, {1.0})\n({1.0}, {1.0})\n</pre> In\u00a0[382]: Copied! <pre># use type=tuple instead of set when identical node features exist\nfor bipart in tree.iter_bipartitions(feature=\"dist\", type=tuple):\n    print(bipart)\n</pre> # use type=tuple instead of set when identical node features exist for bipart in tree.iter_bipartitions(feature=\"dist\", type=tuple):     print(bipart) <pre>((1.0, 1.0), (1.0, 1.0, 1.0, 1.0))\n((1.0, 1.0), (1.0, 1.0, 1.0, 1.0))\n((1.0, 1.0, 1.0, 1.0), (1.0, 1.0))\n</pre> In\u00a0[383]: Copied! <pre># include singleton splits\nfor bipartition in tree.iter_bipartitions(include_singleton_partitions=True):\n    print(bipartition)\n</pre> # include singleton splits for bipartition in tree.iter_bipartitions(include_singleton_partitions=True):     print(bipartition) <pre>({'a'}, {'f', 'b', 'c', 'e', 'd'})\n({'b'}, {'f', 'a', 'c', 'e', 'd'})\n({'c'}, {'f', 'a', 'b', 'e', 'd'})\n({'d'}, {'f', 'a', 'b', 'c', 'e'})\n({'e'}, {'f', 'a', 'b', 'c', 'd'})\n({'f'}, {'a', 'b', 'c', 'e', 'd'})\n({'c', 'd'}, {'b', 'e', 'a', 'f'})\n({'f', 'e'}, {'b', 'c', 'a', 'd'})\n({'c', 'f', 'e', 'd'}, {'b', 'a'})\n</pre> In\u00a0[340]: Copied! <pre># generate a random tree\nrtree = toytree.rtree.unittree(ntips=8, random_names=True, seed=123)\n\n# draw the tree\nrtree.draw();\n</pre> # generate a random tree rtree = toytree.rtree.unittree(ntips=8, random_names=True, seed=123)  # draw the tree rtree.draw(); r3r0r5r6r4r7r1r2 In\u00a0[341]: Copied! <pre># show the unordered bipartitions\nlist(rtree.iter_bipartitions(sort=False))\n</pre> # show the unordered bipartitions list(rtree.iter_bipartitions(sort=False)) Out[341]: <pre>[({'r0', 'r3'}, {'r1', 'r2', 'r4', 'r5', 'r6', 'r7'}),\n ({'r5', 'r6'}, {'r0', 'r1', 'r2', 'r3', 'r4', 'r7'}),\n ({'r0', 'r3', 'r5', 'r6'}, {'r1', 'r2', 'r4', 'r7'}),\n ({'r4', 'r7'}, {'r0', 'r1', 'r2', 'r3', 'r5', 'r6'}),\n ({'r0', 'r3', 'r4', 'r5', 'r6', 'r7'}, {'r1', 'r2'})]</pre> In\u00a0[342]: Copied! <pre># show the ordered bipartitions\nlist(rtree.iter_bipartitions(sort=True))\n</pre> # show the ordered bipartitions list(rtree.iter_bipartitions(sort=True)) Out[342]: <pre>[({'r0', 'r3'}, {'r1', 'r2', 'r4', 'r5', 'r6', 'r7'}),\n ({'r5', 'r6'}, {'r0', 'r1', 'r2', 'r3', 'r4', 'r7'}),\n ({'r0', 'r3', 'r5', 'r6'}, {'r1', 'r2', 'r4', 'r7'}),\n ({'r4', 'r7'}, {'r0', 'r1', 'r2', 'r3', 'r5', 'r6'}),\n ({'r1', 'r2'}, {'r0', 'r3', 'r4', 'r5', 'r6', 'r7'})]</pre> In\u00a0[343]: Copied! <pre># show the ordered bipartitions\nlist(rtree.iter_bipartitions(sort=True, type=tuple))\n</pre> # show the ordered bipartitions list(rtree.iter_bipartitions(sort=True, type=tuple)) Out[343]: <pre>[(('r0', 'r3'), ('r1', 'r2', 'r4', 'r5', 'r6', 'r7')),\n (('r5', 'r6'), ('r0', 'r1', 'r2', 'r3', 'r4', 'r7')),\n (('r0', 'r3', 'r5', 'r6'), ('r1', 'r2', 'r4', 'r7')),\n (('r4', 'r7'), ('r0', 'r1', 'r2', 'r3', 'r5', 'r6')),\n (('r1', 'r2'), ('r0', 'r3', 'r4', 'r5', 'r6', 'r7'))]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[398]: Copied! <pre># include internal nodes\nfor bipart in tree.iter_bipartitions(include_internal_nodes=True):\n    print(bipart)\n</pre> # include internal nodes for bipart in tree.iter_bipartitions(include_internal_nodes=True):     print(bipart) <pre>({'CD', 'c', 'd'}, {'f', 'a', 'b', 'e', 'T', 'EF', 'X'})\n({'EF', 'f', 'e'}, {'a', 'b', 'c', 'T', 'CD', 'd', 'X'})\n({'f', 'c', 'e', 'CD', 'EF', 'X', 'd'}, {'T', 'b', 'a'})\n</pre> In\u00a0[453]: Copied! <pre># bipartitions of the tree when unrooted\nlist(tree.iter_bipartitions(include_internal_nodes=True, sort=True))\n</pre> # bipartitions of the tree when unrooted list(tree.iter_bipartitions(include_internal_nodes=True, sort=True)) Out[453]: <pre>[({'CD', 'c', 'd'}, {'EF', 'T', 'X', 'a', 'b', 'e', 'f'}),\n ({'EF', 'e', 'f'}, {'CD', 'T', 'X', 'a', 'b', 'c', 'd'}),\n ({'T', 'a', 'b'}, {'CD', 'EF', 'X', 'c', 'd', 'e', 'f'})]</pre> In\u00a0[454]: Copied! <pre># bipartitions of the tree after rooting\nlist(tree.root(\"c\", \"d\").iter_bipartitions(include_internal_nodes=True, sort=True))\n</pre> # bipartitions of the tree after rooting list(tree.root(\"c\", \"d\").iter_bipartitions(include_internal_nodes=True, sort=True)) Out[454]: <pre>[({'CD', 'c', 'd'}, {'EF', 'T', 'X', 'a', 'b', 'e', 'f'}),\n ({'EF', 'e', 'f'}, {'CD', 'T', 'X', 'a', 'b', 'c', 'd'}),\n ({'T', 'a', 'b'}, {'CD', 'EF', 'X', 'c', 'd', 'e', 'f'})]</pre> In\u00a0[455]: Copied! <pre># bipartitions of the tree after rooting\nlist(tree.root(\"a\").iter_bipartitions(include_internal_nodes=True, sort=True))\n</pre> # bipartitions of the tree after rooting list(tree.root(\"a\").iter_bipartitions(include_internal_nodes=True, sort=True)) Out[455]: <pre>[({'CD', 'c', 'd'}, {'EF', 'T', 'X', 'a', 'b', 'e', 'f'}),\n ({'EF', 'e', 'f'}, {'CD', 'T', 'X', 'a', 'b', 'c', 'd'}),\n ({'T', 'a', 'b'}, {'CD', 'EF', 'X', 'c', 'd', 'e', 'f'})]</pre> In\u00a0[456]: Copied! <pre># bipartitions of the tree after rooting\nlist(tree.root(\"c\", \"d\").iter_bipartitions(include_internal_nodes=True, sort=True))\n</pre> # bipartitions of the tree after rooting list(tree.root(\"c\", \"d\").iter_bipartitions(include_internal_nodes=True, sort=True)) Out[456]: <pre>[({'CD', 'c', 'd'}, {'EF', 'T', 'X', 'a', 'b', 'e', 'f'}),\n ({'EF', 'e', 'f'}, {'CD', 'T', 'X', 'a', 'b', 'c', 'd'}),\n ({'T', 'a', 'b'}, {'CD', 'EF', 'X', 'c', 'd', 'e', 'f'})]</pre> In\u00a0[344]: Copied! <pre># three trees to compare\ntree_1 = toytree.tree(\"(a,b,((c,d),(e,f)));\")\ntree_2 = toytree.tree(\"(c,d,((a,b),(e,f)));\")\ntree_3 = toytree.tree(\"(a,c,((b,d),(e,f)));\")\n</pre> # three trees to compare tree_1 = toytree.tree(\"(a,b,((c,d),(e,f)));\") tree_2 = toytree.tree(\"(c,d,((a,b),(e,f)));\") tree_3 = toytree.tree(\"(a,c,((b,d),(e,f)));\") In\u00a0[345]: Copied! <pre># get SORTED bipartitions\nbiparts_1 = set(tree_1.iter_bipartitions(type=frozenset, sort=True))\nbiparts_1\n</pre> # get SORTED bipartitions biparts_1 = set(tree_1.iter_bipartitions(type=frozenset, sort=True)) biparts_1 Out[345]: <pre>{(frozenset({'c', 'd'}), frozenset({'a', 'b', 'e', 'f'})),\n (frozenset({'e', 'f'}), frozenset({'a', 'b', 'c', 'd'})),\n (frozenset({'a', 'b'}), frozenset({'c', 'd', 'e', 'f'}))}</pre> In\u00a0[346]: Copied! <pre># get SORTED bipartitions\nbiparts_2 = set(tree_2.iter_bipartitions(type=frozenset, sort=True))\nbiparts_2\n</pre> # get SORTED bipartitions biparts_2 = set(tree_2.iter_bipartitions(type=frozenset, sort=True)) biparts_2 Out[346]: <pre>{(frozenset({'c', 'd'}), frozenset({'a', 'b', 'e', 'f'})),\n (frozenset({'e', 'f'}), frozenset({'a', 'b', 'c', 'd'})),\n (frozenset({'a', 'b'}), frozenset({'c', 'd', 'e', 'f'}))}</pre> In\u00a0[347]: Copied! <pre># get SORTED bipartitions\nbiparts_3 = set(tree_3.iter_bipartitions(type=frozenset, sort=True))\nbiparts_3\n</pre> # get SORTED bipartitions biparts_3 = set(tree_3.iter_bipartitions(type=frozenset, sort=True)) biparts_3 Out[347]: <pre>{(frozenset({'e', 'f'}), frozenset({'a', 'b', 'c', 'd'})),\n (frozenset({'b', 'd'}), frozenset({'a', 'c', 'e', 'f'})),\n (frozenset({'a', 'c'}), frozenset({'b', 'd', 'e', 'f'}))}</pre> In\u00a0[348]: Copied! <pre># get bipartitions shared by both trees\nbiparts_1.intersection(biparts_2)\n</pre> # get bipartitions shared by both trees biparts_1.intersection(biparts_2) Out[348]: <pre>{(frozenset({'c', 'd'}), frozenset({'a', 'b', 'e', 'f'})),\n (frozenset({'e', 'f'}), frozenset({'a', 'b', 'c', 'd'})),\n (frozenset({'a', 'b'}), frozenset({'c', 'd', 'e', 'f'}))}</pre> In\u00a0[349]: Copied! <pre># get bipartitions shared by both trees\nbiparts_1.intersection(biparts_3)\n</pre> # get bipartitions shared by both trees biparts_1.intersection(biparts_3) Out[349]: <pre>{(frozenset({'e', 'f'}), frozenset({'a', 'b', 'c', 'd'}))}</pre> In\u00a0[350]: Copied! <pre># get bipartitions shared by both trees\nbiparts_2.intersection(biparts_3)\n</pre> # get bipartitions shared by both trees biparts_2.intersection(biparts_3) Out[350]: <pre>{(frozenset({'e', 'f'}), frozenset({'a', 'b', 'c', 'd'}))}</pre> In\u00a0[351]: Copied! <pre># bipartitions in set1 not in set2\nbiparts_1 - biparts_2\n</pre> # bipartitions in set1 not in set2 biparts_1 - biparts_2 Out[351]: <pre>set()</pre> In\u00a0[352]: Copied! <pre># bipartitions in set1 not in set3\nbiparts_1 - biparts_3\n</pre> # bipartitions in set1 not in set3 biparts_1 - biparts_3 Out[352]: <pre>{(frozenset({'c', 'd'}), frozenset({'a', 'b', 'e', 'f'})),\n (frozenset({'a', 'b'}), frozenset({'c', 'd', 'e', 'f'}))}</pre> In\u00a0[353]: Copied! <pre># all bipartitions not shared by both trees \nbiparts_1.symmetric_difference(biparts_3)\n</pre> # all bipartitions not shared by both trees  biparts_1.symmetric_difference(biparts_3) Out[353]: <pre>{(frozenset({'b', 'd'}), frozenset({'a', 'c', 'e', 'f'})),\n (frozenset({'a', 'c'}), frozenset({'b', 'd', 'e', 'f'})),\n (frozenset({'a', 'b'}), frozenset({'c', 'd', 'e', 'f'})),\n (frozenset({'c', 'd'}), frozenset({'a', 'b', 'e', 'f'}))}</pre>"},{"location":"bipartitions/#bipartition-methods","title":"Bipartition methods\u00b6","text":"<p>A tree can be bisected along any branch to split it into two smaller subtrees, termed bipartitions. There are typically many bipartitions in a tree, and any two trees with different topologies will differ in their bipartition sets. For this reason, comparing the bipartition sets between trees is used in many contexts to quantify their differences. Because extracting and comparing bipartitions is a common procedure for many tree-based methods, we provide a convenient and powerful method for extracting and formatting bipartitions from trees using the <code>iter_bipartitions</code> method.</p>"},{"location":"bipartitions/#iter_bipartitions","title":"iter_bipartitions\u00b6","text":"<p>The method <code>iter_bipartitions()</code> returns a generator that can be used to iterate over the bipartitions in a tree. This takes several arguments that can toggle the type of information returned (e.g., Nodes, node names, node features); the type of Nodes to include (only tips, or tips and internal nodes); the type of object to be returned containing the bipartitions (e.g., set, tuple); and whether or not to sort the bipartitions. These options are each demonstrated further below. First, we show a simple demonstration of the default options for extracting bipartitions from the example tree below.</p>"},{"location":"bipartitions/#module-level-versus-object-level-api","title":"Module-level versus object-level API\u00b6","text":"<p>You can access the <code>iter_bipartitions</code> from three places in <code>toytree</code>: from the module level using <code>toytree.enum</code>; from the <code>ToyTree.enum</code> subpackage API associated with any <code>Toytree</code> object; and finally, also from a <code>ToyTree</code> object directly, since it is a relatively common method. Each is demonstrated below, where the module-level method accepts a <code>ToyTree</code> as its first argument, while the latter two examples use context to know which tree to extract bipartitions from.</p>"},{"location":"bipartitions/#feature","title":"feature\u00b6","text":"<p>The default behavior is to represent nodes on either side of a bipartition using node names. In other words, we return the \"name\" feature of Node objects. This is determined by the argument <code>feature</code>, which can be toggled to instead return Node objects, or any other desired feature of nodes. This can be particularly useful when nodes do not have unique names. In that case, returning Node objects, or their unique integer \"idx\" labels is likely more useful.</p>"},{"location":"bipartitions/#type","title":"type\u00b6","text":"<p>The items within these tuples can be specified to be represented by a particular object type (e.g., <code>set</code>, <code>frozenset</code>, <code>list</code>, <code>tuple</code>) using the argument <code>type</code>. The conversion of data to the specified type is performed efficiently within the <code>iter_bipartitions</code> method, and so selecting the appropriate type here is typically better than converting yourself afterwards. It is particularly important to be aware of the shortcomings of the <code>set</code> type, which is the default since it is most useful for comparing bipartitions between trees, but it not ideal for other types of operations or data, since sets cannot be sorted, or store items with identical values. In those cases, setting <code>type=tuple</code> is commonly useful.</p>"},{"location":"bipartitions/#compatibile-features-types","title":"compatibile features &amp; types\u00b6","text":"<p>To demonstrate an example mishap, consider a case where we want to measure the branch lengths of nodes on either side of each bipartition. We could select <code>dist</code> (branch length) as the feature to get this feature extracted from each Node on each side of each bipartition. However, because some nodes have identical dist values in this example, they are collapsed in a set, such that we lose data. This can be addressed by changing the returned type from a set to a tuple, as shown below.</p>"},{"location":"bipartitions/#singleton-partitions","title":"singleton partitions\u00b6","text":"<p>By default, singleton bipartitions (e.g., (A | B,C,D)) which only separate a single tip Node from the rest of the tree are excluded. This is because these are implicitly shared between any two trees that have the same tips, and thus these bipartitions are not informative about tree differences. However, they can be informative for other reasons. And so if you wish to include singleton bipartitions in the returned generator you can use the argument <code>include_singleton_partitions=True</code>.</p>"},{"location":"bipartitions/#sort","title":"sort\u00b6","text":"<p>There are three orders to be aware of when iterating over bipartitions: (1) first is the order in which bipartitions are returned given the tree topology; (2) second is the order of the two partitions the compose each bipartition; and (3) finally the order of items within a partition.</p> <ol> <li><p>The first is always the same. Bipartitions are returned in idx order by iterating over the tree starting from the edge above Node 0, and ending with an edge below the treenode.</p> </li> <li><p>The second is modified if <code>sort=True</code>. By default each bipartition is generated as a tuple containing the nodes (below, above) a given edge. When sorted, these will instead be ordered first by length, so that the shorter partition comes first, and second by the lowest item value (e.g., alphanumeric is str names). Thus, if the two partitions are of equal length the one containing the lowest name comes first (e.g.,  <code>({'a', 'b'}, {'c', 'd'})</code>).</p> </li> <li><p>Finally, the order of items within partitions is also sorted if <code>sort=True</code>, if possible. This depends on the <code>type</code> argument used as well. If the partition object type is sortable (e.g., it is a tuple and not a set) then the items within the partition are also sorted.</p> </li> </ol> <p>An example is shown below on a tree with randomly ordered names.</p>"},{"location":"bipartitions/#internal-nodes","title":"Internal nodes\u00b6","text":"<p>The default behavior is to only represent tip nodes in the returned bipartitions, as this provides sufficient information for comparing tree topologies. But there can be other cases where you want to compare the internal nodes as well on either side of each bipartition, particularly when the internal nodes have features associated with them, such as internal node names. You can toggle the behavior to also include internal nodes in bipartitions using <code>include_internal_nodes=True</code>. Note that the treenode (here labeled T) is included in this set by default (see below for further options concerning the treenode).</p>"},{"location":"bipartitions/#treenode-root","title":"treenode (root)\u00b6","text":"<p>Note that the treenode can be moved to difference places by re-rooting a tree and this does not change the number or identity of the bipartitions, since the number of splits in the tree remains the same, since we do not consider a split induced by the root as a bipartition. This is demonstrated below by comparing a rooted versus unrooted tree, and comparing two alternatively rooted trees. We show the internal node names to show that this is true whether or not internal nodes are included.</p>"},{"location":"bipartitions/#rooted-versus-unrooted","title":"rooted versus unrooted\u00b6","text":""},{"location":"bipartitions/#two-alternative-rootings","title":"two alternative rootings\u00b6","text":"<p>Two alternative rootings of the tree return the exact same bipartitions, and only differ in the order that those bipartitions are returned.</p>"},{"location":"bipartitions/#comparing-bipartitions","title":"Comparing bipartitions\u00b6","text":"<p>Below are some example set operations used to compare bipartitions between two trees. This is merely shown for demonstration for users who want to develop their own metrics based on bipartitions. See the <code>toytree.distance</code> module for many examples of existing tree distance metrics already implemented in <code>toytree</code>.</p>"},{"location":"bipartitions/#shared-biparts","title":"shared biparts\u00b6","text":""},{"location":"bipartitions/#differences","title":"differences\u00b6","text":""},{"location":"change_log/","title":"Change log","text":"<p>The changelog will be updated on each packaged release beginning with  <code>toytree</code> v.3.0. Please see the GitHub repo for more detailed commit  messages and the history prior to v.3.0.</p>"},{"location":"change_log/#202365-v300","title":"2023/6/5 (v.3.0.0)","text":"<ul> <li>new unittest framework for testing methods on GitHub CI.</li> <li>new subpackage structure to organize growing code base.</li> <li>new functools wrap to keep API and module-level methods synced.</li> <li><code>cli</code> New CLI for fast tree drawings in browser <code>toytree --ts p --width X --height Y</code></li> <li><code>color</code> New ToyColor module for easier color type validation and conversion.</li> <li><code>io</code> Improved inference of internal label type in <code>toytree.tree</code></li> <li><code>io</code> Support defaults to np.nan if not present in parsed tree.</li> <li><code>io</code> Completely new newick parser function. More flexible parsing.</li> <li><code>io</code> Nexus parser can handle more types of nexus formatting.</li> <li><code>io</code> Show informative message on NHX parsing errors/formatting. </li> <li><code>io</code> Write Node and Edge features separately to NHX format.</li> <li><code>distance</code> separated tree and node distance methods in submodules.</li> <li><code>distance</code> new faster node distance functions for path, up or down.</li> <li><code>distance</code> much faster algorithm for computing node distances.</li> <li><code>distance</code> bipartition based tree distance functions developed and tested.</li> <li><code>distance</code> quartet based tree distance functions developed and tested.</li> <li><code>mod</code> new rooting functions including minimal ancestor deviation (MAD).</li> <li><code>mod</code> added unittests for root and mod methods across wide variety of cases.</li> <li><code>core</code> set default Node.dist to 0, including for root on random trees.</li> <li><code>core</code> implemented new generic Node query method. Replace regex arg w/ \"~name\".</li> <li><code>core</code> simplified Node object, exposed iter functions, made edit funcs private.</li> <li><code>core</code> ToyTree now has <code>.edge_features</code> set to store default and additional features that should be treated as edge data. Edge data in NHX is stored as such.</li> <li><code>enum</code> created enum subpackage to group partition iterators and counters.</li> <li><code>data</code> replaced <code>get_node_values</code> with <code>get_node_data</code>.</li> <li><code>data</code> missing values in Node data default to np.nan on <code>get_node_data()</code></li> <li><code>data</code> new expand_node_mapping for faster expansion of Node queries w/ regex.</li> <li><code>drawing</code> renamed ToytreeMark to ToyTreeMark</li> <li><code>drawing</code> Use text extents when auto-building canvas size.</li> <li><code>drawing</code> Store tip coords in layout/ToyTreeMark for extents, tip angles, etc.</li> <li><code>drawing</code> used aspect='fit-range' on circular layouts.</li> <li><code>drawing</code> bugfix for circular trees 'p' edge type SVG paths.</li> <li><code>drawing</code> bugfix to allow ts='p' with new validators when no Ne feature.</li> <li><code>drawing</code> unrooted layout EA or ED algorithms with improved tip angles.</li> <li><code>style</code> New TreeStyle serialization and validation is faster and easier to debug.</li> <li><code>style</code> general color_mapping approach developed as (feature, ...).</li> <li><code>style</code> general value_mapping approach developed as (feature, ...). Replace <code>normalize_values</code>.</li> <li><code>style</code> create a 'b' builtin style for showing support values easily.</li> <li><code>style</code> use same validation method for tip and node data w/ <code>size</code> arg.</li> <li><code>annotate</code> New annotation subpackage created for extensible add-on plots.</li> <li><code>annotate</code> Basic Node/Edge annotation drawing methods developed.</li> <li><code>annotate</code> Pie charts and general rectangle/bar methods developed.</li> <li><code>annotate</code> Custom Marks to allow for shift in px units, not just data units.</li> <li><code>annotate</code> moved <code>add_scale_bar</code> and <code>axes_styling</code> methods to annotate.</li> <li><code>pcm</code> continuous and discrete brownian sim funcs w/ similar syntax.</li> <li><code>network</code> network parsing module.</li> </ul>"},{"location":"citation/","title":"Citation","text":""},{"location":"citation/#how-to-cite","title":"How to cite","text":"<p>Eaton, DAR. Toytree: A minimalist tree visualization and manipulation library for Python. Methods Ecol Evol. 2020; 11: 187\u2013 191.  https://doi.org/10.1111/2041-210X.13313</p>"},{"location":"citation/#bibtex","title":"Bibtex","text":"<pre><code>@article{eaton_toytree_2020,\n    title = {Toytree: {A} minimalist tree visualization and manipulation library for {Python}},\n    volume = {11},\n    copyright = {\u00a9 2019 The Author. Methods in Ecology and Evolution \u00a9 2019 British Ecological Society},\n    issn = {2041-210X},\n    shorttitle = {Toytree},\n    url = {https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/2041-210X.13313},\n    doi = {10.1111/2041-210X.13313},\n    abstract = {Toytree is a lightweight Python library for programmatically visualizing and manipulating tree-based data structures. It implements a minimalist design aesthetic and modern plotting architecture suited for interactive coding in IPython/Jupyter. Tree drawings are generated in HTML using the toyplot library backend, and display natively in Jupyter notebooks with interactivity features. Tree drawings can be combined with other plotting functions from the toyplot library (e.g. scatterplots, histograms) to create composite figures on a shared coordinate grid, and can be exported to additional formats including PNG, PDF and SVG. To parse and store tree data, toytree uses a modified fork of the ete3 TreeNode object, which includes functions for manipulating, annotating and comparing trees. Toytree integrates these functions with a plotting layout to allow node values to be extracted from trees in the correct order to style nodes for plotting. In addition, toytree provides functions for parsing additional tree formats, generating random trees, inferring consensus trees and drawing grids or clouds from multiple trees to visualize discordance. The goal of toytree is to provide a simple Python equivalent to commonly used tree manipulation and plotting libraries in R, and in doing so, to promote further development of phylogenetic and other tree-based methods in Python. Toytree is released under the GPLv3 license. Source code is available on GitHub and documentation is available at https://toytree.readthedocs.io.},\n    language = {en},\n    number = {1},\n    urldate = {2020-01-15},\n    journal = {Methods in Ecology and Evolution},\n    author = {Eaton, Deren A. R.},\n    year = {2020},\n    keywords = {phylogeny, genetics, evolution, IPython, coalescent, jupyter, notebooks, toyplot},\n    pages = {187--191},\n    file = {Full Text PDF:/home/deren/Zotero/storage/G7UTE4AR/Eaton - 2020 - Toytree A minimalist tree visualization and manip.pdf:application/pdf;Snapshot:/home/deren/Zotero/storage/SPBG3TPH/2041-210X.html:text/html},\n}\n</code></pre>"},{"location":"color-mapping/","title":"feature color-mapping","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport toyplot\nimport numpy as np\n</pre> import toytree import toyplot import numpy as np In\u00a0[2]: Copied! <pre># example tree\ntree = toytree.rtree.bdtree(10, seed=123)\n</pre> # example tree tree = toytree.rtree.bdtree(10, seed=123) In\u00a0[3]: Copied! <pre># example: project a data feature to an array of colors \ntoytree.style.get_color_mapped_feature(tree, \"height\", \"Spectral\")\n</pre> # example: project a data feature to an array of colors  toytree.style.get_color_mapped_feature(tree, \"height\", \"Spectral\") Out[3]: In\u00a0[4]: Copied! <pre># example: map node height to colors using '(feature, cmap)' syntax\ntree.draw(\n    node_sizes=10, \n    node_mask=False, \n    node_colors=(\"height\", \"Spectral\"),\n);\n</pre> # example: map node height to colors using '(feature, cmap)' syntax tree.draw(     node_sizes=10,      node_mask=False,      node_colors=(\"height\", \"Spectral\"), ); r0r1r2r3r4r5r6r7r8r9 In\u00a0[5]: Copied! <pre># assign data to an example tree\ntree = toytree.rtree.bdtree(10, seed=123)\nrng = np.random.default_rng(seed=123)\ntree.set_node_data(\"W\", rng.random(tree.nnodes), inplace=True);\ntree.set_node_data(\"X\", np.linspace(0, 100, tree.nnodes), inplace=True);\ntree.set_node_data(\"Y\", rng.choice([\"A\", \"B\", \"C\"], tree.nnodes), inplace=True);\ntree.set_node_data(\"Z\", {i: i.X for i in tree[::2]}, inplace=True);\n</pre> # assign data to an example tree tree = toytree.rtree.bdtree(10, seed=123) rng = np.random.default_rng(seed=123) tree.set_node_data(\"W\", rng.random(tree.nnodes), inplace=True); tree.set_node_data(\"X\", np.linspace(0, 100, tree.nnodes), inplace=True); tree.set_node_data(\"Y\", rng.choice([\"A\", \"B\", \"C\"], tree.nnodes), inplace=True); tree.set_node_data(\"Z\", {i: i.X for i in tree[::2]}, inplace=True); In\u00a0[6]: Copied! <pre># show data in a table\ntree.get_node_data([\"W\", \"X\", \"Y\", \"Z\"])\n</pre> # show data in a table tree.get_node_data([\"W\", \"X\", \"Y\", \"Z\"]) Out[6]: W X Y Z 0 0.682352 0.000000 A 0.000000 1 0.053821 5.555556 B NaN 2 0.220360 11.111111 C 11.111111 3 0.184372 16.666667 A NaN 4 0.175906 22.222222 A 22.222222 5 0.812095 27.777778 A NaN 6 0.923345 33.333333 A 33.333333 7 0.276574 38.888889 B NaN 8 0.819755 44.444444 A 44.444444 9 0.889893 50.000000 B NaN 10 0.512970 55.555556 B 55.555556 11 0.244965 61.111111 A NaN 12 0.824242 66.666667 B 66.666667 13 0.213763 72.222222 A NaN 14 0.741467 77.777778 A 77.777778 15 0.629940 83.333333 B NaN 16 0.927407 88.888889 A 88.888889 17 0.231908 94.444444 C NaN 18 0.799125 100.000000 A 100.000000 In\u00a0[7]: Copied! <pre># define colors by name, rgb, or rgba\ncolor1 = \"teal\"\ncolor2 = (0.1, 0.5, 0.5)\ncolor3 = (0.1, 0.5, 0.5, 0.3)\n</pre> # define colors by name, rgb, or rgba color1 = \"teal\" color2 = (0.1, 0.5, 0.5) color3 = (0.1, 0.5, 0.5, 0.3) <p>Here I pass the three objects above to <code>toyplot.color.Palette</code>, which is an object that can parse multiple different types of color inputs and store the results as an array. A palette represents the simplest form of ColorMap, containing a discrete collection of colors. This object has a nice property for displaying a color palette in the notebook, like below.</p> In\u00a0[8]: Copied! <pre># create a Palette object to easily visualize\ncolors = toyplot.color.Palette([color1, color2, color3])\ncolors\n</pre> # create a Palette object to easily visualize colors = toyplot.color.Palette([color1, color2, color3]) colors Out[8]: In\u00a0[9]: Copied! <pre># the dtype of numpy array based colors in toyplot\ncolors[0].dtype\n</pre> # the dtype of numpy array based colors in toyplot colors[0].dtype Out[9]: <pre>dtype([('r', '&lt;f8'), ('g', '&lt;f8'), ('b', '&lt;f8'), ('a', '&lt;f8')])</pre> In\u00a0[10]: Copied! <pre># select a pre-defined discrete color palette\ntoyplot.color.brewer.palette(\"Set2\")\n</pre> # select a pre-defined discrete color palette toyplot.color.brewer.palette(\"Set2\") Out[10]: In\u00a0[11]: Copied! <pre># select a pre-defined diverging color palette\ntoyplot.color.brewer.palette(\"BlueRed\", count=8)\n</pre> # select a pre-defined diverging color palette toyplot.color.brewer.palette(\"BlueRed\", count=8) Out[11]: In\u00a0[12]: Copied! <pre># define a color palette manually\ntoyplot.color.Palette(['darkcyan', 'darkmagenta', 'goldenrod'])\n</pre> # define a color palette manually toyplot.color.Palette(['darkcyan', 'darkmagenta', 'goldenrod']) Out[12]: In\u00a0[13]: Copied! <pre># select a pre-defined diverging or linear colormap\ntoyplot.color.brewer.map(\"Spectral\")\n</pre> # select a pre-defined diverging or linear colormap toyplot.color.brewer.map(\"Spectral\") Out[13]: In\u00a0[14]: Copied! <pre># project data 'X' to colors from a colormap\ntoytree.style.get_color_mapped_feature(tree, feature=\"X\", cmap=\"Spectral\")\n</pre> # project data 'X' to colors from a colormap toytree.style.get_color_mapped_feature(tree, feature=\"X\", cmap=\"Spectral\") Out[14]: In\u00a0[15]: Copied! <pre># project data \"X\" to a named colormap\ntoytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\")\n</pre> # project data \"X\" to a named colormap toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\") Out[15]: In\u00a0[16]: Copied! <pre># project data \"W\" to a named colormap\ntoytree.style.get_color_mapped_feature(tree, \"W\", \"BlueRed\")\n</pre> # project data \"W\" to a named colormap toytree.style.get_color_mapped_feature(tree, \"W\", \"BlueRed\") Out[16]: <p>The domain min or max can be set to limit the range of colors such that multiple values at the upper or lower end of the data map to the same color. For example, here we set the max to 50 even though the max of the data we are mapping (\"X\") is 100. Consequently, the color map range is concentrated between 0-50 and all values above 50 are assigned the max color. If min and max values are not set on a colormap then it will by default use the min and max values of the data being projected. Thus, it is only relevant to set these values if you wish to condense colors at one end or the other.</p> In\u00a0[17]: Copied! <pre># create a ColorMap with a restricted range\ntoytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\", domain_min=0, domain_max=50)\n</pre> # create a ColorMap with a restricted range toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\", domain_min=0, domain_max=50) Out[17]: <p>The order in which values are mapped to colors in a colomap can be reversed using the <code>reverse</code> argument.</p> In\u00a0[18]: Copied! <pre># create a reversed ColorMap by name\ntoytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\", reverse=True)\n</pre> # create a reversed ColorMap by name toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\", reverse=True) Out[18]: <p>The center of the colormap can be skewed towards one end or the other. Here it is set at 25, closer to the min value. This compresses the range of colors to the left of 25, and expands the range to right of 25. This can be useful if the variation among the larger values is of greater interest than among the lower values.</p> In\u00a0[19]: Copied! <pre># create a ColorMap with a skewed center\ncmap = toyplot.color.brewer.map(\"BlueRed\", domain_min=0, domain_max=100, center=25)\ntoytree.style.get_color_mapped_feature(tree, \"X\", cmap)\n</pre> # create a ColorMap with a skewed center cmap = toyplot.color.brewer.map(\"BlueRed\", domain_min=0, domain_max=100, center=25) toytree.style.get_color_mapped_feature(tree, \"X\", cmap) Out[19]: <p>By default colormapping in <code>toytree</code> using <code>get_color_mapped_feature</code> or the tuple syntax will assign \"transparent\" (i.e., <code>rgba(0, 0, 0, 0)</code>) for missing values. You can change this behavior by entering a value to use for missing data instead using the <code>nan_value</code> argument.</p> In\u00a0[20]: Copied! <pre># default behavior sets 'transparent' to missing/NaN values\ntoytree.style.get_color_mapped_feature(tree, \"Z\", \"BlueRed\")\n</pre> # default behavior sets 'transparent' to missing/NaN values toytree.style.get_color_mapped_feature(tree, \"Z\", \"BlueRed\") Out[20]: In\u00a0[21]: Copied! <pre># setting 'nan_value' imputes a data value to be colormapped for missing\ntoytree.style.get_color_mapped_feature(tree, \"Z\", \"BlueRed\", nan_value=0)\n</pre> # setting 'nan_value' imputes a data value to be colormapped for missing toytree.style.get_color_mapped_feature(tree, \"Z\", \"BlueRed\", nan_value=0) Out[21]: In\u00a0[22]: Copied! <pre># map a discrete feature to a list/Palette of color names\ntoytree.style.get_color_mapped_feature(tree, \"Y\", [\"red\", \"blue\", \"green\"])\n</pre> # map a discrete feature to a list/Palette of color names toytree.style.get_color_mapped_feature(tree, \"Y\", [\"red\", \"blue\", \"green\"]) Out[22]: In\u00a0[23]: Copied! <pre># map a discrete feature to a discrete colormap\ntoytree.style.get_color_mapped_feature(tree, \"Y\", \"Set2\")\n</pre> # map a discrete feature to a discrete colormap toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set2\") Out[23]: In\u00a0[24]: Copied! <pre># map a discrete feature to a continuous colormap \ntoytree.style.get_color_mapped_feature(tree, \"Y\", \"BlueRed\")\n</pre> # map a discrete feature to a continuous colormap  toytree.style.get_color_mapped_feature(tree, \"Y\", \"BlueRed\") Out[24]: <p>By creating the ColorMap manually you can set more additional arguments, such as the number of states, which can be used to  discretize colors at a more fine or coarse scale.</p> In\u00a0[25]: Copied! <pre># enter a colormap object\ncmap = toyplot.color.brewer.map(\"BlueRed\", count=8)\ntoytree.style.get_color_mapped_feature(tree, \"Y\", cmap)\n</pre> # enter a colormap object cmap = toyplot.color.brewer.map(\"BlueRed\", count=8) toytree.style.get_color_mapped_feature(tree, \"Y\", cmap) Out[25]: In\u00a0[26]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\") Out[26]: In\u00a0[27]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"X\", \"Spectral\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"X\", \"Spectral\") Out[27]: In\u00a0[28]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"X\", \"Blackbody\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"X\", \"Blackbody\") Out[28]: In\u00a0[29]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"X\", \"Greys\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"X\", \"Greys\") Out[29]: In\u00a0[30]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set1\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set1\") Out[30]: In\u00a0[31]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set2\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set2\") Out[31]: In\u00a0[32]: Copied! <pre># project \"W\" values to default 'Spectral' colormap\ntree.draw(node_colors=(\"W\",), node_sizes=10, node_mask=False);\n</pre> # project \"W\" values to default 'Spectral' colormap tree.draw(node_colors=(\"W\",), node_sizes=10, node_mask=False); r0r1r2r3r4r5r6r7r8r9 In\u00a0[33]: Copied! <pre># project \"Y\" values to discrete colors\ntree.draw(node_colors=(\"Y\", \"BlueRed\"), node_sizes=10, node_mask=False);\n</pre> # project \"Y\" values to discrete colors tree.draw(node_colors=(\"Y\", \"BlueRed\"), node_sizes=10, node_mask=False); r0r1r2r3r4r5r6r7r8r9 In\u00a0[34]: Copied! <pre># project \"X\" in minmax range 0-50 using the default colormap\ntree.draw(node_colors=(\"X\", None, 0, 50), node_sizes=10, node_mask=False);\n</pre> # project \"X\" in minmax range 0-50 using the default colormap tree.draw(node_colors=(\"X\", None, 0, 50), node_sizes=10, node_mask=False); r0r1r2r3r4r5r6r7r8r9 In\u00a0[35]: Copied! <pre># project \"Z\" to \"Greys\" colormap with nan_values set to 0 (black)\ntree.draw(node_colors=(\"Z\", \"Greys\", None, None, 0), node_sizes=10, node_mask=False);\n</pre> # project \"Z\" to \"Greys\" colormap with nan_values set to 0 (black) tree.draw(node_colors=(\"Z\", \"Greys\", None, None, 0), node_sizes=10, node_mask=False); r0r1r2r3r4r5r6r7r8r9 <p>Colormapping by the tuple syntax is also supported when using the <code>annotation</code> subpackage to add drawing annotations after initially creating a tree drawing, like in the example below.</p> In\u00a0[36]: Copied! <pre># draw a tree and add node marker annotations w/ colormapped \"X\"\ncanvas, axes, mark  = tree.draw();\ntree.annotate.add_node_markers(axes, color=(\"X\", \"BlueRed\"), mask=False);\n</pre> # draw a tree and add node marker annotations w/ colormapped \"X\" canvas, axes, mark  = tree.draw(); tree.annotate.add_node_markers(axes, color=(\"X\", \"BlueRed\"), mask=False); r0r1r2r3r4r5r6r7r8r9 In\u00a0[37]: Copied! <pre># create a custom Diverging colormap\ncol0 = toyplot.color.css(\"goldenrod\")\ncol1 = toyplot.color.css(\"darkcyan\")\ncustom_map = toyplot.color.DivergingMap(low=col0, high=col1, domain_min=0, domain_max=1)\ncustom_map\n</pre> # create a custom Diverging colormap col0 = toyplot.color.css(\"goldenrod\") col1 = toyplot.color.css(\"darkcyan\") custom_map = toyplot.color.DivergingMap(low=col0, high=col1, domain_min=0, domain_max=1) custom_map Out[37]: In\u00a0[38]: Copied! <pre>tree.draw(node_sizes=10, node_colors=(\"W\", custom_map), node_mask=False);\n</pre> tree.draw(node_sizes=10, node_colors=(\"W\", custom_map), node_mask=False); r0r1r2r3r4r5r6r7r8r9"},{"location":"color-mapping/#color-mapping","title":"Color-mapping\u00b6","text":"<p>Color mapping is a convenient method and syntax that allows for transforming/projecting raw data values into a range of valid color values drawn either from a discrete or continuous colormap. This is especially useful for visualizing a range of data values on the edges or nodes of a tree. (See Range-Mapping for a similar implementation to project continuous data to a new continuous range of values.)</p>"},{"location":"color-mapping/#quick-example","title":"Quick Example\u00b6","text":"<p>In this example we will project Node \"height\" data from a tree into a range of colors. Color mapping can be applied to any continuous or discrete data feature. This is done using the function <code>toytree.style.get_color_mapped_feature</code>, given a feature name and the name of a colormap. Below this function is used to return an array of mapped color values. This array could be passed as a node_color argument to the draw function, or, as demonstrated below, you can use the shortcut syntax by simply entering <code>(feature-name, colormap-name)</code> as a tuple into the specific field.</p>"},{"location":"color-mapping/#example-data","title":"Example Data\u00b6","text":"<p>To demonstrate color-mapping we will use a 10 tip birth-death tree with three data features assigned to Nodes of the tree. The first feature \"W\" contains random float values between 0-1. The second \"X\" contains float values sampled along a continuous range from (0-100). The third feature contains discrete str values randomly sampled from (\"A\", \"B\", \"C\"). And the final feature contains the same data as feature \"X\", but with missing values for alternating Nodes.</p>"},{"location":"color-mapping/#colors","title":"Colors\u00b6","text":"<p><code>toytree</code> relies on <code>toyplot.color</code> for parsing color data and defining color maps. Please see the incredibly good color module documentation of toyplot for more details. Here I provide a simple introduction. You can select colors in three main ways: (1) CSS color name; (2) rgb tuple; or (3) rgba tuple.</p>"},{"location":"color-mapping/#color-array-dtype","title":"Color array dtype\u00b6","text":"<p>Colors in a <code>toyplot.color</code> array are stored in a complex data format that allows for performing mathematical operations on colors, which allows for blending colors from a palette together to create gradients in colormaps. In most cases, this is an advanced feature you do not need to worry about. It is simplest to select colors by name, or by selecting them from a pre-defined palette or colormap, as described in the next section.</p>"},{"location":"color-mapping/#color-palettes","title":"Color Palettes\u00b6","text":"<p>There are a number of pre-defined color palettes that can be selected by name from the <code>toyplot.color</code> subpackage named <code>brewer</code>, which contains the popular \"brewer2\" color sets. The default color palette in <code>toyplot</code> is called Set2, and can be selected like below. A number of \"diverging\" color palettes (see more below) can also be selected and discretized into a palette by using the <code>count</code> argument to maximize divergence among the colors for the number of discrete states in a set of data.</p>"},{"location":"color-mapping/#colormaps","title":"ColorMaps\u00b6","text":"<p>A colormap (<code>toyplot.color.Map</code>) is a more advanced container for describing a distribution of colors. There are two main types of colormaps, discrete and continous. A discrete map contains a small number of colors that are typically grouped together by a shared design palette with the goal of being maximally divergent from each other. By contrast, a continuous colormap represents colors sampled along a continuous range of RGBA values such that a gradient can be easily observed spanning from minimum to maximum values in the map. The default colormaps used by <code>toytree</code> are \"Spectral\" for continous data and \"Set2\" for categorical.</p>"},{"location":"color-mapping/#get_color_mapped_feature","title":"get_color_mapped_feature()\u00b6","text":"<p>Here I will demonstrate color mapping using a function from <code>toytree</code> named <code>get_color_mapped_feature</code>. In practice users can use this function to transform data from a set of values into a distribution of colors in a colormap, however, it is not required, since the simpler \"tuple syntax\" can also be used when entering drawing arguments. Nevertheless, this is the function that is used under the hood to map data to colors, so it helps to understand its options and how it works. This function accepts a number of arguments to specify a tree, a feature to select data from the tree, and a colormap name. It also accepts options that can limit the upper or lower limits of the colormapped distribution, or skew the distribution, and options for dealing with missing data, all of which are demonstrated below.</p>"},{"location":"color-mapping/#continuous-map-examples","title":"Continuous map examples\u00b6","text":"<p>Here the data are extracted from the \"X\" feature on the tree, which contians values equally spaced between 0-100 assigned in order to the 18 Nodes in the tree. Thus, the colors assigned to each Node match the gradient of the colormap. In the next example, the feature \"W\" is mapped to the same colormap, which yields a very different distribution of colors, since Nodes 0-17 contain random values for this feature.</p>"},{"location":"color-mapping/#discrete-map-example","title":"Discrete map example\u00b6","text":"<p>You can similarly map discrete/categorical data to colormaps. For this you can enter either a Categorical or Linear ColorMap, which in the latter case will reduce the linear map into equally spaced discrete colors. Like before you can either enter the name of a colormap, or create a <code>ColorMap</code> object. As an even simpler option, you can simply enter a list of color names that is of the same length as the number of discrete states in the data, as shown below. Here the data are extracted from the \"Y\" feature on the tree which represents random discrete states of \"A\", \"B\" or \"C\".</p>"},{"location":"color-mapping/#best-colormaps","title":"Best ColorMaps\u00b6","text":"<p>These are are a few of my favorites:</p>"},{"location":"color-mapping/#using-color-mapping","title":"Using Color Mapping\u00b6","text":"<p>For convenience you perform colormapping in <code>toytree</code> drawing functions by using the tuple syntax, as a simpler alternative to calling the function <code>get_color_mapped_feature</code>. This simply involves entering the feature name to be colormapped inside of a tuple as <code>(feature-name,)</code>. You can provide additional arguments inside of the tuple, in order, to specify additional arguments available to the <code>get_color_mapped_feature</code> function. For example, to use a specific colormap rather than the default one you can specify the colormap name as well as <code>(feature-name, colormap-name)</code>. You can also add min, max,  and nan_value arguments, as demonstrated below.</p>"},{"location":"color-mapping/#tuple-syntax","title":"Tuple Syntax\u00b6","text":"<p>Several examples of entering colormap arguments using the tuple syntax.</p> <ul> <li>(feature,)</li> <li>(feature, cmap)</li> <li>(feature, cmap, min_value, max_value)</li> <li>(feature, cmap, min_value, max_value, nan_value)</li> <li>(feature, None, None, None, 10)</li> </ul>"},{"location":"color-mapping/#using-toyplotcolormap-objects","title":"Using toyplot.color.Map objects\u00b6","text":"<p>The function <code>get_color_mapped_feature</code> provides a convenient way to map data to colors that would otherwise require additional experience and knowledge about the <code>toyplot.color</code> library. Nevertheless,  advanced users may want to become familiar with the core objects and functions available in this library to expand the options that are available. In addition to selecting a colormap by name when using colormapping in <code>toytree</code> you can alternative pass it a <code>toyplot.color.Map</code> object and it will use this instead. This example demonstrates creating a custom colormap that blends two colors.</p>"},{"location":"command-line/","title":"Command line","text":""},{"location":"command-line/#toytree-cli","title":"<code>toytree</code> cli","text":"<p>Sometimes you might not be in the mood to open a jupyter notebook just to take a quick peek at a tree, in which case, the toytree command line interface (cli) provides a convenient alternative. This tool can be called from a terminal shell to execute one or more simple commands to accomplish tasks such as creating tree drawings, rooting trees, and comparing trees. </p>"},{"location":"command-line/#subcommands","title":"Subcommands","text":"<p>Currently three subcommands are supported in the cli: draw, root, and distance. (Please reach out and let us know if you would like to see additional toytree methods implemented in the cli.) Call the help command (-h) to see the available subcommands.</p> <pre><code>$ toytree -h\n</code></pre> <p>This will bring up a help statement like below. Each subcommand also has its own help page that describes its usage and options, as demonstrated below.</p> <pre><code>usage: toytree [-h] [-v] {draw,root,distance} ...\n\ntoytree command line tool. Select a subcommand.\n\npositional arguments:\n  {draw,root,distance}  sub-commands\n    draw                create tree drawing\n    root                (re)root tree and return to STDOUT\n    distance            compute distance between trees\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n\nEXAMPLE: $ toytree draw TREE -ts o -d 400 400 -v\n</code></pre>"},{"location":"command-line/#toytree-draw","title":"toytree draw","text":"<pre><code>$ toytree draw -h\n</code></pre> <pre><code>usage: toytree draw [-h] [-ts treestyle] [-d dim dim] [-o basename] [-v [app]]\n                    [-f {html,svg,pdf}]\n                    TREE\n\npositional arguments:\n  TREE               tree newick file or string\n\noptions:\n  -h, --help         show this help message and exit\n  -ts treestyle      tree style (default: n)\n  -d dim dim         width height (px) (default: (None, None))\n  -o basename        output basename[.format suffix] (default: /tmp/test)\n  -v [app]           open file with default browser or app. (default: None)\n  -f {html,svg,pdf}  output file format (default: html)\n</code></pre>"},{"location":"command-line/#toytree-root","title":"toytree root","text":"<pre><code>$ toytree root -h\n</code></pre> <pre><code>usage: toytree root [-h] [-o O [O ...]] [-r] TREE\n\npositional arguments:\n  TREE          tree newick file or string\n\noptions:\n  -h, --help    show this help message and exit\n  -o O [O ...]  outgroup\n  -r            use regex matching on outgroup string.\n</code></pre>"},{"location":"command-line/#toytree-distance","title":"toytree distance","text":"<pre><code>$ toytree distance -h\n</code></pre> <pre><code>usage: toytree distance [-h] [-m {rf,rfi,rfj,qrt}] [-n] TREE1 TREE2\n\npositional arguments:\n  TREE1                tree1 newick file or string\n  TREE2                tree2 newick file or string\n\noptions:\n  -h, --help           show this help message and exit\n  -m {rf,rfi,rfj,qrt}  distance metric method\n  -n, --normalize      normalize value between [0-1]\n</code></pre>"},{"location":"command-line/#chaining","title":"chaining","text":"<p>To indicate to the draw function that the NEWICk input is the STDOUT from the previous command, use the <code>-</code> character like below.</p> <pre><code>toytree root NEWICK | toytree draw - ...\n</code></pre>"},{"location":"consensus-trees/","title":"Consensus trees","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np In\u00a0[7]: Copied! <pre># a single starting tree\ntree = toytree.rtree.unittree(6, seed=123)\n</pre> # a single starting tree tree = toytree.rtree.unittree(6, seed=123) In\u00a0[8]: Copied! <pre># create set of trees by randomly modifying root, internal, and tip edges\ntrees = [\n    tree\n    .mod.edges_set_node_heights({i: np.random.uniform(-0.2, 0) for i in range(tree.ntips)})\n    .mod.edges_multiplier(10)\n    .mod.edges_slider(0.1)\n    for i in range(20)\n]\n</pre> # create set of trees by randomly modifying root, internal, and tip edges trees = [     tree     .mod.edges_set_node_heights({i: np.random.uniform(-0.2, 0) for i in range(tree.ntips)})     .mod.edges_multiplier(10)     .mod.edges_slider(0.1)     for i in range(20) ] In\u00a0[4]: Copied! <pre># create a multitree\nmtree = toytree.mtree(trees)\n</pre> # create a multitree mtree = toytree.mtree(trees) In\u00a0[5]: Copied! <pre># draw a few trees to examine variation\nmtree.draw(ts='c', shared_axes=True, scale_bar=True);\n</pre> # draw a few trees to examine variation mtree.draw(ts='c', shared_axes=True, scale_bar=True); r0r1r2r3r4r500.51r0r1r2r3r4r500.51r0r1r2r3r4r500.51r0r1r2r3r4r500.51 In\u00a0[6]: Copied! <pre># get consensus tree\nctree = mtree.get_consensus_tree()\n\n# root the tree\n# ctree = ctree.mod.root_on_midpoint()\nctree = ctree.root(8, root_dist=0.28)\n\n# draw it\nctree.draw('p');\n\n# add node bars to show std of node heights\n# ...\n</pre> # get consensus tree ctree = mtree.get_consensus_tree()  # root the tree # ctree = ctree.mod.root_on_midpoint() ctree = ctree.root(8, root_dist=0.28)  # draw it ctree.draw('p');  # add node bars to show std of node heights # ... <pre>&lt;Node(idx=8)&gt; 0.28418659898121107 0.5737607504385339\n&lt;Node(idx=8)&gt; 0.2583728055227246 0.562271718955612\n&lt;Node(idx=8)&gt; 0.20776634990990392 0.4417576575275013\n&lt;Node(idx=8)&gt; 0.4966666903202328 0.9634437598395291\n&lt;Node(idx=8)&gt; 0.2796030913115508 0.5440066126849977\n&lt;Node(idx=8)&gt; 0.2209731809351428 0.4515257945911898\n&lt;Node(idx=8)&gt; 0.3956792138033278 0.8500737537447055\n&lt;Node(idx=8)&gt; 0.38938404955162453 0.8933688023632044\n&lt;Node(idx=8)&gt; 0.2496431351720949 0.48560838839973897\n&lt;Node(idx=8)&gt; 0.32479826910645115 0.642429483482034\n&lt;Node(idx=8)&gt; 0.515842588816714 1.1002762107273165\n&lt;Node(idx=8)&gt; 0.3205299499335021 0.6543663667441568\n&lt;Node(idx=8)&gt; 0.4478923071928977 0.9368206321841088\n&lt;Node(idx=8)&gt; 0.36392653442839135 0.7001000440964242\n&lt;Node(idx=8)&gt; 0.40437951030086616 0.8180741068442078\n&lt;Node(idx=8)&gt; 0.5482530379692488 1.029027637683661\n&lt;Node(idx=8)&gt; 0.45342139503569173 0.8789492137708874\n&lt;Node(idx=8)&gt; 0.5096151196401049 0.9989612640708907\n&lt;Node(idx=8)&gt; 0.24484891580343765 0.5114797463792604\n&lt;Node(idx=8)&gt; 0.24782437249402905 0.5478674408967885\n</pre> 012345678910r0r1r2r3r4r500.40.81.2 In\u00a0[\u00a0]: Copied! <pre>c = mtree1.get_consensus_tree(ultrametric=0)\nc = c.mod.root_on_midpoint()\nc = c.set_node_data(\"height\", {i: 0 for i in range(c.ntips)})\nc = c.set_node_data(\"height\", {i: c[i].height_mean for i in range(c.ntips, c.nnodes - 2)})\nc = c.set_node_data(\"height\", {c.treenode.idx: c[c.treenode.idx - 1].height_mean})\nc = c.set_node_data(\"height\", {c.treenode.idx - 1: c.treenode.height - c[c.treenode.idx - 2].dist})\n\n# c = c.set_node_data(\"height\", {5: 1.208333, 6: 1.250000, 7: 1.25 + 1.0})  # 0 for i in range(5)})\nc.get_node_data()\n</pre> c = mtree1.get_consensus_tree(ultrametric=0) c = c.mod.root_on_midpoint() c = c.set_node_data(\"height\", {i: 0 for i in range(c.ntips)}) c = c.set_node_data(\"height\", {i: c[i].height_mean for i in range(c.ntips, c.nnodes - 2)}) c = c.set_node_data(\"height\", {c.treenode.idx: c[c.treenode.idx - 1].height_mean}) c = c.set_node_data(\"height\", {c.treenode.idx - 1: c.treenode.height - c[c.treenode.idx - 2].dist})  # c = c.set_node_data(\"height\", {5: 1.208333, 6: 1.250000, 7: 1.25 + 1.0})  # 0 for i in range(5)}) c.get_node_data() In\u00a0[\u00a0]: Copied! <pre>mtree1[0].style.edge_colors = \"red\"\nmtree1[0].style.edge_widths = 10\nmtree1[0].style.edge_style.stroke_opacity = 1.0\nmtree1[1].style.edge_style.stroke = \"blue\"\nmtree1[1].style.edge_style.stroke_opacity = 1.0\n</pre> mtree1[0].style.edge_colors = \"red\" mtree1[0].style.edge_widths = 10 mtree1[0].style.edge_style.stroke_opacity = 1.0 mtree1[1].style.edge_style.stroke = \"blue\" mtree1[1].style.edge_style.stroke_opacity = 1.0 In\u00a0[\u00a0]: Copied! <pre>cons.draw(axes=a, tip_labels=False, edge_colors=\"red\", edge_type='b');\nc\n</pre> cons.draw(axes=a, tip_labels=False, edge_colors=\"red\", edge_type='b'); c In\u00a0[\u00a0]: Copied! <pre>tree = toytree.rtree.unittree(ntips=20)\ntree[0].name = \"A-really-long-string-that-becomes-cutoff-on-pdf-exporting\"\n</pre> tree = toytree.rtree.unittree(ntips=20) tree[0].name = \"A-really-long-string-that-becomes-cutoff-on-pdf-exporting\" In\u00a0[40]: Copied! <pre>c, a, m1 = tree.draw(width=500);\n</pre> c, a, m1 = tree.draw(width=500); A-really-long-string-that-becomes-cutoff-on-pdf-exportingr1r2r3r4r5r6r7r8r9r10r11r12r13r14r15r16r17r18r19 In\u00a0[74]: Copied! <pre>c, a, m2 = tree.draw(width=500, shrink=500);\nimport toyplot.pdf\ntoyplot.pdf.render(c, \"/tmp/longname.pdf\")\n</pre> c, a, m2 = tree.draw(width=500, shrink=500); import toyplot.pdf toyplot.pdf.render(c, \"/tmp/longname.pdf\") In\u00a0[32]: Copied! <pre>canvas, axes, mark = tree.draw(width=500, tip_labels=False)\naxes.text(\n    [0] * tree.ntips,\n    range(tree.ntips),\n    tree.get_tip_labels(),\n    annotation=False,\n    style={\"text-anchor\": \"start\", \"fill\": \"black\", \"-toyplot-anchor-shift\": 10},\n)\n</pre> canvas, axes, mark = tree.draw(width=500, tip_labels=False) axes.text(     [0] * tree.ntips,     range(tree.ntips),     tree.get_tip_labels(),     annotation=False,     style={\"text-anchor\": \"start\", \"fill\": \"black\", \"-toyplot-anchor-shift\": 10}, ) Out[32]: <pre>&lt;toyplot.mark.Text at 0x7fcbba798970&gt;</pre> A-really-long-string-that-becomes-cutoff-on-pdf-exportingr1r2r3r4r5r6r7r8r9r10r11r12r13r14r15r16r17r18r19 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"consensus-trees/#consensus-trees","title":"Consensus trees\u00b6","text":""},{"location":"consensus-trees/#same-topology-variable-edge-lengths-non-ultrametric-trees","title":"Same topology, variable edge lengths, non-ultrametric trees\u00b6","text":"<p>This is an example of a set of trees you might get as a result of running phylogenetic inference on a collection of different data sets for the same taxa using a non-clock model. A consensus tree approach provides a simple and fast way to compare trees by finding the most commonly supported clades, and their frequency. It may also be of interest to see the relative branch lengths which are stored in features like <code>dist_mean</code> and <code>dist_std</code> for each node.  With this type of dataset you would most likely want to apply a species tree inference approach, such as ASTRAL, as a model-based approach of examining the agreement among trees.</p>"},{"location":"consensus-trees/#example-xiphophorus-fishes","title":"Example: Xiphophorus fishes\u00b6","text":"<p>Data set for reconstructing a densitree figure from Cui et al. (2013). I\u2019ve taken the nexus file from the paper\u2019s dryad repository and converted it to newick and saved it online so it can be easily downloaded. The file contains 160 trees representing mrbayes consensus trees inferred for different genomic regions.</p>"},{"location":"consensus2/","title":"Consensus2","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[30]: Copied! <pre># a set of simple ultrametric trees\ntrees = ...\n</pre> # a set of simple ultrametric trees trees = ... In\u00a0[24]: Copied! <pre># a set of ultrametric (and presumably) rooted trees\naligned_rooted_trees = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\")\n</pre> # a set of ultrametric (and presumably) rooted trees aligned_rooted_trees = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\") In\u00a0[\u00a0]: Copied! <pre># a set of non-ultrametric unrooted trees\nunaligned_unrooted_trees = toytree...\n</pre> # a set of non-ultrametric unrooted trees unaligned_unrooted_trees = toytree... In\u00a0[25]: Copied! <pre>fish\n</pre> fish Out[25]: <pre>&lt;toytree.MultiTree ntrees=160&gt;</pre> In\u00a0[28]: Copied! <pre># ctree = fish.get_consensus_tree(ultrametric=True)\n</pre> # ctree = fish.get_consensus_tree(ultrametric=True) In\u00a0[29]: Copied! <pre>fish[6].draw();\n</pre> fish[6].draw(); PriapellaPsjonesiiXclemenciae_GXsignumXalvareziXmayaeXmonticolusXhelleriiXandersiXcouchianusXgordoniXmeyeriXvariatusXxiphidiumXevelynaeXmilleriXmaculatus_JpWildXcorteziXnezahuacoyotlXmalinche_CHIC2Xbirchmanni_GARCXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensis In\u00a0[17]: Copied! <pre>ctree.mod.root_on_minimal_ancestor_deviation(48).draw();\n</pre> ctree.mod.root_on_minimal_ancestor_deviation(48).draw(); Xbirchmanni_GARCXmalinche_CHIC2XcorteziXnezahuacoyotlXmontezumaeXmultilineatusXnigrensisXcontinensXpygmaeusXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXgordoniXmeyeriXcouchianusXvariatusXevelynaeXmilleriXxiphidiumXandersiXmaculatus_JpWildPriapellaPsjonesii In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"consensus2/#consensus-trees","title":"Consensus trees\u00b6","text":"<p>A consensus tree represents an amalgamation of information from multiple trees, usually sharing the same sets of tips. For example, a majority-rule consensus tree represents a tree composed of the most frequently observed clades among a set of trees. Consensus trees often include minimum cut-off values such that nodes are collapsed if a clade is not observed at least some minimum proportion of the time. Consensus trees can also be used to represent more complex results, such as the mean edge length, node height, or trait value observed for each clade in a tree. For exapmle, these values are commonly reported in Bayesian tree inference as the marginal posterior values.</p>"},{"location":"consensus2/#inferring-consensus-trees","title":"Inferring consensus trees\u00b6","text":"<p>Let's start by creating three different sets of trees. The first varies in topology, the second varies only in internal node heights but all trees are ultrametric (e.g., a posterior distribution of trees from mrbayes), and the last varies in all edge lengths such that trees are not ultrametric (e.g., a set of maximum likelihood inferred gene trees).</p>"},{"location":"consensus2/#example-datasets","title":"Example datasets\u00b6","text":""},{"location":"consensus2/#rooting-of-consensus-trees","title":"Rooting of consensus trees\u00b6","text":"<p>A set of input trees may be rooted or unrooted. For example, a set of bootstrap trees from a Maximum Likelihood analysis will typically contain many unrooted trees, whereas a posterior distribution of trees from a Bayesian tree inference analysis will usually contain many rooted trees. The distinction of whether the trees are rooted or not can have implications on the ... By default, <code>toytree</code> will attempt to auto-detect whether the trees are rooted or not, but this behavior can be overridden by using the argument ...</p>"},{"location":"consensus2/#consensus-features","title":"Consensus features\u00b6","text":""},{"location":"consensus2/#dist-values","title":"dist values\u00b6","text":"<p><code>dist</code> values (edge lengths) ...</p>"},{"location":"consensus2/#height-values","title":"height values\u00b6","text":"<p>...</p>"},{"location":"consensus2/#support-values","title":"support values\u00b6","text":"<p>...</p>"},{"location":"consensus2/#other-featuresdata","title":"other features/data\u00b6","text":"<p>...</p>"},{"location":"contribute/","title":"Contributing","text":"<p>Collaborator's are very welcome!</p> <p>If you haven\u2019t already, you\u2019ll want to first get familiar with the <code>toytree</code> repository at http://github.com/eaton-lab/toytree.  There you will find the source code and issue tracker where you can inquire about ongoing development, discuss planned contributions, and volunteer to take on known issues or future planned developments.</p>"},{"location":"contribute/#organization","title":"Organization","text":"<p>As of <code>toytree</code> v.3.0 the code base has been reorganized explicitly to better facilitate collaborative development. This involves the organization of code into a nested hierarchy of subpackages that share common themes. Many of these have a clear template structure which can be easily modified or extended to create new useful methods. For example, a new method could be created for annotating drawings within the <code>annotation</code> subpackage, or a new method for modifying a tree could be created in the <code>mod</code> subpackage. </p>"},{"location":"contribute/#getting-started","title":"Getting started","text":"<p>To contribute as a developer you'll need to install <code>toytree</code> from source on GitHub and install additional dependencies used for testing the code. My workflow for this is to clone the repository (in your case, a fork of the repo) and install in development mode using pip.</p> <pre><code># install dependencies from conda\n$ conda install toytree -c eaton-lab --only-deps\n\n# clone the repo and cd into it\n$ git clone https://github.com/eaton-lab/toytree.git\n$ cd toytree/\n\n# call pip install in 'development mode' (note the '-e .')\n$ pip install -e .\n</code></pre>"},{"location":"contribute/#coding-style","title":"Coding Style","text":"<p>The Toyplot source code follows the PEP-8 Style Guide for Python Code.</p>"},{"location":"core/","title":"Core toytree class objects","text":"<p>...</p>"},{"location":"data/","title":"Data/Features","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport toyplot\nimport numpy as np\n</pre> import toytree import toyplot import numpy as np In\u00a0[2]: Copied! <pre># an example tree\ntree = toytree.rtree.unittree(ntips=5, seed=123)\n</pre> # an example tree tree = toytree.rtree.unittree(ntips=5, seed=123) In\u00a0[3]: Copied! <pre># set the feature \"X\" to a value of 10 on all Nodes in a tree\ntree.set_node_data(feature=\"X\", default=10, inplace=True);\n</pre> # set the feature \"X\" to a value of 10 on all Nodes in a tree tree.set_node_data(feature=\"X\", default=10, inplace=True); In\u00a0[4]: Copied! <pre># get the values of \"X\" for all Nodes in idx traversal order\ntree.get_node_data(\"X\")\n</pre> # get the values of \"X\" for all Nodes in idx traversal order tree.get_node_data(\"X\") Out[4]: <pre>0    10\n1    10\n2    10\n3    10\n4    10\n5    10\n6    10\n7    10\n8    10\ndtype: int64</pre> In\u00a0[5]: Copied! <pre># chain the two functions together to set &amp; get values for a feature\ntree.set_node_data(\"X\", default=10).get_node_data(\"X\")\n</pre> # chain the two functions together to set &amp; get values for a feature tree.set_node_data(\"X\", default=10).get_node_data(\"X\") Out[5]: <pre>0    10\n1    10\n2    10\n3    10\n4    10\n5    10\n6    10\n7    10\n8    10\ndtype: int64</pre> In\u00a0[6]: Copied! <pre># all feature names assigned to at least one Node in this tree\ntree.features\n</pre> # all feature names assigned to at least one Node in this tree tree.features Out[6]: <pre>('idx', 'name', 'height', 'dist', 'support', 'X')</pre> In\u00a0[7]: Copied! <pre># set a value for the attribute (feature) named \"Z\" on two Nodes\ntree[0].Z = \"A\"\ntree[1].Z = \"B\"\n</pre> # set a value for the attribute (feature) named \"Z\" on two Nodes tree[0].Z = \"A\" tree[1].Z = \"B\" <p>When the <code>get_node_data</code> function is called without any features selected it returns a dataframe showing all features on the current tree. Here, this tree includes the five default features in addition to the new feature \"X\" for which we assigned a value of 10 to all Nodes above, and it also includes the attribute \"Z\", which has been assigned to only two Nodes in the tree. For other Nodes that do not contain a \"Z\" feature a default missing value of NaN (numpy.nan) is returned in the dataframe (but note, NaN is not assigned to the \"Z\" attribute of the other Nodes by this function).</p> In\u00a0[8]: Copied! <pre># return a dataframe with all feature data\ntree.get_node_data()\n</pre> # return a dataframe with all feature data tree.get_node_data() Out[8]: idx name height dist support X Z 0 0 r0 0.000000 0.333333 NaN 10 A 1 1 r1 0.000000 0.333333 NaN 10 B 2 2 r2 0.000000 0.666667 NaN 10 NaN 3 3 r3 0.000000 0.666667 NaN 10 NaN 4 4 r4 0.000000 0.666667 NaN 10 NaN 5 5 0.333333 0.333333 NaN 10 NaN 6 6 0.666667 0.333333 NaN 10 NaN 7 7 0.666667 0.333333 NaN 10 NaN 8 8 1.000000 0.000000 NaN 10 NaN In\u00a0[9]: Copied! <pre># set data to feature \"Y\" for two Nodes \ndata = {0: 10, 1: 20, 2: 30}\ntree.set_node_data(\"Y\", data=data).get_node_data(\"Y\")\n</pre> # set data to feature \"Y\" for two Nodes  data = {0: 10, 1: 20, 2: 30} tree.set_node_data(\"Y\", data=data).get_node_data(\"Y\") Out[9]: <pre>0    10.0\n1    20.0\n2    30.0\n3     NaN\n4     NaN\n5     NaN\n6     NaN\n7     NaN\n8     NaN\ndtype: float64</pre> <p>In this example the data dictionary selects nodes using a variety of Node Queries. The first is a regular expression that matches the first four nodes in the tree, the second matches the node named \"r4\", and the last matches the node with int index of 8. Finally, we use the <code>default</code> arg to set a value of 0 to all other Nodes not selected in the data dict. In this way, we easily assigned to all 9 nodes in the tree without having to write a value for each.</p> In\u00a0[10]: Copied! <pre># set data to feature \"Y\" using a dict w/ node queries, and the default arg\ndata = {\"~r[0-3]\": 10, \"r4\": 20, 8: 50}\ntree.set_node_data(feature=\"Y\", data=data, default=0).get_node_data(\"Y\")\n</pre> # set data to feature \"Y\" using a dict w/ node queries, and the default arg data = {\"~r[0-3]\": 10, \"r4\": 20, 8: 50} tree.set_node_data(feature=\"Y\", data=data, default=0).get_node_data(\"Y\") Out[10]: <pre>0    10\n1    10\n2    10\n3    10\n4    20\n5     0\n6     0\n7     0\n8    50\ndtype: int64</pre> <p>The <code>inherit</code> arg provides another convenient way to assign data to Nodes in a tree based on their hierarchical relationships. For example, to assign a trait value that is inherited by all descendants of a particular node in a tree you need only to assign the value to one or more internal nodes while using the <code>inherit=True</code> argument. The inherited values are assigned to nodes in order from root to tips so that you can enter values for nested clades using this argument.</p> In\u00a0[11]: Copied! <pre># set data to feature \"Y\" for a clade using inherit=True\ntree.set_node_data(\"Y\", data={6: True}, inherit=True).get_node_data(\"Y\")\n</pre> # set data to feature \"Y\" for a clade using inherit=True tree.set_node_data(\"Y\", data={6: True}, inherit=True).get_node_data(\"Y\") Out[11]: <pre>0    True\n1    True\n2    True\n3     NaN\n4     NaN\n5    True\n6    True\n7     NaN\n8     NaN\ndtype: object</pre> In\u00a0[12]: Copied! <pre># set data using an array of random int values\ndata = np.random.randint(10, 20, size=tree.nnodes)\ntree.set_node_data(feature=\"Y\", data=data).get_node_data(\"Y\")\n</pre> # set data using an array of random int values data = np.random.randint(10, 20, size=tree.nnodes) tree.set_node_data(feature=\"Y\", data=data).get_node_data(\"Y\") Out[12]: <pre>0    14\n1    11\n2    19\n3    10\n4    16\n5    11\n6    17\n7    14\n8    15\ndtype: int64</pre> In\u00a0[13]: Copied! <pre># return values for feature \"dist\"\ntree.get_node_data(feature=\"dist\")\n</pre> # return values for feature \"dist\" tree.get_node_data(feature=\"dist\") Out[13]: <pre>0    0.333333\n1    0.333333\n2    0.666667\n3    0.666667\n4    0.666667\n5    0.333333\n6    0.333333\n7    0.333333\n8    0.000000\ndtype: float64</pre> In\u00a0[14]: Copied! <pre># return values for feature 'Z' which has data for only 2 Nodes\ntree.get_node_data(\"Z\")\n</pre> # return values for feature 'Z' which has data for only 2 Nodes tree.get_node_data(\"Z\") Out[14]: <pre>0      A\n1      B\n2    NaN\n3    NaN\n4    NaN\n5    NaN\n6    NaN\n7    NaN\n8    NaN\ndtype: object</pre> In\u00a0[15]: Copied! <pre># return values for feature 'Z' with an imputed missing value\ntree.get_node_data(\"Z\", missing=\"C\")\n</pre> # return values for feature 'Z' with an imputed missing value tree.get_node_data(\"Z\", missing=\"C\") Out[15]: <pre>0    A\n1    B\n2    C\n3    C\n4    C\n5    C\n6    C\n7    C\n8    C\ndtype: object</pre> <p>The pandas Series object is convenient to work with since it is accepted by many other <code>toytree</code> functions as input, and can can be easily converted to other object types, as demonstrated below.</p> In\u00a0[16]: Copied! <pre># convert a single trait Series to a dict\ntree.get_node_data(\"Z\", missing=\"C\").to_dict()\n</pre> # convert a single trait Series to a dict tree.get_node_data(\"Z\", missing=\"C\").to_dict() Out[16]: <pre>{0: 'A', 1: 'B', 2: 'C', 3: 'C', 4: 'C', 5: 'C', 6: 'C', 7: 'C', 8: 'C'}</pre> In\u00a0[17]: Copied! <pre># convert a single trait Series to a numpy ndarray\ntree.get_node_data(\"Z\", missing=\"C\").values\n</pre> # convert a single trait Series to a numpy ndarray tree.get_node_data(\"Z\", missing=\"C\").values Out[17]: <pre>array(['A', 'B', 'C', 'C', 'C', 'C', 'C', 'C', 'C'], dtype=object)</pre> In\u00a0[18]: Copied! <pre># return Node values for all features\ntree.get_node_data()\n</pre> # return Node values for all features tree.get_node_data() Out[18]: idx name height dist support X Z 0 0 r0 0.000000 0.333333 NaN 10 A 1 1 r1 0.000000 0.333333 NaN 10 B 2 2 r2 0.000000 0.666667 NaN 10 NaN 3 3 r3 0.000000 0.666667 NaN 10 NaN 4 4 r4 0.000000 0.666667 NaN 10 NaN 5 5 0.333333 0.333333 NaN 10 NaN 6 6 0.666667 0.333333 NaN 10 NaN 7 7 0.666667 0.333333 NaN 10 NaN 8 8 1.000000 0.000000 NaN 10 NaN In\u00a0[19]: Copied! <pre># return values for two features, with different imputed missing values\ntree.get_node_data([\"support\", \"Z\"], missing=[100, \"C\"])\n</pre> # return values for two features, with different imputed missing values tree.get_node_data([\"support\", \"Z\"], missing=[100, \"C\"]) Out[19]: support Z 0 100 A 1 100 B 2 100 C 3 100 C 4 100 C 5 100 C 6 100 C 7 100 C 8 100 C In\u00a0[20]: Copied! <pre># set a color name as 'red' or 'blue' to all nodes for feature \"C\"\ntree.set_node_data(\"C\", {6: \"red\"}, inherit=True, default=\"blue\", inplace=True).get_node_data(\"C\")\n</pre> # set a color name as 'red' or 'blue' to all nodes for feature \"C\" tree.set_node_data(\"C\", {6: \"red\"}, inherit=True, default=\"blue\", inplace=True).get_node_data(\"C\") Out[20]: <pre>0     red\n1     red\n2     red\n3    blue\n4    blue\n5     red\n6     red\n7    blue\n8    blue\ndtype: object</pre> In\u00a0[21]: Copied! <pre># set random float values in (0-1) to all nodes for feature \"D\"\ntree.set_node_data(\"D\", np.random.random(tree.nnodes), inplace=True).get_node_data(\"D\")\n</pre> # set random float values in (0-1) to all nodes for feature \"D\" tree.set_node_data(\"D\", np.random.random(tree.nnodes), inplace=True).get_node_data(\"D\") Out[21]: <pre>0    0.773484\n1    0.840667\n2    0.503796\n3    0.736419\n4    0.374351\n5    0.737745\n6    0.537203\n7    0.387983\n8    0.136558\ndtype: float64</pre> <p>(1) The first method for extracting data from a tree to use for plotting makes use of the <code>get_node_data</code> function call. Here we call the function from the same tree object that is being plotted, and select the feature \"C\" of discrete data values. This returns a Series object with the values in the correct order (idxorder) for plotting on the nodes, which are then parsed as a <code>node_colors</code> argument.</p> In\u00a0[22]: Copied! <pre># draw with node colors entered from the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=tree.get_node_data(\"C\"));\n</pre> # draw with node colors entered from the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=tree.get_node_data(\"C\")); r0r1r2r3r4 <p>(2) The second method for extracting data from a tree uses a simpler syntax, entering only the feature name as a string to the <code>node_colors</code> argument. Here, the <code>draw</code> function will identify that \"C\" is a valid feature of this tree object, and it will extract the \"C\" feature data from the tree. Compared to the syntax above, this looks cleaner, but has the downside that you cannot enter additional options to fill a value for missing data.</p> In\u00a0[23]: Copied! <pre># draw with node colors automatically extracted from the \"C\" feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=\"C\");\n</pre> # draw with node colors automatically extracted from the \"C\" feature tree.draw(node_sizes=15, node_mask=False, node_colors=\"C\"); r0r1r2r3r4 <p>(3) The third method uses toytree's \"tuple syntax\" that is used for range and color mapping (See range-mapping and color-mapping). For colors, you can enter (feature name, colormap, min-value, max-value, nan-value), to map any feature to any range of colors in a colormap. Only the first argument is required, with additional args providing style options, as shown below.</p> In\u00a0[24]: Copied! <pre># draw with node colors extracted and colormapped from the \"C\" feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=(\"C\",));\n</pre> # draw with node colors extracted and colormapped from the \"C\" feature tree.draw(node_sizes=15, node_mask=False, node_colors=(\"C\",)); r0r1r2r3r4 In\u00a0[25]: Copied! <pre># draw with node colors extracted and colormapped to BlueRed from \"C\"\ntree.draw(node_sizes=15, node_mask=False, node_colors=(\"C\", \"BlueRed\"));\n</pre> # draw with node colors extracted and colormapped to BlueRed from \"C\" tree.draw(node_sizes=15, node_mask=False, node_colors=(\"C\", \"BlueRed\")); r0r1r2r3r4 In\u00a0[26]: Copied! <pre># draw with node colors extracted and colormapped to BlueRed from \"D\"\ntree.draw(node_sizes=15, node_mask=False, node_colors=(\"D\", \"BlueRed\"));\n</pre> # draw with node colors extracted and colormapped to BlueRed from \"D\" tree.draw(node_sizes=15, node_mask=False, node_colors=(\"D\", \"BlueRed\")); r0r1r2r3r4 In\u00a0[27]: Copied! <pre># draw a feature as EDGE data \ntree.draw(\n    node_mask=False, \n    node_labels=\"idx\", \n    node_labels_style={'font-size': 18},\n    node_as_edge_data=True,\n);\n</pre> # draw a feature as EDGE data  tree.draw(     node_mask=False,      node_labels=\"idx\",      node_labels_style={'font-size': 18},     node_as_edge_data=True, ); 0123456r0r1r2r3r4 In\u00a0[28]: Copied! <pre># draw a feature as EDGE data for the same tree, unrooted.\ntree.unroot().draw(\n    node_mask=False, \n    node_labels=\"idx\", \n    node_labels_style={'font-size': 18},\n    node_as_edge_data=True,\n);\n</pre> # draw a feature as EDGE data for the same tree, unrooted. tree.unroot().draw(     node_mask=False,      node_labels=\"idx\",      node_labels_style={'font-size': 18},     node_as_edge_data=True, ); 0123456r0r1r2r3r4 <p>Annotation methods can also be used to plot edge data. See the annotation docs.</p> In\u00a0[29]: Copied! <pre># annotate a tree with EDGE data\ncanvas, axes, mark = tree.draw();\ntree.annotate.add_edge_labels(axes=axes, labels=\"idx\", font_size=18, mask=False);\n</pre> # annotate a tree with EDGE data canvas, axes, mark = tree.draw(); tree.annotate.add_edge_labels(axes=axes, labels=\"idx\", font_size=18, mask=False); r0r1r2r3r40123456"},{"location":"data/#datafeatures","title":"Data/Features\u00b6","text":"<p>A common mistake that users make when working with tree data arises from incorrectly assigning trait values to nodes of the tree. This is most prevalent when trait data are stored in a matrix or dataframe separate from the tree object itself, and operations such as re-rooting or ladderizing are applied to the tree. It is important that trees and trait data are kept in sync. To avoid this problem, we recommend using <code>ToyTree</code> objects themselves as the primary data storage object in your analyses. It is very simple to assign data to nodes of a tree, and to fetch data back from a tree as a dataframe, or in various alternative formats. A recommended workflow for working with data on trees is demonstrated in this section.</p>"},{"location":"data/#simple-example","title":"Simple Example\u00b6","text":"<p>The functions <code>set_node_data</code> and <code>get_node_data</code> provide a broad suite of functionality for setting data to one or more nodes on a tree and subsequently fetching the data back in a variety of formats, and in the correct order for plotting. By default the data setting function returns a modified copy of the tree with new data assigned, however, you can optionally use the argument <code>inplace=True</code> to set data on the tree object inplace. In either case, a tree is returned by the function, which allows for optionally chaining it with the data getter function to subsequently return the data for one or more node features.</p>"},{"location":"data/#features","title":"Features\u00b6","text":"<p>In <code>toytree</code> terminology a \"feature\" refers the name of trait for which data is stored to nodes in a tree. For example, each <code>ToyTree</code> has several data features by default, such as <code>name</code>, <code>dist</code>, and <code>support</code>. You can create and store data under any arbitrary feature name (except for a few disallowed names and characters), and, in fact when you load a tree from a newick, NHX, or NEXUS formatted data file created by a phylogenetic tree inference program, it will often contain additional metadata that will be loaded as features. Several examples of this are shown in tree parsing documentation. A <code>ToyTree</code> contains a dynamic propery <code>.features</code> containing all feature names currently assigned to that tree. (This includes any feature that is assigned to at least one Node in the tree, but it does not need to be assigned to every Node in the tree.)</p>"},{"location":"data/#data-as-node-attributes","title":"Data as Node attributes\u00b6","text":"<p>When storing data to a <code>ToyTree</code> it is actually stored to individual <code>Node</code> objects as Node attributes. This is demonstrated below where data is assigned to a feature named \"Z\" for two Nodes in the tree. Setting and retrieving data directly from Nodes as attributes like this is the fastest way to set/get data, and is thus especially useful for developers. However, for general <code>toytree</code> usage, we recommend using the helper functions <code>set_node_data</code> and <code>get_node_data</code> to set and retrieve data as they provide a number of benefits, especially in terms of dealing with missing values, checking data types, and ordering data values.</p>"},{"location":"data/#set-node-data","title":"Set Node data\u00b6","text":"<p>The <code>set_node_data</code> function is the general recommended way to assign data to nodes on a tree. Data can be entered using either a dictionary or sequence of values, and a number of options are available to make it easier to assign values to many nodes without having to type each out individually. A related function is also available, <code>set_node_data_from_dataframe</code>, which allows setting multiple features at the same time from tabular data loaded as a pandas DataFrame. Here, however, we will focus on adding single features at a time.</p>"},{"location":"data/#setting-data-by-dict","title":"Setting data by dict\u00b6","text":"<p>The simplest way to enter specific data values is by using a dictionary. The keys of the dictionary can correspond to any valid Node Query to select one or more Nodes, and the corresponding value will be assigned to these Nodes. Notably, you can enter a dict selecting only a few Nodes and a feature will be assigned to those Nodes, and not to any of the other Nodes not entered in the dict. If you want to assign a default value to all other nodes you can do so using  <code>default</code> argument. Finally, the argument <code>inherit</code> can be used to also assign a value to all descendants of a selected Node. Examples of each of these is shown below.</p>"},{"location":"data/#setting-data-by-array","title":"Setting data by array\u00b6","text":"<p>You can alternatively set data to all Nodes in a tree by entering the values as a sequence (e.g., list, ndarray, Series) in Node idx order. Note that this requires you to have already properly ordered your input data and to be aware of the Node idx order of your current tree. Thus, this method is more error prone than assigning data by dictionary. Nevertheless, the option is available. Here we use it to assign random integer values to all Nodes by using the <code>numpy.random</code> library to generate an array of random ints.</p>"},{"location":"data/#get-node-data","title":"Get Node data\u00b6","text":"<p>The <code>get_node_data</code> function is used to retrieve feature data that has been assigned to Nodes in a tree, and to return them in the correct idx order for plotting. Data can be returned for a single feature as a pandas Series, or for multiple features as a pandas DataFrame. When a feature has not been assigned to all Nodes in a tree a default value of <code>np.nan</code> will be returned for missing values, but this can be changed to any arbitrary alternative value by entering an argument for the option <code>missing</code>.</p>"},{"location":"data/#get-a-single-feature","title":"Get a single feature\u00b6","text":"<p>By entering the name of a feature in the tree a pandas Series will be returned with all of the Node values for that feature. Here the Series index contains Node idx labels representing the Nodes in an idxorder traversal of the tree.</p>"},{"location":"data/#get-multiple-features","title":"Get multiple features\u00b6","text":"<p>By default the <code>get_node_data</code> function returns a DataFrame with data for all features in a tree. In addition to the option to subselect a single feature from the tree, as shown above, you can also select a subset of features to return a DataFrame containing just those features. Finally, an important feature of this function is its application for dealing with missing data. The <code>missing</code> argument can accept either a single value to assign to all missing values in the DataFrame, or a list of values to apply separately to each column.</p>"},{"location":"data/#using-features","title":"Using features\u00b6","text":"<p>One of the primary uses for assigning data to nodes on a tree is to visualize the data. Many arguments to the tree drawing functions accept values to designate the size, color, width, etc. of nodes or edges. These can be entered in three main ways: (1) by extracting the data as a Series using <code>get_node_data</code>; (2) by entering the feature name directly as an argument; and (3) by using range or color mapping. The latter to cases simply provide a shorthand syntax for plotting a feature which use <code>get_node_data</code> under the hood. Examples are shown below for the two features, \"C\" and \"D\", representing a discrete and continuous data set.</p>"},{"location":"data/#node-vs-edge-features","title":"Node vs Edge features\u00b6","text":"<p>Some data stored to a tree are intended to represent information about the edges (splits) in a tree, rather than information about the nodes. This is important as these types of data must be treated differently when doing things like re-rooting a tree, and in some cases, for visualization. (See the rooting tutorial for an example of how this is automatically handled in <code>toytree</code>.) Any feature can be optionally plotted as a marker and/or label on edges of a tree rather than on nodes. This can be done in a simple way within the <code>.draw</code> function by using the argument <code>node_as_edge_data=True</code>, or, it can be done with many more options by using functions in the <code>toytree.annotate</code> subpackage.</p> <p>Examples of plotted edge features are shown below. These have a few key features in visualization: (1) values are plotted on the midpoint of edges; (2) No value is shown for the root edge, since it does not represent a true split in the tree; and (3) only one of the two edges descended from the root show a value, since these are actually the same edge, but on which the root node has been placed. As an example of this last point, a value such as a support score, or edge length, is a feature of this entire edge. Thus, the value is the same whether the tree is rooted or unrooted, as shown below.</p>"},{"location":"debug-canvas/","title":"Debugging Canvas, Axes, and Data Bounds","text":"<p><code>toytree.utils.debug_toyplot_canvas()</code> adds translucent fills to a Toyplot canvas and axes so you can see layout regions at a glance. This is useful when tuning <code>margin</code>, <code>padding</code>, and label offsets.</p>"},{"location":"debug-canvas/#what-the-layers-mean","title":"What the layers mean","text":"<ul> <li>Canvas (background color): the full canvas area.</li> <li>Padding (outer band): axes range expanded by <code>axes.padding</code>.</li> <li>Axes: the axes range itself.</li> <li>Data: the bounds of the marks, computed from mark extents.</li> </ul>"},{"location":"debug-canvas/#example","title":"Example","text":"<pre><code>import toytree\n\n# draw a tree and keep the returned mark\ntree = toytree.rtree.unittree(10)\nc, a, m = tree.draw(layout=\"r\", tip_labels=True)\n\n# show axes so the ranges are visible\na.x.show = True\na.y.show = True\n\n# add debug fills (data bounds computed from mark extents)\ntoytree.utils.debug_toyplot_canvas(c, a, marks=m)\n\n# display in notebook\nc\n</code></pre>"},{"location":"debug-canvas/#custom-colors","title":"Custom colors","text":"<pre><code>toytree.utils.debug_toyplot_canvas(\n    c,\n    a,\n    marks=m,\n    canvas_style={\"background-color\": \"#fafafa\"},\n    padding_style={\"fill\": \"#ffb3b3\", \"opacity\": 0.2},\n    axes_style={\"fill\": \"#b3d9ff\", \"opacity\": 0.2},\n    data_style={\"fill\": \"#b8e3b1\", \"opacity\": 0.35},\n)\n</code></pre>"},{"location":"debug-canvas/#multiple-axes","title":"Multiple axes","text":"<p>If you have multiple axes (e.g., grid layouts), pass a list of axes and a corresponding list of marks (or a mapping from axes to marks):</p> <pre><code>toytree.utils.debug_toyplot_canvas(\n    c,\n    [ax1, ax2],\n    marks=[mark1, mark2],\n)\n</code></pre>"},{"location":"docs-drafts/","title":"Docs drafts","text":"<p>\"\"\"Generator of bipartitions (Nodes on either side of edges).</p> <pre><code>Bipartitions represent the splits in a tree. Many algorithms compare\ntips (or internal Nodes) on either side of each split to compute\nmetrics on trees. This function aims to provide a flexible and fast\nframework for yielding bipartitions in various formats.\n\nNotes\n-----\n- Bipartitions are generated in Node idx traversal order.\n- Bipartitions are formatted as a tuple of two items, each of\nwhich is referred to as a partition.\n- The order of partitions, e.g. (part1, part2) can be toggled using\nthe argument `sort`.\n- The type used to represent a partition can be toggled using the\nargument `type`. Common formats are `set` or `tuple`.\n\nParameters\n----------\nfeature: str\n    Feature to return to represent Nodes on either side of a\n    bipartition. Default is \"name\". None will return Node objects.\n    Any other Node feature, such as \"idx\" can also be used. Note\n    the feature arg does not affect the order in which partitions\n    or bipartitions are returned/sorted (see `sort` argument below).\ninclude_singleton_partitions: bool\n    If True then singleton splits (e.g., (A | B,C,D)) are included\n    in the result. By default these are excluded since it is\n    implicit that one exists for every tip Node in a tree.\ninclude_internal_nodes: bool\n    Default is to only show tip Nodes on either side of a\n    bipartition, but internal Nodes can be included as well. In\n    this case the results are easier to interpret if the returned\n    values have unique features (e.g., feature=None or 'idx').\ntype: Callable\n    The type of collection used to represent a partition. Default\n    is `set` to return a tuple of sets, but another useful option\n    is `tuple`, which returns a tuple of tuples. The latter\n    collection can be converted into a set of bipartitions.\nsort: bool\n    If False, bipartitions are returned as (child, parent) order\n    given the topology and rooting in Node idx order traversal. If\n    sort=True, bipartitions are instead always sorted first by len,\n    e.g., (fewer, longer) and if the same len, then next by the\n    lowest alphanumeric tip name, e.g., ({'a', 'b'}, {'c', 'd'}).\n    If the requested partition `type` is sortable (i.e., not a set)\n    then items within a partition are also consistently sorted.</code></pre> <p>In this example, a <code>toytree</code> object taking a simple newick string is split into bipartitions, which are then printed as a <code>multitree</code> object.</p> In\u00a0[\u00a0]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[\u00a0]: Copied! <pre>#draw initial tree\ntree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\")\ntree.draw()\n</pre> #draw initial tree tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\") tree.draw() <pre>(&lt;toyplot.canvas.Canvas at 0x22f43df4740&gt;,\n &lt;toyplot.coordinates.Cartesian at 0x22f440e73b0&gt;,\n &lt;toytree.drawing.src.mark_toytree.ToyTreeMark at 0x22f43926e70&gt;)</pre> abcdef In\u00a0[\u00a0]: Copied! <pre>#make multitree from bipartitions\nbipartitions = tree.enum.iter_bipartitions(feature=None)\nbipartitions_list = list(bipartitions)\nprint(bipartitions_list)\n</pre> #make multitree from bipartitions bipartitions = tree.enum.iter_bipartitions(feature=None) bipartitions_list = list(bipartitions) print(bipartitions_list) <pre>[({&lt;Node(idx=2, name='c')&gt;, &lt;Node(idx=3, name='d')&gt;}, {&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=5, name='f')&gt;, &lt;Node(idx=1, name='b')&gt;, &lt;Node(idx=4, name='e')&gt;}), ({&lt;Node(idx=5, name='f')&gt;, &lt;Node(idx=4, name='e')&gt;}, {&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=2, name='c')&gt;, &lt;Node(idx=1, name='b')&gt;, &lt;Node(idx=3, name='d')&gt;}), ({&lt;Node(idx=5, name='f')&gt;, &lt;Node(idx=2, name='c')&gt;, &lt;Node(idx=3, name='d')&gt;, &lt;Node(idx=4, name='e')&gt;}, {&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=1, name='b')&gt;})]\n</pre> <p>Generators to sample quartets of tips from a tree.</p> <p>The primary function <code>iter_quartets</code> can be used as a generator to yield quartet subtrees from a larger tree. This function is quite fast and includes options for sorting the output, and transforming its format to return Node objects, names, or any arbitrary feature of Nodes. See examples.</p> In\u00a0[\u00a0]: Copied! <pre>#asdf\n</pre> #asdf In\u00a0[\u00a0]: Copied! <pre>#asdf\n</pre> #asdf <p>asdf</p> In\u00a0[\u00a0]: Copied! <pre>#asdf\n</pre> #asdf In\u00a0[\u00a0]: Copied! <pre>import toytree  \n\ntree = toytree.rtree.unittree(5, seed=123)\ntree1 = tree.mod.add_internal_node_and_child(\"r1\", name=\"r1\")\n# merge nodes with identical leaf names.\ntree2 = tree1.mod.merge_nodes(\"name\")\n# more verbose example to do the same\nmerge_method = lambda x: len(set(x.iter_leaf_names())) == 1\ntree2 = tree1.mod.merge_nodes(merge_method)\ntoytree.mtree([tree1, tree2]).draw();\n</pre> import toytree    tree = toytree.rtree.unittree(5, seed=123) tree1 = tree.mod.add_internal_node_and_child(\"r1\", name=\"r1\") # merge nodes with identical leaf names. tree2 = tree1.mod.merge_nodes(\"name\") # more verbose example to do the same merge_method = lambda x: len(set(x.iter_leaf_names())) == 1 tree2 = tree1.mod.merge_nodes(merge_method) toytree.mtree([tree1, tree2]).draw(); <pre>\n---------------------------------------------------------------------------\n\nAttributeError                            Traceback (most recent call last)\n\nCell In[236], line 6\n\n      4 tree1 = tree.mod.add_internal_node_and_child(\"r1\", name=\"r1\")\n\n      5 # merge nodes with identical leaf names.\n\n----&gt; 6 tree2 = tree1.mod.merge_nodes(\"name\")\n\n      7 # more verbose example to do the same\n\n      8 merge_method = lambda x: len(set(x.iter_leaf_names())) == 1\n\n\n\nAttributeError: 'TreeModAPI' object has no attribute 'merge_nodes'</pre> <p>The toytree .distance subpackage has two main purposes: (1) to provide the user with efficient methods to measure or describe paths between nodes in a tree, and (2) to provide many methods of describing dissimilarities between two trees. All dissimilarity metrics currently implemented are quantified by quartet and bipartition differences, which are explained in  tree distances.</p> In\u00a0[1]: Copied! <pre>import toytree\n\n#generate random topology with 16 tips\ntree = toytree.rtree.rtree(ntips=16)\n\n#draw to show all internal nodes\ntree.draw(ts = 's', tip_labels = False, node_labels = 'idx');\n</pre> import toytree  #generate random topology with 16 tips tree = toytree.rtree.rtree(ntips=16)  #draw to show all internal nodes tree.draw(ts = 's', tip_labels = False, node_labels = 'idx'); 0123456789101112131415161718192021222324252627282930 <p><code>get_node_path</code> returns a list of Nodes connecting two queried Nodes of a tree(including at ends).</p> In\u00a0[2]: Copied! <pre>toytree.distance.get_node_path(tree, 15, 0)\n</pre> toytree.distance.get_node_path(tree, 15, 0) Out[2]: <pre>(&lt;Node(idx=15, name='r15')&gt;,\n &lt;Node(idx=29)&gt;,\n &lt;Node(idx=30)&gt;,\n &lt;Node(idx=28)&gt;,\n &lt;Node(idx=23)&gt;,\n &lt;Node(idx=21)&gt;,\n &lt;Node(idx=18)&gt;,\n &lt;Node(idx=17)&gt;,\n &lt;Node(idx=16)&gt;,\n &lt;Node(idx=0, name='r0')&gt;)</pre> <p>And <code>iter_node_path</code> is the iterative generator version.</p> In\u00a0[3]: Copied! <pre>from toytree.distance import iter_node_path\n\nfor node in iter_node_path(tree, 15, 0):\n    print(node.idx)\n</pre> from toytree.distance import iter_node_path  for node in iter_node_path(tree, 15, 0):     print(node.idx) <pre>15\n29\n30\n28\n23\n21\n18\n17\n16\n0\n</pre> In\u00a0[4]: Copied! <pre>#Newick string generated in R with phylomaker_v2\nnewick = \"(((Sambucus_nigra:112.340729,(Arctostaphylos_viscida:1.761115,Arctostaphylos_patula:1.761115):110.579613)mrcaott248ott650:11.393508,((Lupinus_sparsiflorus:112.701196,(((Ceanothus_leucodermis:4.464401,Ceanothus_cuneatus:4.464401):46.93409,(Frangula_rubra:10.957388,Rhamnus_ilicifolia:10.957388):40.441103):59.749516,(Quercus_douglasii:11.776698,Quercus_wislizeni:11.776699):99.371309)mrcaott371ott2511:1.553188)mrcaott371ott579:5.877408,Aesculus_californica:118.578604)mrcaott2ott96:5.155633)Pentapetalae:201.315791,Pinus_sabiniana:325.050028)Spermatophyta;\"\n\n#generate ToyTree from Newick string\ntree = toytree.tree(newick)\n\ntree.draw('s');\n</pre> #Newick string generated in R with phylomaker_v2 newick = \"(((Sambucus_nigra:112.340729,(Arctostaphylos_viscida:1.761115,Arctostaphylos_patula:1.761115):110.579613)mrcaott248ott650:11.393508,((Lupinus_sparsiflorus:112.701196,(((Ceanothus_leucodermis:4.464401,Ceanothus_cuneatus:4.464401):46.93409,(Frangula_rubra:10.957388,Rhamnus_ilicifolia:10.957388):40.441103):59.749516,(Quercus_douglasii:11.776698,Quercus_wislizeni:11.776699):99.371309)mrcaott371ott2511:1.553188)mrcaott371ott579:5.877408,Aesculus_californica:118.578604)mrcaott2ott96:5.155633)Pentapetalae:201.315791,Pinus_sabiniana:325.050028)Spermatophyta;\"  #generate ToyTree from Newick string tree = toytree.tree(newick)  tree.draw('s');  012345678910111213141516171819202122Sambucus_nigraArctostaphylos_viscidaArctostaphylos_patulaLupinus_sparsiflorusCeanothus_leucodermisCeanothus_cuneatusFrangula_rubraRhamnus_ilicifoliaQuercus_douglasiiQuercus_wislizeniAesculus_californicaPinus_sabiniana <p>Yi Jin, Hong Qian, V.PhyloMaker2: An updated and enlarged R package that can generate very large phylogenies for vascular plants, Plant Diversity, Volume 44, Issue 4, 2022, Pages 335-339, ISSN 2468-2659, https://doi.org/10.1016/j.pld.2022.05.005.</p> <p><code>get_node_distance</code> returns the patristic distance (sum of distances belonging to each edge in shortest path) between two Nodes on a ToyTree.</p> In\u00a0[5]: Copied! <pre>toytree.distance.get_node_distance(tree, 15, 17)\n</pre> toytree.distance.get_node_distance(tree, 15, 17) Out[5]: <pre>199.561928</pre> In\u00a0[6]: Copied! <pre>toytree.distance.get_node_distance(tree, 15, 17, topology_only= True)\n</pre> toytree.distance.get_node_distance(tree, 15, 17, topology_only= True) Out[6]: <pre>3</pre> <p><code>get_node_distance_matrix</code> returns the pairwise distance matrix for every node in the tree. The user can also use <code>get_internal_node_distance_matrix</code> and <code>get_tip_distance_matrix</code> for more specific distance matrices.</p> <p>A matrix is returned as a np.ndarray with rows and columns ordered by Node int idx labels, or as a pd.DataFrame (<code>df=True</code>) with row and column names as str Node names for leaf Nodes and idx labels for internal Nodes.</p> In\u00a0[9]: Copied! <pre>tree.distance.get_internal_node_distance_matrix(df= True, topology_only=True)\n</pre> tree.distance.get_internal_node_distance_matrix(df= True, topology_only=True) Out[9]: 12 13 14 15 16 17 18 19 20 21 22 12 0 1 7 7 6 6 5 4 3 2 3 13 1 0 6 6 5 5 4 3 2 1 2 14 7 6 0 2 1 3 2 3 4 5 6 15 7 6 2 0 1 3 2 3 4 5 6 16 6 5 1 1 0 2 1 2 3 4 5 17 6 5 3 3 2 0 1 2 3 4 5 18 5 4 2 2 1 1 0 1 2 3 4 19 4 3 3 3 2 2 1 0 1 2 3 20 3 2 4 4 3 3 2 1 0 1 2 21 2 1 5 5 4 4 3 2 1 0 1 22 3 2 6 6 5 5 4 3 2 1 0 <p><code>get_descendant_dists</code> returns a dictionary with {Node: dist} pairs of all descendants relative to a queried node. Without a queried node, all descendants/distances are relative to the root node. Values are generated in \"preorder\" traversal order (left then right).</p> <p>An iterable generator <code>iter_descendant_dists</code> is also provided.</p> In\u00a0[11]: Copied! <pre>tree.distance.get_descendant_dists(18)\n</pre> tree.distance.get_descendant_dists(18) Out[11]: <pre>{&lt;Node(idx=18, name='mrcaott371ott2511')&gt;: 0,\n &lt;Node(idx=16)&gt;: 59.749516,\n &lt;Node(idx=14)&gt;: 106.683606,\n &lt;Node(idx=4, name='Ceanothus_leucodermis')&gt;: 111.14800699999999,\n &lt;Node(idx=5, name='Ceanothus_cuneatus')&gt;: 111.14800699999999,\n &lt;Node(idx=15)&gt;: 100.190619,\n &lt;Node(idx=6, name='Frangula_rubra')&gt;: 111.14800699999999,\n &lt;Node(idx=7, name='Rhamnus_ilicifolia')&gt;: 111.14800699999999,\n &lt;Node(idx=17)&gt;: 99.371309,\n &lt;Node(idx=8, name='Quercus_douglasii')&gt;: 111.14800699999999,\n &lt;Node(idx=9, name='Quercus_wislizeni')&gt;: 111.148008}</pre> <p><code>get_farthest_node</code> returns the farthest Node from a selected Node and <code>get_farthest_node_distance</code> returns the distance between the two.</p> In\u00a0[12]: Copied! <pre>node = tree.distance.get_farthest_node(11)\ndist = tree.distance.get_farthest_node_distance(11)\nprint(node, dist)\n</pre> node = tree.distance.get_farthest_node(11) dist = tree.distance.get_farthest_node_distance(11) print(node, dist) <pre>&lt;Node(idx=0, name='Sambucus_nigra')&gt; 650.100056\n</pre> In\u00a0[14]: Copied! <pre>import toytree\n\nt1 = toytree.rtree.rtree(ntips=6, seed=123)\nt2 = toytree.rtree.rtree(ntips=6, seed=321)\n\nt1.draw('s');\nt2.draw('s');\n</pre> import toytree  t1 = toytree.rtree.rtree(ntips=6, seed=123) t2 = toytree.rtree.rtree(ntips=6, seed=321)  t1.draw('s'); t2.draw('s'); 012345678910r0r1r2r3r4r5 012345678910r0r1r2r3r4r5 In\u00a0[3]: Copied! <pre>import toytree\n\ntree1 = toytree.rtree.rtree(ntips=10, seed=123)\ntree2 = toytree.rtree.rtree(ntips=10, seed=321)\ntree1.draw('s')\ntree2.draw('s')\ntoytree.distance.get_treedist_quartets(tree1, tree2)\n</pre> import toytree  tree1 = toytree.rtree.rtree(ntips=10, seed=123) tree2 = toytree.rtree.rtree(ntips=10, seed=321) tree1.draw('s') tree2.draw('s') toytree.distance.get_treedist_quartets(tree1, tree2)  Out[3]: <pre>Q                              210.000000\nS                              107.000000\nD                              103.000000\nU                                0.000000\nR1                               0.000000\nR2                               0.000000\nN                              210.000000\ndo_not_conflict                  0.490476\nexplicitly_agree                 0.490476\nstrict_joint_assertions          0.490476\nsemistrict_joint_assertions      0.490476\nsteel_and_penny                  0.490476\nsymmetric_difference             0.490476\nsymmetric_divergence             0.019048\nsimilarity_to_reference          0.490476\nmarczewski_steinhaus             0.658147\ndtype: float64</pre> 0123456789101112131415161718r0r1r2r3r4r5r6r7r8r9 0123456789101112131415161718r0r1r2r3r4r5r6r7r8r9 <p>Note: For reference, these two trees will be used for the rest of this notebook's examples.</p> In\u00a0[9]: Copied! <pre>normalized = toytree.distance.get_treedist_rf(tree1, tree2, normalize=True)\ndefault = toytree.distance.get_treedist_rf(tree1, tree2)\nprint(' normalized: ', normalized, '\\n','default: ',default)\n</pre> normalized = toytree.distance.get_treedist_rf(tree1, tree2, normalize=True) default = toytree.distance.get_treedist_rf(tree1, tree2) print(' normalized: ', normalized, '\\n','default: ',default) <pre> normalized:  0.8571428571428571 \n default:  12\n</pre> In\u00a0[10]: Copied! <pre>normalized = toytree.distance.get_treedist_rfi(tree1, tree2, normalize=True)\ndefault = toytree.distance.get_treedist_rfi(tree1, tree2)\nprint(' normalized: ', normalized, '\\n','default: ',default)\n</pre> normalized = toytree.distance.get_treedist_rfi(tree1, tree2, normalize=True) default = toytree.distance.get_treedist_rfi(tree1, tree2) print(' normalized: ', normalized, '\\n','default: ',default) <pre> normalized:  0.8944865320126851 \n default:  66.2410417642415\n</pre> In\u00a0[14]: Copied! <pre>normalized = toytree.distance.get_treedist_rfg_ms(tree1, tree2, normalize=True)\ndefault = toytree.distance.get_treedist_rfg_ms(tree1, tree2, normalize=False)\nprint(' normalized: ', normalized, '\\n','default: ',default)\n</pre> normalized = toytree.distance.get_treedist_rfg_ms(tree1, tree2, normalize=True) default = toytree.distance.get_treedist_rfg_ms(tree1, tree2, normalize=False) print(' normalized: ', normalized, '\\n','default: ',default) <pre>\u26a0\ufe0f toytree | treedist_utils:get_trees_matching_split_dist | no normalization method for matching split distance.\n</pre> <pre> normalized:  15.0 \n default:  15.0\n</pre> In\u00a0[\u00a0]: Copied! <pre># toytree.distance.get_treedist_rfg_mci(tree1, tree2)\n# toytree.distance.get_treedist_rfg_ms(tree1, tree2)\n# toytree.distance.get_treedist_rfg_msi(tree1, tree2)\n# toytree.distance.get_treedist_rfg_spi(tree1, tree2)\n</pre>  # toytree.distance.get_treedist_rfg_mci(tree1, tree2) # toytree.distance.get_treedist_rfg_ms(tree1, tree2) # toytree.distance.get_treedist_rfg_msi(tree1, tree2) # toytree.distance.get_treedist_rfg_spi(tree1, tree2) <p>The <code>.annotate</code> subpackage offers a clean, readable way to edit an existing tree as an alternative to modifying each argument in the <code>.draw()</code> method. The funcitons provided in this subpackage work by adding marks on top of the most recent <code>canvas</code> created by Toytree. It can be accessed direclty from a tree object (e.g., tree.annotate.{function}()), but some functions require additional arguments to specify axes, styles, etc.</p> <p>Since this subpackage contains very simple modifications that can be quickly added on top of existing trees, we encourage you to share with us any functions you make that may fit in this subpackage! These can be shared via Github at https://github.com/eaton-lab/toytree/discussions</p> In\u00a0[\u00a0]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np In\u00a0[\u00a0]: Copied! <pre>#add_axes_box_outline\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n\n\ntree.annotate.add_axes_box_outline(axes=axes)\n</pre> #add_axes_box_outline  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw()   tree.annotate.add_axes_box_outline(axes=axes)  In\u00a0[\u00a0]: Copied! <pre>#add_edge_labels\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\nm1 = tree.annotate.add_edge_labels(\n    axes,\n    labels=tree.get_node_data(\"idx\"),\n    color='blue',\n    style={'font-size': 16, 'baseline-shift': 8}\n)\n</pre> #add_edge_labels  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() m1 = tree.annotate.add_edge_labels(     axes,     labels=tree.get_node_data(\"idx\"),     color='blue',     style={'font-size': 16, 'baseline-shift': 8} ) In\u00a0[\u00a0]: Copied! <pre>#add_edge_markers\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\nm1 = tree.annotate.add_edge_markers(\n     axes,\n     marker='s',\n     size=9,\n     color='red',\n     style={'stroke': 'white', 'stroke-width': 2.5}\n )\n</pre> #add_edge_markers  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() m1 = tree.annotate.add_edge_markers(      axes,      marker='s',      size=9,      color='red',      style={'stroke': 'white', 'stroke-width': 2.5}  ) In\u00a0[\u00a0]: Copied! <pre>#add_node_markers\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n# add markers to all Nodes\nm1 = tree.annotate.add_node_markers(\n    axes,\n    marker='s',\n    size=9,\n    color='red',\n    style={'stroke': 'white', 'stroke-width': 2.5}\n)\n# add markers to only a few Nodes\nm2 = tree.annotate.add_node_markers(\n    axes, marker=\"&gt;\", size=20, mask=tree.get_node_mask(9, 10)\n)\n</pre> #add_node_markers  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() # add markers to all Nodes m1 = tree.annotate.add_node_markers(     axes,     marker='s',     size=9,     color='red',     style={'stroke': 'white', 'stroke-width': 2.5} ) # add markers to only a few Nodes m2 = tree.annotate.add_node_markers(     axes, marker=\"&gt;\", size=20, mask=tree.get_node_mask(9, 10) ) In\u00a0[\u00a0]: Copied! <pre>#add_node_labels\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\nm1 = tree.annotate.add_node_labels(\n    axes,\n    labels=tree.get_node_data(\"idx\"),\n    color='blue',\n    style={'font-size': 16, 'baseline-shift': 8}\n)\n</pre> #add_node_labels  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() m1 = tree.annotate.add_node_labels(     axes,     labels=tree.get_node_data(\"idx\"),     color='blue',     style={'font-size': 16, 'baseline-shift': 8} )  In\u00a0[\u00a0]: Copied! <pre>#add_node_bars\n\ntree = toytree.rtree.unittree(10, treeheight=1e5)\nc, a, m = tree.draw()\nnode_height = tree.get_node_data(\"height\").values\ntree.annotate.add_node_bars(\n    axes=a,\n    bar_min=node_height * 0.5,\n    bar_max=node_height * 1.5,\n    size=0.33, z_index=-1, color='purple', opacity=0.4,\n)\n</pre> #add_node_bars  tree = toytree.rtree.unittree(10, treeheight=1e5) c, a, m = tree.draw() node_height = tree.get_node_data(\"height\").values tree.annotate.add_node_bars(     axes=a,     bar_min=node_height * 0.5,     bar_max=node_height * 1.5,     size=0.33, z_index=-1, color='purple', opacity=0.4, ) In\u00a0[\u00a0]: Copied! <pre>#add_tip_markers\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n# add markers to all Nodes\nm1 = tree.annotate.add_tip_markers(\n    axes,\n    marker='s',\n    size=9,\n    color='red',\n    style={'stroke': 'white', 'stroke-width': 2.5}\n)\n# add markers to only a few Nodes\nm2 = tree.annotate.add_tip_markers(\n    axes, marker=\"&gt;\", size=20, mask=tree.get_node_mask(9)\n)\n</pre> #add_tip_markers  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() # add markers to all Nodes m1 = tree.annotate.add_tip_markers(     axes,     marker='s',     size=9,     color='red',     style={'stroke': 'white', 'stroke-width': 2.5} ) # add markers to only a few Nodes m2 = tree.annotate.add_tip_markers(     axes, marker=\"&gt;\", size=20, mask=tree.get_node_mask(9) ) In\u00a0[\u00a0]: Copied! <pre>#add_axes_scale_bar\n\nimport toytree\n\ntree = toytree.rtree.unittree(ntips = 10)\ncanvas, axes, mark = tree.draw()\ntree.annotate.add_axes_scale_bar(axes)\n\n# orig = toytree.rtree.rtree(5, seed=123)\n# orig.set_node_data(\"orig\", {i: i.idx for i in orig}, inplace=True)\n# # orig.draw('p', node_labels=\"orig\");\n# a, b = orig.mod.bisect(1)\n# c, ax, m = a.draw()\n# a.annotate.add_axes_scale_bar(ax)#scale_bar=True);\n</pre> #add_axes_scale_bar  import toytree  tree = toytree.rtree.unittree(ntips = 10) canvas, axes, mark = tree.draw() tree.annotate.add_axes_scale_bar(axes)  # orig = toytree.rtree.rtree(5, seed=123) # orig.set_node_data(\"orig\", {i: i.idx for i in orig}, inplace=True) # # orig.draw('p', node_labels=\"orig\"); # a, b = orig.mod.bisect(1) # c, ax, m = a.draw() # a.annotate.add_axes_scale_bar(ax)#scale_bar=True); In\u00a0[\u00a0]: Copied! <pre>#add_node_pie_charts\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n\n# generate random pie-like (proportion) data array\nncategories = 3\narr = np.random.random(size=(tree.nnodes, ncategories))\narr = (arr.T / arr.sum(axis=1)).T\n\n# add pie charts to all internal Nodes\ntree.annotate.add_node_pie_charts(\n    axes=axes, data=arr, size=20, mask=(0, 1, 1),\n    istroke_width=0.75, istroke=\"black\", rotate=-45,\n)\n</pre> #add_node_pie_charts tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw()  # generate random pie-like (proportion) data array ncategories = 3 arr = np.random.random(size=(tree.nnodes, ncategories)) arr = (arr.T / arr.sum(axis=1)).T  # add pie charts to all internal Nodes tree.annotate.add_node_pie_charts(     axes=axes, data=arr, size=20, mask=(0, 1, 1),     istroke_width=0.75, istroke=\"black\", rotate=-45, ) In\u00a0[\u00a0]: Copied! <pre>#add_edge_pie_charts\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n\n# generate random pie-like (proportion) data array\nncategories = 3\narr = np.random.random(size=(tree.nnodes, ncategories))\narr = (arr.T / arr.sum(axis=1)).T\n\n# add pie charts to all internal Nodes\ntree.annotate.add_edge_pie_charts(\n    axes=axes, data=arr, size=20, mask=(0, 1, 1),\n    istroke_width=0.75, istroke=\"black\", rotate=-45,\n)\n</pre> #add_edge_pie_charts tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw()  # generate random pie-like (proportion) data array ncategories = 3 arr = np.random.random(size=(tree.nnodes, ncategories)) arr = (arr.T / arr.sum(axis=1)).T  # add pie charts to all internal Nodes tree.annotate.add_edge_pie_charts(     axes=axes, data=arr, size=20, mask=(0, 1, 1),     istroke_width=0.75, istroke=\"black\", rotate=-45, )"},{"location":"docs-drafts/#enum-subpackage-documentation","title":"Enum Subpackage Documentation\u00b6","text":""},{"location":"docs-drafts/#bipartitions","title":"Bipartitions\u00b6","text":""},{"location":"docs-drafts/#example-expressing-bipartitions-in-dataframes","title":"Example - Expressing bipartitions in dataframes\u00b6","text":""},{"location":"docs-drafts/#quartets","title":"Quartets\u00b6","text":""},{"location":"docs-drafts/#methods","title":"Methods\u00b6","text":"<p>Get fast unordered sets of all combinations of 4 tip Nodes in a tree</p> <p>tree.enum._iter_unresolved_quartet_sets()   # {0, 1, 2, 3}, ...</p> <p>Get name-ordered tuples of Nodes for each quartet induced by bipartitions in a tree.</p> <p>tree.enum.iter_quartets()                   # ((0, 1), (2, 3)), ...</p>"},{"location":"docs-drafts/#see-also","title":"See Also\u00b6","text":"<p>Get number of quartets induced by the splits in a tree.</p> <p>tree.enum.get_n_quartets()                  # 5</p>"},{"location":"docs-drafts/#format","title":"Format\u00b6","text":"<p>Quartets represent a sample from a bipartition or quadripartition where there is a split, e.g. <code>AB|CD</code>, separating to sets of items. The order of the items within each partition of the quartet is not often of interest, but it is nice to have a consistent sort option in case it is useful.</p> <p>Supported:</p> <ul> <li>({'a', 'b'}, {'c', 'd'})  # type=set, collapse=False; sort affects order of p1,p2</li> <li>(('a', 'b'), ('c', 'd'))  # type=tuple, collapse=False; sort affects order of p1,p2 and within each p</li> <li>('a', 'b', 'c', 'd')      # type=tuple, collapse=True; same as above, imagine middle split is still there.</li> </ul> <p>Not supported:</p> <ul> <li>({'a', 'b', 'c', 'd'})    # type=set, collapse=True; split info lost. \"\"\"</li> </ul> <p>=============================================================</p> <p>Generator to yield quartets induced by edges in a tree.</p> <pre><code>This yields all quartets (4-sample subtrees) that exist within\na larger tree. The set of possible quartets is not affected by\ntree rooting, but is affected by collapsed edges (polytomies),\nwhich reduce the number of quartets.\n\nQuartets are returned as Tuple[Node, Node, Node, Node], or Tuple\nof the requested features of Nodes, where e.g. ('a', 'b', 'c', 'd')\nimplies the quartet `ab|cd`. The order in which quartets are\nyielded depends on the topology and rooting, and is in Node idx\ntraversal order, where the first two Nodes are below the edge, and\nthe second two above. This can be changed to a consistent name\nsorted order for each split partition using `sort=True`.\n\nParameters\n----------\nfeature: str\n    Feature used to represent Nodes on either side of bipartitions.\n    Default is \"name\". None will return Node objects. Other Node\n    features can be used but be aware if using quartets to compare\n    among trees that 'idx' changes depending on topology, and other\n    features may not be unique among Nodes.\ntype: Callable\n    The type of collection used to represent a partition. Default\n    is `set` to return a tuple of sets, but another useful option\n    is `tuple`, which returns a tuple of tuples.\nsort: bool\n    If False, quartets are returned with Nodes spanning edges as\n    (below, below, above, above) in idx traversal order given the\n    topology and rooting. If sort=True, partitions are instead\n    always sorted alphanumerically within and between partitions.\ncollapse: bool\n    If True then quartets are returned as a single tuple, e.g.,\n    (0, 1, 2, 3), else they are returned as a tuple of tuples,\n    e.g., ((0, 1), (2, 3)). In either case, the induced split is\n    implied to occur in the middle, e.g., 0,1 vs 2,3. Collapse arg\n    cannot be combined with type=set.\nquadripartition: bool\n    If True then quartets are only returned that are induced by\n    quadripartitite splits in a the tree. This is a subset of the\n    quartets induced by bipartitions, since the tip Nodes must come\n    from four different clades from each edge/split.</code></pre>"},{"location":"docs-drafts/#quadripartitions","title":"Quadripartitions\u00b6","text":""},{"location":"docs-drafts/#mod-subpackage-documentation","title":"Mod subpackage documentation\u00b6","text":""},{"location":"docs-drafts/#merging-nodes","title":"Merging nodes\u00b6","text":"<p><code>merge_nodes()</code> takes a user-inputted merge method and selection method and uses it to discard at least one tip and one internal Node while keeping one child Node. The remaining child Node inherets its parent's distance.</p> <p>The <code>merge_method=</code> argument has two kinds of possible inputs:</p> <ol> <li>A function that returns <code>True</code> if a node should be merged</li> <li>A feature name/value for which a Node will be merged if all descendant leaves share the same feature name/value</li> </ol> <p>The <code>selection_method=</code> argument takes a function that returns a single <code>Node</code> from a collection of Nodes. By default, this uses the <code>min()</code> function, returning the lowest indexed Node.</p>"},{"location":"docs-drafts/#distance-subpackage-documentation","title":"Distance Subpackage Documentation\u00b6","text":""},{"location":"docs-drafts/#distance-dissimilarity-functions","title":"Distance &amp; Dissimilarity Functions\u00b6","text":""},{"location":"docs-drafts/#node-level-distances","title":"Node-level distances\u00b6","text":"<p>The functions provided to study node-level distances are generally provided as <code>get_</code> and <code>iter_</code> functions. <code>get_</code> functions return paths or distances as tuples, dictionaries, or matrices while <code>iter_</code> functions are iterable generators. All currently implemented node-level distance functions are shown with examples below.</p> <p>Distances can generally be described by <code>patristic distance</code> (default), or the sum of the lengths of edges in the shortest path between two nodes, or by <code>toplogical distance</code>, or simply the number of edges separating two nodes. For topological distance, use <code>toplogy_only=True</code></p>"},{"location":"docs-drafts/#node-paths","title":"Node Paths\u00b6","text":""},{"location":"docs-drafts/#node-distances","title":"Node Distances\u00b6","text":""},{"location":"docs-drafts/#tree-level-dissimilarities","title":"Tree-level dissimilarities\u00b6","text":"<p>This set of functions computes tree similarity metrics based on quartets. All tree similarity matrics revolve around the following terms:</p> <p><code>Q</code> = Total possible quartets <code>S</code> = Resolved in the same way between the two trees <code>D</code> = Resolved differently between the two trees <code>R1</code> = Unresolved in tree 1, resolved in tree 2 <code>R2</code> = Unresolved in tree 2, resolved in tree1 <code>U</code> = unresolved in both trees <code>N</code> = S + D + R1 + R2 + U</p>"},{"location":"docs-drafts/#tree-level-dissimilarities","title":"Tree-level dissimilarities\u00b6","text":"<p>In order to quantify the difference between two trees, these methods decompose trees into sets of bipartitions or quartets and measure differences based on these sets. In order to quickly show an overview of the different distance scores, use <code>get_treedist_quartets</code>. This overview shows all tree distances based on quartet metrics where:</p> <p>$Q =$ Total possible quartets $S =$ Resolved in the same way between the two trees $D =$ Resolved differently between the two trees $R1 =$ Unresolved in tree 1, resolved in tree 2 $R2 =$ Unresolved in tree 2, resolved in tree 1 $U =$  Unresolved in both trees $N = S + D + R1 + R2 + U$</p> <p>with arguments (tree1, tree2, similarity=False). When similarity=True, scores are shown as similarity scores (1-distance)</p> <p>Using these metrics, <code>get_treedist_quartets</code> also shows a list of calculated scores. Descriptions of these scores can be found in the paper below:</p> <p>Estabrook GF, McMorris FR, Meacham CA (1985). \u201cComparison of undirected phylogenetic trees based on subtrees of four evolutionary units.\u201d Systematic Zoology, 34(2), 193--200. doi:10.2307/2413326 .</p>"},{"location":"docs-drafts/#robinson-foulds-distance","title":"Robinson-Foulds distance\u00b6","text":"<p>The Robinson-Foulds (RF) distance is a metric that measures the normalized* count of bipartitions induced by one tree, but not the other tree. In other words, it is the symmmetric difference between two bipart sets divided by the total number of bipartitions in both sets. ___Larger_ values indicate that the two trees are more different__</p> <p>*To show the normalized score, use <code>normalize=True</code></p>"},{"location":"docs-drafts/#information-corrected-robinson-foulds-distance","title":"Information-corrected Robinson-Foulds distance\u00b6","text":"<p>The information-corrected Robinson-Foulds distance (RFI) measures the sum of the <code>phylogenetic information</code> of edges taht are different between two trees. <code>Information</code> is calculated as the probability that a randomly sampled binary tree of the same size contains the split. Splits that contain less information (e.g.m a cherry vs a deep split) are more likely to arise by chance, and thus contribute less to the metric.</p> <p><code>normalize=True</code> normalizes the score relative to the sum of phylogenetic information present in both subtrees.</p>"},{"location":"docs-drafts/#generalized-robinson-foulds-matching-split-distance","title":"Generalized Robinson-Foulds Matching Split distance\u00b6","text":""},{"location":"docs-drafts/#annotate-subpackage-documentation","title":"Annotate subpackage Documentation\u00b6","text":""},{"location":"docs-drafts/#node-and-edge-markslabels","title":"Node and edge marks/labels\u00b6","text":"<ul> <li>add_edge_labels</li> <li>add_edge_markers</li> <li>add_node_markers</li> <li>add_node_labels</li> <li>add_tip_markers</li> <li>add_node_bars</li> </ul>"},{"location":"docs-drafts/#axes-annotations","title":"Axes annotations\u00b6","text":"<ul> <li>add_axes_box_outline</li> <li>add_axes_scale_bar</li> </ul>"},{"location":"docs-drafts/#datagraph-annotations","title":"Data/graph annotations\u00b6","text":"<ul> <li>add_node_pie_charts</li> <li>add_edge_pie_charts</li> </ul>"},{"location":"docs-drafts/#quick-examples","title":"Quick examples\u00b6","text":""},{"location":"draw-options/","title":"draw options","text":"In\u00a0[6]: Copied! <pre>import toytree\nimport toyplot\nimport numpy as np\n\n# a tree to use for examples\nurl = \"https://eaton-lab.org/data/Cyathophora.tre\"\nrtre = toytree.tree(url).root(\"~prz\") # rooted on outgroup clade\n</pre> import toytree import toyplot import numpy as np  # a tree to use for examples url = \"https://eaton-lab.org/data/Cyathophora.tre\" rtre = toytree.tree(url).root(\"~prz\") # rooted on outgroup clade In\u00a0[7]: Copied! <pre># hide tip labels\nrtre.draw(tip_labels=False);\n</pre> # hide tip labels rtre.draw(tip_labels=False); In\u00a0[8]: Copied! <pre># get tip labels from tree\ntipnames = rtre.get_tip_labels()\n\n# modify list so that names have a \"-0\" at the end\nitalicnames = [f\"{i}-0\".format(i) for i in tipnames]\n\n# enter the list of names to tip_labels (in idx order)\nrtre.draw(tip_labels=italicnames);\n</pre> # get tip labels from tree tipnames = rtre.get_tip_labels()  # modify list so that names have a \"-0\" at the end italicnames = [f\"{i}-0\".format(i) for i in tipnames]  # enter the list of names to tip_labels (in idx order) rtre.draw(tip_labels=italicnames); 32082_przewalskii-033588_przewalskii-033413_thamno-030556_thamno-040578_rex-035855_rex-035236_rex-039618_rex-038362_rex-029154_superba-030686_cyathophylla-041954_cyathophylloides-041478_cyathophylloides-0 In\u00a0[9]: Copied! <pre>rtre.draw(tip_labels_align=True);\n</pre> rtre.draw(tip_labels_align=True); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[31]: Copied! <pre># use color from favored toytree color scheme\nrtre.draw(\n    tip_labels_align=True, \n    tip_labels_colors=\"orange\",\n);\n\n# enter a list of colors by name\nrtre.draw(\n    tip_labels_align=True, \n    tip_labels_colors=(['goldenrod'] * 11) + ([\"mediumseagreen\"] * 2),\n);\n\n# make list of hex color values based on tip labels\ncolorlist = [\"#d6557c\" if \"rex\" in tip else \"#5384a3\" for tip in rtre.get_tip_labels()]\nrtre.draw(\n    tip_labels_align=True, \n    tip_labels_colors=colorlist\n);\n\n# use \"tuple format\" to colomap a tree data feature\nrtre.draw(\n    tip_labels_align=True, \n    tip_labels_colors=(\"idx\", \"Spectral\"),\n);\n</pre> # use color from favored toytree color scheme rtre.draw(     tip_labels_align=True,      tip_labels_colors=\"orange\", );  # enter a list of colors by name rtre.draw(     tip_labels_align=True,      tip_labels_colors=(['goldenrod'] * 11) + ([\"mediumseagreen\"] * 2), );  # make list of hex color values based on tip labels colorlist = [\"#d6557c\" if \"rex\" in tip else \"#5384a3\" for tip in rtre.get_tip_labels()] rtre.draw(     tip_labels_align=True,      tip_labels_colors=colorlist );  # use \"tuple format\" to colomap a tree data feature rtre.draw(     tip_labels_align=True,      tip_labels_colors=(\"idx\", \"Spectral\"), ); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[32]: Copied! <pre># you can view the default options here\nrtre.style.tip_labels_style\n</pre> # you can view the default options here rtre.style.tip_labels_style Out[32]: <pre>{\n    fill: (0.145, 0.145, 0.145, 1.0),\n    fill_opacity: None,\n    font_size: 12,\n    font_weight: 300,\n    font_family: 'Helvetica',\n    anchor_shift: 15,\n    baseline_shift: 0,\n    text_anchor: 'start',\n}</pre> In\u00a0[33]: Copied! <pre>rtre.draw(\n    tip_labels_style={\n        \"fill\": \"red\", \n        \"font-size\": \"15px\", \n        \"anchor-shift\": \"40px\", \n    }\n);\n</pre> rtre.draw(     tip_labels_style={         \"fill\": \"red\",          \"font-size\": \"15px\",          \"anchor-shift\": \"40px\",      } ); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[34]: Copied! <pre># shows node labels (default feature to show is 'idx' labels)\nrtre.draw(node_labels=True);\n</pre> # shows node labels (default feature to show is 'idx' labels) rtre.draw(node_labels=True); 13141516171819202122232432082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[35]: Copied! <pre># suppreses node labels\nrtre.draw(node_labels=False);\n</pre> # suppreses node labels rtre.draw(node_labels=False); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[36]: Copied! <pre># suppresses node labels, but using node_sizes ensures nodes are still shown\nrtre.draw(node_labels=False, node_sizes=10);\n</pre> # suppresses node labels, but using node_sizes ensures nodes are still shown rtre.draw(node_labels=False, node_sizes=10); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[37]: Copied! <pre># select a data feature (\"support\") of Nodes to extract and show on node labels \nrtre.draw(node_labels=\"support\");\n</pre> # select a data feature (\"support\") of Nodes to extract and show on node labels  rtre.draw(node_labels=\"support\"); 1001001009699100100100100100100nan32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[38]: Copied! <pre># build (or extract) a list of values in idx order for plotting on nodes\nsups = rtre.get_node_data(\"support\")\n\n# enter node labels as a list in idx node order\nrtre.draw(node_labels=sups);\n</pre> # build (or extract) a list of values in idx order for plotting on nodes sups = rtre.get_node_data(\"support\")  # enter node labels as a list in idx node order rtre.draw(node_labels=sups); 1001001009699100100100100100100nan32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[39]: Copied! <pre># default options can be seen from the tree style dict\nrtre.style.node_labels_style\n</pre> # default options can be seen from the tree style dict rtre.style.node_labels_style Out[39]: <pre>{\n    fill: (0.145, 0.145, 0.145, 1.0),\n    fill_opacity: 1.0,\n    font_size: 9,\n    font_weight: 300,\n    font_family: 'Helvetica',\n    anchor_shift: 0,\n    baseline_shift: 0,\n    text_anchor: 'middle',\n}</pre> In\u00a0[40]: Copied! <pre>rtre.draw(\n    node_labels='idx',\n    node_sizes=15,\n    node_colors=\"white\",\n    node_labels_style={      ## &lt;- entered as a dict\n        \"fill\": \"red\",\n        \"font-size\": \"8px\",\n    }\n);\n</pre> rtre.draw(     node_labels='idx',     node_sizes=15,     node_colors=\"white\",     node_labels_style={      ## &lt;- entered as a dict         \"fill\": \"red\",         \"font-size\": \"8px\",     } ); 13141516171819202122232432082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[41]: Copied! <pre>rtre.draw(node_sizes=10);\n</pre> rtre.draw(node_sizes=10); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[42]: Copied! <pre># draw random values between 5-15\nrtre.draw(node_sizes=np.random.uniform(5, 15, rtre.nnodes));\n</pre> # draw random values between 5-15 rtre.draw(node_sizes=np.random.uniform(5, 15, rtre.nnodes)); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[43]: Copied! <pre># use tuple format to range-map values of a data feature between min max sizes\nrtre.draw(node_sizes=(\"height\", 5, 15));\n</pre> # use tuple format to range-map values of a data feature between min max sizes rtre.draw(node_sizes=(\"height\", 5, 15)); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[58]: Copied! <pre># set a single color for all nodes\nrtre.draw(node_sizes=10, node_colors=\"red\");\n</pre> # set a single color for all nodes rtre.draw(node_sizes=10, node_colors=\"red\"); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[66]: Copied! <pre># create a list of colors (e.g., red or blue randomly sampled nnodes times)\ncolors = np.random.choice([\"red\", \"blue\"], size=rtre.nnodes)\nrtre.draw(node_sizes=10, node_colors=colors);\n</pre> # create a list of colors (e.g., red or blue randomly sampled nnodes times) colors = np.random.choice([\"red\", \"blue\"], size=rtre.nnodes) rtre.draw(node_sizes=10, node_colors=colors); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[67]: Copied! <pre># colormap data from a tree feature to a colormap using tuple format\nrtre.draw(node_sizes=10, node_colors=(\"height\", \"Greys\"));\n</pre> # colormap data from a tree feature to a colormap using tuple format rtre.draw(node_sizes=10, node_colors=(\"height\", \"Greys\")); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[71]: Copied! <pre># default marker is a circle\nrtre.draw(node_sizes=10, node_markers=\"o\");\n</pre> # default marker is a circle rtre.draw(node_sizes=10, node_markers=\"o\"); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[74]: Copied! <pre># alternative shapes are available (see options above)\nrtre.draw(node_sizes=10, node_markers=\"s\");\n</pre> # alternative shapes are available (see options above) rtre.draw(node_sizes=10, node_markers=\"s\"); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides <p>Rectangular markers can be drawn in many dimensions. Designate \"r2x1\" for a box that is twice as wide as it is tall.</p> In\u00a0[76]: Copied! <pre># rectangles for nodes\nrtre.draw(node_sizes=10, node_markers=\"r2x1.25\");\n</pre> # rectangles for nodes rtre.draw(node_sizes=10, node_markers=\"r2x1.25\"); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[88]: Copied! <pre># default options can be viewed here\nrtre.style.node_style\n</pre> # default options can be viewed here rtre.style.node_style Out[88]: <pre>{\n    fill: (0.4, 0.7607843137254902, 0.6470588235294118, 1.0),\n    fill_opacity: None,\n    stroke: '#262626',\n    stroke_width: 1.5,\n    stroke_opacity: None,\n}</pre> In\u00a0[89]: Copied! <pre>rtre.draw(\n    node_sizes=10,\n    node_style={\n        \"fill\": \"orange\",\n        \"fill-opacity\": 0.5,\n        \"stroke\": \"black\",\n        \"stroke-opacity\": 0.5,\n        \"stroke-width\": 3,\n    }\n);\n</pre> rtre.draw(     node_sizes=10,     node_style={         \"fill\": \"orange\",         \"fill-opacity\": 0.5,         \"stroke\": \"black\",         \"stroke-opacity\": 0.5,         \"stroke-width\": 3,     } ); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[91]: Copied! <pre># hover over the nodes\nrtre.draw(node_hover=True, node_sizes=15);\n</pre> # hover over the nodes rtre.draw(node_hover=True, node_sizes=15); idx: 13 dist: 0.0179371130487 support: 100 height: 0.0152107514239 name: idx: 14 dist: 0.00222999650239 support: 100 height: 0.00577636172318 name: idx: 15 dist: 0.00617527349892 support: 100 height: 0.00109218434613 name: idx: 16 dist: 0.000738900380519 support: 96 height: 0.00726745784506 name: idx: 17 dist: 0.000783365499905 support: 99 height: 0.00800635822557 name: idx: 18 dist: 0.00103379657491 support: 100 height: 0.00878972372548 name: idx: 19 dist: 0.00538723112355 support: 100 height: 0.00982352030039 name: idx: 20 dist: 0.00237994755604 support: 100 height: 0.00985454237589 name: idx: 21 dist: 0.00941020878048 support: 100 height: 0.00282428115145 name: idx: 22 dist: 0.00297626149201 support: 100 height: 0.0122344899319 name: idx: 23 dist: 0.0179371130487 support: 100 height: 0.0152107514239 name: idx: 24 dist: 0 support: nan height: 0.0331478644727 name: root32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[102]: Copied! <pre>rtre.draw(layout='d');\n</pre> rtre.draw(layout='d'); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[103]: Copied! <pre>rtre.draw(layout='l');\n</pre> rtre.draw(layout='l'); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[104]: Copied! <pre># unrooted\nrtre.draw(layout='unr');\n</pre> # unrooted rtre.draw(layout='unr'); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[106]: Copied! <pre># view the allowed and default options\nrtre.style.edge_align_style\n</pre> # view the allowed and default options rtre.style.edge_align_style Out[106]: <pre>{\n    stroke: (0.66, 0.66, 0.66, 1),\n    stroke_width: 2,\n    stroke_opacity: 0.75,\n    stroke_linecap: 'round',\n    stroke_dasharray: '2,4',\n}</pre> In\u00a0[108]: Copied! <pre>rtre.draw(\n    tip_labels_align=True, \n    edge_align_style={\n        \"stroke\": \"violet\",\n        \"stroke-width\": 3.5,\n        \"stroke-dasharray\": \"2,5\"    # size of dash, spacing of dashes\n    });\n</pre> rtre.draw(     tip_labels_align=True,      edge_align_style={         \"stroke\": \"violet\",         \"stroke-width\": 3.5,         \"stroke-dasharray\": \"2,5\"    # size of dash, spacing of dashes     }); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[112]: Copied! <pre>rtre.draw(tree_style='c');\n</pre> rtre.draw(tree_style='c'); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides00.010.020.03 In\u00a0[114]: Copied! <pre>rtre.draw(tree_style='r');\n</pre> rtre.draw(tree_style='r'); root32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[115]: Copied! <pre>rtre.draw(tree_style='s');\n</pre> rtre.draw(tree_style='s'); 012345678910111213141516171819202122232432082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[116]: Copied! <pre># add scale bar\nrtre.draw(scale_bar=True);\n</pre> # add scale bar rtre.draw(scale_bar=True); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides0.030.020.010 In\u00a0[117]: Copied! <pre># add scale bar with units scaling\nrtre.draw(scale_bar=1e-2);\n</pre> # add scale bar with units scaling rtre.draw(scale_bar=1e-2); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides3210"},{"location":"draw-options/#toytree-drawings-options","title":"toytree drawings options\u00b6","text":"<p>The number of styling options available in <code>toytree</code> is enormous and will continue to grow as development on the project continues. If you have a specific styling option that does not appear to be supported please raise a issue on GitHub and we can discuss adding support for it. Below I try to demonstrate the options and usage of each styling option with at least one example.</p>"},{"location":"draw-options/#tip-label-styling","title":"Tip label styling\u00b6","text":""},{"location":"draw-options/#tip_labels","title":"tip_labels\u00b6","text":"<p>Type: boolean or list[str] Allowed: True, False, or list of str names (length ntips) Default: True Description: Shows or hides tip labels (boolean), or replaces tip labels with a user defined list.</p>"},{"location":"draw-options/#tip_labels_align","title":"tip_labels_align\u00b6","text":"<p>Type: boolean Allowed: True, False Default: False Description: Add lines connecting tips to tip labels. See edge_align_style for ways to style the extra tip lines (colors, etc.).</p>"},{"location":"draw-options/#tip_labels_colors","title":"tip_labels_colors\u00b6","text":"<p>Apply a single color to all tip labels, or different colors to each.</p> <p>Type: <code>str</code>, <code>list[str]</code>, <code>tuple[str, Colormap]</code> Allowed: Any color argument supported in toyplot colors. Default: <code>\"#262626\"</code> (near black) Description: A single color can be entered to apply to all tip labels, or a list of colors can be entered in idx order to apply different colors to each tip. The special tuple syntax can be used to map colors to feature data extracted from a tree.</p>"},{"location":"draw-options/#tip_labels_style","title":"tip_labels_style\u00b6","text":"<p>The <code>tip_labels_style</code> dictionary is used to apply CSS styling to all tip labels. Note: fill color arguments here can be overriden by <code>tip_colors</code>.</p> <p>Type: dictionary of (mostly) CSS styles. Allowed: See the dict of supported options below. Default: Defaults are shown below. Description: Modify the font, color and opacity of tip labels.</p>"},{"location":"draw-options/#node-labels-styling","title":"Node labels styling\u00b6","text":""},{"location":"draw-options/#node_labels","title":"node_labels\u00b6","text":"<p>The <code>node_labels</code> argument is used to provide labels at node positions, and is often used to show support or trait values. If node markers are plotted the labels are drawn on top of the node markers which makes them easier to see.</p> <p>Type:  boolean, str, or list of strings or ints. Allowed:  True, False, string name of features (e.g., \"idx\", \"support\"), or list that is the same length as the number of nodes. Default: False Description:  If True then the node index labels are used.</p>"},{"location":"draw-options/#node_labels_style","title":"node_labels_style\u00b6","text":"<p>The <code>node_labels_style</code> argument is a dictionary that can apply CSS styling to all node labels. This includes options to change the font-size, and the fill and stroke color and opacity.</p> <p>Type: dictionary. Allowed: CSS values supported for text by toyplot. Default: fill: near-black, font-size: '11px'. Description: A dictionary of CSS style options applied to text of node labels.</p>"},{"location":"draw-options/#node-styling","title":"Node styling\u00b6","text":""},{"location":"draw-options/#node_sizes","title":"node_sizes\u00b6","text":"<p>The <code>node_sizes</code> argument sets the size of node markers. All can be set to the same size, or different sizes.</p> <p>Type: int, float, list[int], list[float], tuple[feature, min, max]. Allowed: Reasonable values in units of pixels are typically from 0-50. Default: 0 Description: The size of node markers.</p>"},{"location":"draw-options/#node_colors","title":"node_colors\u00b6","text":"<p>Apply a single color to all node markers, or different colors to each.</p> <p>Type: <code>str</code>, <code>list[str]</code>, <code>tuple[str, Colormap]</code> Allowed: Any color argument supported in toyplot colors. Default: <code>rgba(40.0%,76.1%,64.7%,1.000)</code> (the first color from colormap 'Set2' (cyan)) Description: A single color can be entered to apply to all node markers, or a list of colors can be entered in idx order to apply different colors to each node. The special tuple syntax can be used to map colors to feature data extracted from a tree.</p>"},{"location":"draw-options/#node_markers","title":"node_markers\u00b6","text":"<p>See toyplot markers for available options.</p>"},{"location":"draw-options/#node_style","title":"node_style\u00b6","text":"<p>The <code>node_style</code> argument can be used to set CSS styles to the node markers to style fill and stroke color and opacity, and stroke width.</p>"},{"location":"draw-options/#node_hover","title":"node_hover\u00b6","text":"<p>Enables interactive hover over nodes so that you can see all features associated with each.</p>"},{"location":"draw-options/#layout","title":"Layout\u00b6","text":""},{"location":"draw-options/#layout","title":"layout\u00b6","text":"<p>Type:  str Allowed: 'right', 'r'; 'left', 'l'; 'down', 'd'; 'up', 'u'; 'unrooted', 'unr'; 'circular', 'c'; Default: 'r' Description:  The layout orients the direction of tip labels. Options include linear trees facing right, left, up, down, as well as circular and unrooted trees.</p>"},{"location":"draw-options/#todo","title":"<code>todo</code>\u00b6","text":"<p>Type: Allowed: Default: Description:</p>"},{"location":"draw-options/#aligned-edge-styling","title":"Aligned Edge Styling\u00b6","text":""},{"location":"draw-options/#edge_align_style","title":"edge_align_style\u00b6","text":"<p>Type: Allowed: Default: Description:</p>"},{"location":"draw-options/#built-in-tree_style","title":"Built in tree_style\u00b6","text":"<p>A number of built-in <code>tree_style</code> options are avilable. These allow you to enter just a single option to set the base style of the drawing, which affects many styles. Any additional drawing arguments that you add will be applied on top of this base style. The arg <code>ts</code> can be used as a shortcut for tree_style. The default style is 'n' (normal).</p>"},{"location":"draw-options/#scale_bar","title":"Scale_bar\u00b6","text":"<p>You can add a scale_bar to any tree plot with the draw argument <code>scale_bar=True</code>. When creating a drawing (which return three objects) you can store the middle object (axes) to further set styling options on it. You can also optionally enter a float value such as <code>scale_bar=1e6</code> to add a scale_bar where branch lengths will be returned in units divided by 1e4. This can help to make units of millions of years listed as integers instead of many zeros.</p> <p>Type: boolean or float Allowed: True, False, float Default: False Description: Add a scale bar and optionally set the scalebar unit by entering a float.</p>"},{"location":"drawing-basics/","title":"draw basics","text":"In\u00a0[27]: Copied! <pre>import toytree\nimport numpy as np\n\n# an example tree\ntree = toytree.rtree.bdtree(ntips=6, seed=123)\n</pre> import toytree import numpy as np  # an example tree tree = toytree.rtree.bdtree(ntips=6, seed=123) In\u00a0[28]: Copied! <pre># returns the three drawing objects\ntree.draw()\n</pre> # returns the three drawing objects tree.draw() Out[28]: <pre>(&lt;toyplot.canvas.Canvas at 0x7f0edbe44be0&gt;,\n &lt;toyplot.coordinates.Cartesian at 0x7f0edbf9d660&gt;,\n &lt;toytree.drawing.src.mark_toytree.ToyTreeMark at 0x7f0edbf6eb90&gt;)</pre> r0r1r2r3r4r5 <p>Throughout this documentation you will see many <code>toytree</code> drawing commands end with a semicolon (;), which is a simple method to hide the returned objects from being displayed in the output cell.</p> In\u00a0[29]: Copied! <pre># semicolon hides the returned objects, but drawing still autorenders\ntree.draw();\n</pre> # semicolon hides the returned objects, but drawing still autorenders tree.draw(); r0r1r2r3r4r5 In\u00a0[30]: Copied! <pre># store the drawing objects as variables\ncanvas, axes, mark = tree.draw()\n</pre> # store the drawing objects as variables canvas, axes, mark = tree.draw() r0r1r2r3r4r5 In\u00a0[85]: Copied! <pre># drawing with pre-built tree_styles\ntree.draw(tree_style='s');  # simple-style\ntree.draw(tree_style='c');  # coalescent-style\ntree.draw(tree_style='r');  # R-style\ntree.draw(tree_style='p');  # population-style\ntree.draw(tree_style='d');  # dark-style\ntree.draw(tree_style='o');  # umlaut-style\n</pre> # drawing with pre-built tree_styles tree.draw(tree_style='s');  # simple-style tree.draw(tree_style='c');  # coalescent-style tree.draw(tree_style='r');  # R-style tree.draw(tree_style='p');  # population-style tree.draw(tree_style='d');  # dark-style tree.draw(tree_style='o');  # umlaut-style 012345678910r0r1r2r3r4r5 r0r1r2r3r4r500.511.5 1-14-23-21-20r0r1r2r3r4r5 012345678910r0r1r2r3r4r500.511.5 r0r1r2r3r4r5 r0r1r2r3r4r5 <p>You can think of setting a <code>tree_style</code> as changing the baseline style on top of which additional drawing arguments can still be added. For example, here we select the \"dark\" tree style, which changes the default edge and tip colors, and on top of this we can still specify a change to the layout, node marker type, node size, and/or other drawing options.</p> In\u00a0[38]: Copied! <pre># tree_style is a baseline on top of which additional styles can be added\ntree.draw(tree_style='d', layout='d', node_markers=\"s\", node_sizes=8, height=250);\n</pre> # tree_style is a baseline on top of which additional styles can be added tree.draw(tree_style='d', layout='d', node_markers=\"s\", node_sizes=8, height=250); r0r1r2r3r4r5 In\u00a0[39]: Copied! <pre>tree.draw(\n    node_sizes=8, node_markers=\"&gt;\", node_mask=False,\n    edge_colors=\"darkmagenta\", edge_style={\"opacity\": 0.3}, edge_type=\"c\", \n    scale_bar=True,\n);\n</pre> tree.draw(     node_sizes=8, node_markers=\"&gt;\", node_mask=False,     edge_colors=\"darkmagenta\", edge_style={\"opacity\": 0.3}, edge_type=\"c\",      scale_bar=True, ); r0r1r2r3r4r51.510.50 In\u00a0[13]: Copied! <pre># define a re-usable style dictionary\nmystyle = {\n    \"layout\": 'd',\n    \"edge_type\": 'p',\n    \"edge_style\": {\n        \"stroke\": \"black\",\n        \"stroke-width\": 2.5,\n    },\n    \"tip_labels_align\": True,\n    \"tip_labels_colors\": \"darkcyan\",\n    \"tip_labels_style\": {\n        \"font-size\": \"15px\"\n    },\n    \"node_labels\": False,\n    \"node_sizes\": 8,\n    \"node_colors\": \"goldenrod\",\n    \"node_mask\": False,\n}\n\n# apply the custom treestyle dict to a drawing\ntree.draw(**mystyle);\n</pre> # define a re-usable style dictionary mystyle = {     \"layout\": 'd',     \"edge_type\": 'p',     \"edge_style\": {         \"stroke\": \"black\",         \"stroke-width\": 2.5,     },     \"tip_labels_align\": True,     \"tip_labels_colors\": \"darkcyan\",     \"tip_labels_style\": {         \"font-size\": \"15px\"     },     \"node_labels\": False,     \"node_sizes\": 8,     \"node_colors\": \"goldenrod\",     \"node_mask\": False, }  # apply the custom treestyle dict to a drawing tree.draw(**mystyle); r0r1r2r3r4r5 In\u00a0[14]: Copied! <pre># set a style that will persist on an individual tree object\nstree = tree.copy()\nstree.style.edge_colors = \"darkcyan\"\nstree.style.edge_widths = 2.5\nstree.style.node_mask = False\nstree.style.node_sizes = 16\nstree.style.node_markers = \"s\"\nstree.style.node_style.fill_opacity = 0.5\nstree.style.node_labels = \"idx\"\nstree.style.tip_labels_style.font_size = 16\nstree.style.tip_labels_style.anchor_shift = 25\nstree.draw();\n</pre> # set a style that will persist on an individual tree object stree = tree.copy() stree.style.edge_colors = \"darkcyan\" stree.style.edge_widths = 2.5 stree.style.node_mask = False stree.style.node_sizes = 16 stree.style.node_markers = \"s\" stree.style.node_style.fill_opacity = 0.5 stree.style.node_labels = \"idx\" stree.style.tip_labels_style.font_size = 16 stree.style.tip_labels_style.anchor_shift = 25 stree.draw(); 012345678910r0r1r2r3r4r5 In\u00a0[16]: Copied! <pre># hover over nodes to see pop-up elements\ntree.draw(\n    node_sizes=18, \n    node_style={\"fill-opacity\": 0.75, \"stroke\": \"white\", \"stroke-width\": 2.5},\n    node_mask=(0, 1, 0),\n    node_labels=\"idx\",\n    node_labels_style={\"font-size\": 14, \"fill\": \"white\"},\n    node_colors=(\"idx\", \"BlueRed\", 6, 9),\n    node_markers=\"s\",\n    node_hover=True, \n);\n</pre> # hover over nodes to see pop-up elements tree.draw(     node_sizes=18,      node_style={\"fill-opacity\": 0.75, \"stroke\": \"white\", \"stroke-width\": 2.5},     node_mask=(0, 1, 0),     node_labels=\"idx\",     node_labels_style={\"font-size\": 14, \"fill\": \"white\"},     node_colors=(\"idx\", \"BlueRed\", 6, 9),     node_markers=\"s\",     node_hover=True,  ); idx: 6 dist: 0.596972495123 support: nan height: 1.12630250437 name: 1-1 tdiv: 0.5969724951236idx: 7 dist: 0.0386582269365 support: nan height: 0.177873309174 name: 4-2 tdiv: 1.545401690327idx: 8 dist: 0.783873618514 support: nan height: 0.216531536111 name: 3-2 tdiv: 1.506743463388idx: 9 dist: 0.722869844869 support: nan height: 1.00040515462 name: 1-2 tdiv: 0.5969724951239r0r1r2r3r4r5 In\u00a0[17]: Copied! <pre># hover over nodes to see pop-up elements\ntree.draw(node_sizes=12);\n</pre> # hover over nodes to see pop-up elements tree.draw(node_sizes=12); r0r1r2r3r4r5 In\u00a0[82]: Copied! <pre>tree.draw(node_sizes=(\"height\", 5, 20));\n</pre> tree.draw(node_sizes=(\"height\", 5, 20)); r0r1r2r3r4r5 In\u00a0[77]: Copied! <pre>tree.draw(node_sizes=(\"height\",));\n</pre> tree.draw(node_sizes=(\"height\",)); r0r1r2r3r4r5 In\u00a0[14]: Copied! <pre># mask=False reveals all nodes\ntree.draw(node_mask=False, node_sizes=12);\n</pre> # mask=False reveals all nodes tree.draw(node_mask=False, node_sizes=12); r0r1r2r3r4r5 In\u00a0[15]: Copied! <pre># mask=True masks all nodes\ntree.draw(node_mask=True, node_sizes=12);\n</pre> # mask=True masks all nodes tree.draw(node_mask=True, node_sizes=12); r0r1r2r3r4r5 In\u00a0[16]: Copied! <pre># mask=[True, False, True, ...] shows Nodes with True\nmask = tree.get_node_mask(show_tips=True, show_root=True, show_internal=False)\nprint(mask)\ntree.draw(node_mask=mask, node_sizes=12);\n</pre> # mask=[True, False, True, ...] shows Nodes with True mask = tree.get_node_mask(show_tips=True, show_root=True, show_internal=False) print(mask) tree.draw(node_mask=mask, node_sizes=12); <pre>[ True  True  True  True  True  True False False False False  True]\n</pre> r0r1r2r3r4r5 In\u00a0[17]: Copied! <pre># mask=[True, False, True, ...] shows Nodes with True\nmask = tree.get_node_mask(\"~r[0-5]\")\nprint(mask)\ntree.draw(node_mask=mask, node_sizes=12);\n</pre> # mask=[True, False, True, ...] shows Nodes with True mask = tree.get_node_mask(\"~r[0-5]\") print(mask) tree.draw(node_mask=mask, node_sizes=12); <pre>[ True  True  True  True  True  True False False False False False]\n</pre> r0r1r2r3r4r5 In\u00a0[279]: Copied! <pre># mask=[True, False, True, ...] shows a subset of Nodes\nmask = tree.get_node_mask(2, 3, 7, 8)\nprint(mask)\ntree.draw(node_mask=mask, node_sizes=15, node_labels=\"idx\");\n</pre> # mask=[True, False, True, ...] shows a subset of Nodes mask = tree.get_node_mask(2, 3, 7, 8) print(mask) tree.draw(node_mask=mask, node_sizes=15, node_labels=\"idx\"); 2378r0r1r2r3r4r5 In\u00a0[24]: Copied! <pre># apply square markers to all nodes\ntree.draw(node_sizes=10, node_markers=\"s\");\n</pre> # apply square markers to all nodes tree.draw(node_sizes=10, node_markers=\"s\"); r0r1r2r3r4r5 In\u00a0[35]: Copied! <pre># apply rectangle markers to each node\ntree.draw(node_sizes=15, node_markers=\"r2x1\");\n</pre> # apply rectangle markers to each node tree.draw(node_sizes=15, node_markers=\"r2x1\"); r0r1r2r3r4r5 In\u00a0[36]: Copied! <pre># apply a rectangle marker with width scaled to n digits in data\nrects = [f\"r{len(str(i))}x1\" for i in tree.get_node_data(\"idx\")]\ntree.draw(node_sizes=15, node_markers=rects, node_labels=\"idx\");\n</pre> # apply a rectangle marker with width scaled to n digits in data rects = [f\"r{len(str(i))}x1\" for i in tree.get_node_data(\"idx\")] tree.draw(node_sizes=15, node_markers=rects, node_labels=\"idx\"); 678910r0r1r2r3r4r5 In\u00a0[58]: Copied! <pre># show \ntree = tree.set_node_data(\"support\", default=100)\ntree[-1].support = np.nan\ntree.draw(node_labels='support', node_sizes=18, node_markers='r2x1');\n</pre> # show  tree = tree.set_node_data(\"support\", default=100) tree[-1].support = np.nan tree.draw(node_labels='support', node_sizes=18, node_markers='r2x1'); 100100100100nanr0r1r2r3r4r5 In\u00a0[224]: Copied! <pre># ...\nmask = tree.get_node_mask(2, 9, 10)\ncanvas, axes, mark = tree.draw();\ntree.annotate.add_node_markers(axes=axes, marker=\"s\", size=10, mask=mask);\n</pre> # ... mask = tree.get_node_mask(2, 9, 10) canvas, axes, mark = tree.draw(); tree.annotate.add_node_markers(axes=axes, marker=\"s\", size=10, mask=mask); r0r1r2r3r4r5 In\u00a0[72]: Copied! <pre># set a single color to all nodes\ntree.draw(node_colors='red', node_sizes=10);\n</pre> # set a single color to all nodes tree.draw(node_colors='red', node_sizes=10); r0r1r2r3r4r5 In\u00a0[73]: Copied! <pre># list of colors of length nnodes\ncolors = ['darkcyan'] * 6 + ['goldenrod'] * 5\ntree.draw(node_colors=colors, node_sizes=10, node_mask=False);\n</pre> # list of colors of length nnodes colors = ['darkcyan'] * 6 + ['goldenrod'] * 5 tree.draw(node_colors=colors, node_sizes=10, node_mask=False); r0r1r2r3r4r5 <p>Automatically color nodes by projecting a data feature that is saved to tree object, such as the node heights, using color-mapping.</p> In\u00a0[76]: Copied! <pre># colormapping the 'height' feature\ntree.draw(node_colors='height', node_sizes=10, node_mask=False);\n</pre> # colormapping the 'height' feature tree.draw(node_colors='height', node_sizes=10, node_mask=False); r0r1r2r3r4r5 In\u00a0[24]: Copied! <pre>import toyplot\n\n# set config options to new settings\ntoyplot.config.autoformat = \"png\"\ntoyplot.config.autorender = False\n</pre> import toyplot  # set config options to new settings toyplot.config.autoformat = \"png\" toyplot.config.autorender = False In\u00a0[25]: Copied! <pre># embed a PNG drawing in the notebook\ncanvas, axes, mark = tree.draw();\n\n# it will only display here b/c we return the Canvas\ncanvas\n</pre> # embed a PNG drawing in the notebook canvas, axes, mark = tree.draw();  # it will only display here b/c we return the Canvas canvas Out[25]: r0r1r2r3r4r5 In\u00a0[26]: Copied! <pre># set config options back to their defaults\ntoyplot.config.autoformat = \"html\"\ntoyplot.config.autorender = True\n</pre> # set config options back to their defaults toyplot.config.autoformat = \"html\" toyplot.config.autorender = True"},{"location":"drawing-basics/#tree-drawing-basics","title":"Tree Drawing basics\u00b6","text":"<p>Tree visualization is a fundamental feature of <code>toytree</code>. Following our minimalist ethos, it is possible to generate a beautiful tree drawing very easily. But in addition, it is also possible to create complex and data rich visualizations using a variety of styling options.</p>"},{"location":"drawing-basics/#drawing-class-objects","title":"Drawing class objects\u00b6","text":"<p>When you call <code>.draw()</code> on a tree it returns three objects, a <code>Canvas</code>, a <code>Cartesian</code> axes, and a <code>Mark</code>. This follows the design principle of the <code>toyplot</code> plotting library on which toytree is based. The <code>Canvas</code> describes the plot space, and the <code>Cartesian</code> coordinates define how to project <code>Marks</code> onto that space. <code>Marks</code> are used to represent data using SVG markers and shapes. One canvas can have multiple cartesian coordinates, and each cartesian axes can contain multiple marks.</p> <p>It is often useful to capture these drawing objects as variables so that they can be reused to further edit or annotate drawings, and to save them. However, if you are working in a jupyter notebook and only intend the drawings to be embedded in the output cells, then you do not need to save the plots externally. Canvas objects automatically render in output cells when they are created (this option can be toggled in Global config.)</p>"},{"location":"drawing-basics/#builtin-tree-styles","title":"Builtin Tree Styles\u00b6","text":"<p>There are innumerous ways to style ToyTree drawings by combining different arguments to the <code>.draw</code> function. As a convenience, we also provide a number of pre-built tree styles that represent collections of style arguments that can be set using a single command.</p>"},{"location":"drawing-basics/#creating-tree-styles","title":"Creating Tree Styles\u00b6","text":"<p>There are a number of ways to apply individual styles to tree drawings. Which method you use may depend on whether you intend to reuse a particular tree style many times, or just once. The most common method is described below as the \"one-time\" setting, in which you enter style arguments to the <code>.draw()</code> function. You will see this used most common throughout this tutorial. However, it is also possible for users to create reusable styles similar to the builtin tree style types shown above. A final option is to modify style settings saved to the tree objects themselves. Each is demonstrated below.</p>"},{"location":"drawing-basics/#one-time-style-setting","title":"One-time style setting\u00b6","text":"<p>Use tab-completion or other methods to examine the documentation string of the draw function to see the options available for styling tree drawings.</p>"},{"location":"drawing-basics/#reusable-style-dict","title":"Reusable style dict\u00b6","text":"<p>You can create a custom reusable tree-style as a dictionary of key-value pairs specifying options to the draw function. To apply this to many tree drawings you can simply use variadics to expand the dictionary as a single argument to the draw function, as demonstrated below.</p>"},{"location":"drawing-basics/#persistent-style","title":"Persistent style\u00b6","text":"<p>Finally, you can modify the <code>.style</code> settings of a <code>ToyTree</code> object to modify its saved default drawing options. This can useful if you plan to visualize the same tree many times, or wish to save different trees with different style settings for easier comparison. For example, it can be used within a function to return a tree object that has a style setting saved to it which will highlight a particular feature or clade when visualized. This framework is also useful for learning which tree style options are available, since you can use tab-completion in an interactive environment to explore the different style options available. In this example, I first create a copy of our example tree object and save the new copy as stree. Then, I modify the the style settings of the stree object. Finally, we can simply call <code>.draw()</code> to draw the tree using its saved tree style. (Note that if you enter a new <code>tree_style</code> argument to the draw() function of this tree it will override the settings in the tree's <code>.style</code> settings.)</p>"},{"location":"drawing-basics/#drawing-nodes","title":"Drawing nodes\u00b6","text":"<p>Plotting node values on a tree is a useful way of representing additional information about trees. See the Data/Features section for details on extracting data from tree objects to plot on nodes. Here we will focus on options available for styling nodes. Nodes are often used to show labels, support values, or trait data. They can convey information through variation in their marker shapes (e.g., circles, rectangles, pie-charts), colors, and size. Node markers in <code>toytree</code> are represented by SVG shape objects for which a fill (color), fill-opacity, stroke (outline color), stroke-opacity, and stroke-width can be set.</p> <p>Below is a complex example showing how</p>"},{"location":"drawing-basics/#node_sizes","title":"node_sizes\u00b6","text":"<p>In the default tree style node sizes are set to zero, meaning that they will not be shown. Node sizes are described in pixel units as floats or ints, which scale node marker sizes. A single value can be entered to apply to all nodes, or a sequence of values of length nnodes can be entered to scale nodes to different sizes. In this case, the values should be enetered in node idxorder, which is best done by extracting data from the tree object itself, as described in Data/Features. See also Range-Mapping for examples of scaling node sizes to data features.</p>"},{"location":"drawing-basics/#node_mask","title":"node_mask\u00b6","text":"<p>You will notice that the <code>node_sizes</code> argument shown above only adds node markers to the internal nodes. What if we want to choose which nodes to display markers on? In that case, you will want to use the <code>node_mask</code> argument. This accepts a boolean or array of boolean values to describe which nodes to show versus hide. There is a convenience function of tree objects named <code>get_node_mask</code> that can be used to generate a boolean mask in the correct order to designate a subset of nodes to show. Finally, there is a simplified tuple syntax that can be used to choose to display particular sets of nodes composing only the tips, only the internal nodes, or only the root.</p>"},{"location":"drawing-basics/#node_markers","title":"node_markers\u00b6","text":"<p>Node markers are the shapes of the mark objects plotted on nodes. The default shape is a circle, but a variety of marker shapes are available and can be selected by the shorthand str names used for toyplot markers. For example, 's' for a square, 'o' for a circle, 'r1x5' for a rectangle that is 5 times taller than wide. Each marker shape is still scaled to a particular pixel size using the <code>node_sizes</code> argument, and optionally shown or hidden using <code>node_mask</code>. You can enter a single node marker argument to apply to all nodes uniformly, or a series of node markers of length nnodes to apply different markers shapes to different nodes.</p>"},{"location":"drawing-basics/#node_colors","title":"node_colors\u00b6","text":"<p>The fill color of nodes can be set in a variety of ways. The node_colors option can be used to set a single color to all nodes, or different colors to nodes. The colors can be entered manually, or they can be automatically projected from color map to data values. There is another option for setting a single color to all nodes, using node_style.fill. The node_colors argument overrides node_style.fill.</p>"},{"location":"drawing-basics/#global-config","title":"Global config\u00b6","text":"<p>The default visualization settings in toytree are inherited from toyplot. This includes the default usage of html format for displaying plots in a notebook, and the default behavior of automatically rendering Canvas objects in a notebook cell when they are created. Both of these options can be changed in the <code>config</code> settings of the toyplot library.</p>"},{"location":"drawing-cloud-trees-bkp/","title":"Drawing cloud trees bkp","text":"In\u00a0[\u00a0]: Copied! In\u00a0[3]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[4]: Copied! <pre>fish = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\")\nfish\n</pre> fish = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\") fish Out[4]: <pre>&lt;toytree.MultiTree ntrees=160&gt;</pre> <p>Styling tip labels in cloud trees -- In cloud tree plots a fixed order of the tips is always enforced, which allows for the discordance among trees to be visualized. Because each tree within the multitree object may have a different ordering of tips, we only print the tip labels once. The order of the tips of the tree can be changed by using the fixed order argument, otherwise a consensus tree is quickly inferred and used for the tip order. To style the tip labels or change them, like below, you can provide a list of new names in the same order as in the first tree in the treelist.</p> In\u00a0[5]: Copied! <pre># draw a cloud tree which enforces a fixed tip order\nfish.draw_cloud_tree(\n    jitter=0.1,\n    edge_style={\n        'stroke': \"red\",\n        'stroke-opacity': 0.05,\n    },\n    #fixed_order=consfish.get_tip_labels(),\n    tip_labels_style={\"font-size\": \"11px\"},\n    tip_labels=[\n        '{}. {}'.format(i[0], i[1:])\n        for i in fish.treelist[0].get_tip_labels()\n    ],\n);\n</pre> # draw a cloud tree which enforces a fixed tip order fish.draw_cloud_tree(     jitter=0.1,     edge_style={         'stroke': \"red\",         'stroke-opacity': 0.05,     },     #fixed_order=consfish.get_tip_labels(),     tip_labels_style={\"font-size\": \"11px\"},     tip_labels=[         '{}. {}'.format(i[0], i[1:])         for i in fish.treelist[0].get_tip_labels()     ], ); P. riapellaP. sjonesiiX. alvareziX. mayaeX. helleriiX. signumX. clemenciae_GX. monticolusX. corteziX. birchmanni_GARCX. malinche_CHIC2X. montezumaeX. nezahuacoyotlX. continensX. pygmaeusX. multilineatusX. nigrensisX. andersiX. couchianusX. gordoniX. meyeriX. variatusX. evelynaeX. milleriX. xiphidiumX. maculatus_JpWild In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"drawing-cloud-trees-bkp/#example-xiphophorus-fishes","title":"Example: Xiphophorus fishes\u00b6","text":"<p>Data set for reconstructing a densitree figure from Cui et al. (2013). I\u2019ve taken the nexus file from the paper\u2019s dryad repository and converted it to newick and saved it online so it can be easily downloaded. The file contains 160 trees representing mrbayes consensus trees inferred for different genomic regions.</p>"},{"location":"drawing-cloud-trees/","title":"multitree cloud trees","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[8]: Copied! <pre># a multi-newick string\nNEWICKS = \"\"\"\\\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((a:1,d:1):1,(b:1,e:1):1):1,c:3);\n(((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5);\n(((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3);\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4);\n(((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3);\n(((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3);\n\"\"\"\n</pre> # a multi-newick string NEWICKS = \"\"\"\\ (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((a:1,d:1):1,(b:1,e:1):1):1,c:3); (((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5); (((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3); (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4); (((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3); (((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3); \"\"\" In\u00a0[9]: Copied! <pre># create a multitree object\nmtree = toytree.mtree(NEWICKS)\n</pre> # create a multitree object mtree = toytree.mtree(NEWICKS) In\u00a0[24]: Copied! <pre># draw a cloud tree\nmtree.draw_cloud_tree(\n    scale_bar=True,\n    edge_style={\n        \"stroke-opacity\": 0.1,\n        \"stroke-width\": 2.5,\n    },\n);\n</pre> # draw a cloud tree mtree.draw_cloud_tree(     scale_bar=True,     edge_style={         \"stroke-opacity\": 0.1,         \"stroke-width\": 2.5,     }, ); abdec3210 In\u00a0[21]: Copied! <pre># make a copy of the multitree on which we will set styles\nmtree2 = mtree.copy()\n\n# get unique trees\nutrees = mtree2.get_unique_topologies()\n\n# set color to red if most common topology, else green\nfor tree in mtree2:\n    if tree.distance.get_treedist_rf(utrees[0][0]) == 0:\n        tree.style.edge_colors = 'red'\n    else:\n        tree.style.edge_colors = \"green\"\n\n# draw the cloud tree w/o any overriding args to use individual .style dicts\nmtree2.draw_cloud_tree(\n    scale_bar=True,\n    interior_algorithm=0, \n    edge_style={\"stroke-opacity\": 0.25},\n    tip_labels_style={\"font-size\": 15},\n);\n</pre> # make a copy of the multitree on which we will set styles mtree2 = mtree.copy()  # get unique trees utrees = mtree2.get_unique_topologies()  # set color to red if most common topology, else green for tree in mtree2:     if tree.distance.get_treedist_rf(utrees[0][0]) == 0:         tree.style.edge_colors = 'red'     else:         tree.style.edge_colors = \"green\"  # draw the cloud tree w/o any overriding args to use individual .style dicts mtree2.draw_cloud_tree(     scale_bar=True,     interior_algorithm=0,      edge_style={\"stroke-opacity\": 0.25},     tip_labels_style={\"font-size\": 15}, ); abdec3210"},{"location":"drawing-cloud-trees/#drawing-cloud-trees","title":"Drawing Cloud Trees\u00b6","text":"<p>Cloud tree drawings provide a useful way to visualize discordance among sets of trees in a MultiTree object.</p>"},{"location":"drawing-cloud-trees/#example-dataset","title":"Example dataset\u00b6","text":""},{"location":"drawing-cloud-trees/#cloud-tree-drawings","title":"Cloud tree drawings\u00b6","text":"<p>The <code>.draw_cloud_tree</code> function takes similar styling arguments as the <code>ToyTree.draw</code> function but accepts a few additional arguments.</p>"},{"location":"drawing-cloud-trees/#styling-individual-trees","title":"Styling individual trees\u00b6","text":"<p>I find it useful to set different styles on different trees in a set to better examine their differences. In this example I set a different color to the edges depending on whether the tree topology matches the most common topology in the set or not.</p>"},{"location":"drawing-coordinates/","title":"coordinates and axes","text":"In\u00a0[\u00a0]: Copied! <pre>import toytree\n\ntree = toytree.rtree.unittree(10)\ntree[0].name = 'AAAAAAAAAA'\nc, a, m = tree.draw(layout='r', tip_labels=True)\na.x.show = True\na.y.show = True\ntoytree.utils.debug_toyplot_canvas(c, a, marks=m)\nc\n</pre> import toytree  tree = toytree.rtree.unittree(10) tree[0].name = 'AAAAAAAAAA' c, a, m = tree.draw(layout='r', tip_labels=True) a.x.show = True a.y.show = True toytree.utils.debug_toyplot_canvas(c, a, marks=m) c  In\u00a0[5]: Copied! <pre>import toytree\nimport toyplot\nimport numpy as np\n\n\ntre = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")\n\nrtre = tre.root(13) #13th node corresponds to przewalskii outgroup\n\n\n# set dimensions of the canvas\ncanvas = toyplot.Canvas(width=700, height=250)\n\n# dissect canvas into multiple cartesian areas (x1, x2, y1, y2)\nax0 = canvas.cartesian(bounds=('10%', '45%', '10%', '90%'))\nax1 = canvas.cartesian(bounds=('55%', '90%', '10%', '90%'))\n\n# call draw with the 'axes' argument to pass it to a specific cartesian area\nstyle = {\n    \"tip_labels_align\": True,\n    \"tip_labels_style\": {\n        \"font-size\": \"9px\"\n    },\n}\nrtre.draw(axes=ax0, **style);\nrtre.draw(axes=ax1, ts='o', layout='r', tip_labels_colors=\"indigo\");\n\n#optional: choose to hide the axes markers\nax0.show = False\nax1.show = False\n</pre> import toytree import toyplot import numpy as np   tre = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")  rtre = tre.root(13) #13th node corresponds to przewalskii outgroup   # set dimensions of the canvas canvas = toyplot.Canvas(width=700, height=250)  # dissect canvas into multiple cartesian areas (x1, x2, y1, y2) ax0 = canvas.cartesian(bounds=('10%', '45%', '10%', '90%')) ax1 = canvas.cartesian(bounds=('55%', '90%', '10%', '90%'))  # call draw with the 'axes' argument to pass it to a specific cartesian area style = {     \"tip_labels_align\": True,     \"tip_labels_style\": {         \"font-size\": \"9px\"     }, } rtre.draw(axes=ax0, **style); rtre.draw(axes=ax1, ts='o', layout='r', tip_labels_colors=\"indigo\");  #optional: choose to hide the axes markers ax0.show = False ax1.show = False 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[8]: Copied! <pre># store the returned Canvas and Axes objects\ncanvas, axes, mark = tre.draw(\n    width=300, \n    height=300, \n    edge_style={\"stroke-opacity\": 0.5},\n    tip_labels=False,\n    node_mask=[False] + [True] * (tre.nnodes - 1),\n    node_sizes=14,\n    node_labels=\"idx\",\n    scale_bar = True\n)\n\n# overlay a grid \naxes.hlines(np.arange(0, tre.ntips), style={\"stroke\": \"red\", \"stroke-dasharray\": \"2,4\"})\naxes.vlines(0, style={\"stroke\": \"blue\", \"stroke-dasharray\": \"2,4\"});\n</pre> # store the returned Canvas and Axes objects canvas, axes, mark = tre.draw(     width=300,      height=300,      edge_style={\"stroke-opacity\": 0.5},     tip_labels=False,     node_mask=[False] + [True] * (tre.nnodes - 1),     node_sizes=14,     node_labels=\"idx\",     scale_bar = True )  # overlay a grid  axes.hlines(np.arange(0, tre.ntips), style={\"stroke\": \"red\", \"stroke-dasharray\": \"2,4\"}) axes.vlines(0, style={\"stroke\": \"blue\", \"stroke-dasharray\": \"2,4\"}); 12345678910111213141516171819202122230.050.040.030.020.010 In\u00a0[10]: Copied! <pre># store the returned Canvas and Axes objects\ncanvas, axes, mark = tre.draw(\n    width=300, \n    height=300, \n    tip_labels=False,\n    edge_style={\"stroke-opacity\": 0.5},\n    node_mask=[False] + [True] * (tre.nnodes - 1),\n    node_sizes=14,\n    node_labels=\"idx\",\n    layout='d',\n    scale_bar = True\n)\n\n# overlay a grid on the axes \naxes.vlines(np.arange(0, tre.ntips), style={\"stroke\": \"red\", \"stroke-dasharray\": \"2,4\"})\naxes.hlines(0, style={\"stroke\": \"blue\", \"stroke-dasharray\": \"2,4\"});\n</pre> # store the returned Canvas and Axes objects canvas, axes, mark = tre.draw(     width=300,      height=300,      tip_labels=False,     edge_style={\"stroke-opacity\": 0.5},     node_mask=[False] + [True] * (tre.nnodes - 1),     node_sizes=14,     node_labels=\"idx\",     layout='d',     scale_bar = True )  # overlay a grid on the axes  axes.vlines(np.arange(0, tre.ntips), style={\"stroke\": \"red\", \"stroke-dasharray\": \"2,4\"}) axes.hlines(0, style={\"stroke\": \"blue\", \"stroke-dasharray\": \"2,4\"}); 123456789101112131415161718192021222300.010.020.030.040.05"},{"location":"drawing-coordinates/#drawing-the-canvas-axes-and-coordinates","title":"Drawing: The Canvas, Axes, and coordinates\u00b6","text":"<p>When you call the <code>toytree.draw()</code> function it returns two Toyplot objects which are used to display the figure. The first is the Canvas, which is the HTML element that holds the figure, and the second is a Cartesian axes object, which represent the coordinates for the plot. You can store these objects when they are returned by the <code>draw()</code> function to further manipulate the plot. Storing the Canvas is necessary in order to save the plot.</p> <p>See also: Debugging canvas, axes, and data bounds in the User Guide (page: <code>debug-canvas</code>).</p>"},{"location":"drawing-coordinates/#debug-canvas-example","title":"Debug Canvas Example\u00b6","text":"<p>This example renders a tree and overlays debug fills to show the canvas, axes range, padding, and data bounds.</p>"},{"location":"drawing-coordinates/#the-canvas-and-axes","title":"The Canvas and Axes\u00b6","text":"<p>If you wish to combine multiple toytree figures into a single figure then it is easiest to first create instances of the toyplot Canvas and Axes objects and then to add the toytree drawing to this plot by using the <code>.draw(axes=axes)</code> argument. In the example below we first define the Canvas size, then define two coordinate axes inside of this Canvas, and then we pass these coordinate axes objects to two separate toytree drawings.</p>"},{"location":"drawing-coordinates/#the-coordinates","title":"The Coordinates\u00b6","text":"<p>Toytrees drawings are designed to use a set coordinate space within the axes to make it easy to situate additional plots to align with tree drawings. Regardless of whether the tree drawing is oriented 'right' or 'down' the farthest tip of the tree (not tip label but tip) will align at the zero-axis. For right-facing trees this means at x=0, for down-facing trees this means y=0. On the other axis, tree tips will be spaced from zero to ntips with a unit of 1 between each tip. Below I add a grid to overlay tree plots in both orientations to highlight the coordinate space.</p>"},{"location":"drawing-tree-grids/","title":"multitree tree grids","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[15]: Copied! <pre># a MultiTree containing 50 random coalescent trees with 10 tips each\nmtree = toytree.mtree([toytree.rtree.coaltree(10) for i in range(50)])\n</pre> # a MultiTree containing 50 random coalescent trees with 10 tips each mtree = toytree.mtree([toytree.rtree.coaltree(10) for i in range(50)]) In\u00a0[16]: Copied! <pre>mtree.draw();\n</pre> mtree.draw(); r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9 In\u00a0[4]: Copied! <pre># a multi-newick string\nNEWICKS = \"\"\"\\\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((a:1,d:1):1,(b:1,e:1):1):1,c:3);\n(((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5);\n(((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3);\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4);\n(((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3);\n(((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3);\n\"\"\"\n</pre> # a multi-newick string NEWICKS = \"\"\"\\ (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((a:1,d:1):1,(b:1,e:1):1):1,c:3); (((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5); (((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3); (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4); (((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3); (((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3); \"\"\" In\u00a0[5]: Copied! <pre># create a multitree object\nmtree = toytree.mtree(NEWICKS)\n</pre> # create a multitree object mtree = toytree.mtree(NEWICKS) In\u00a0[17]: Copied! <pre>mtree.draw();\n</pre> mtree.draw(); r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9 <p>shape -- The argument <code>shape</code> can be used to layout a grid describing how the trees should be arranged. It takes a tuple of ints as input in the form (rows, columns), similar to describing the shape of a numpy array. In the example below we draw 8 trees in a grid that has two rows and four columns. (See 'margin' below for further styling of spacing).</p> In\u00a0[18]: Copied! <pre>mtree.draw(shape=(2, 2), width=400, height=400);\n</pre> mtree.draw(shape=(2, 2), width=400, height=400); r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9 <p>shared_axes -- The <code>shared_axes</code> arg accepts a boolean and can be used to set the same shared time scale on the time-associated axis of tree plots (this varies depending on the layout direction). This is useful for comparing the node heights or edge lengths among trees visually. This is demonstrated for five random coalescent trees below which differ in coalescent times.</p> In\u00a0[21]: Copied! <pre>mtree.draw(scale_bar=True, layout='d', shared_axes=True);\n</pre> mtree.draw(scale_bar=True, layout='d', shared_axes=True); r0r1r2r3r4r5r6r7r8r90100200300400r0r1r2r3r4r5r6r7r8r90100200300400r0r1r2r3r4r5r6r7r8r90100200300400r0r1r2r3r4r5r6r7r8r90100200300400 <p>margin -- You can set the margin size in pixel units between the trees in a grid. The default value is automatically adjusted, but usually around 30. Larger values increase the spacing between trees, which can be useful for fitting longer tip names, while smaller values will pack trees closer together. A single value can be entered to apply to margins on all four sides, or a tuple of four values can be entered to modify the (top, right, bottom, left) margins in order.</p> In\u00a0[29]: Copied! <pre>mtree.draw(margin=(10, 30, 10, 30));\n</pre> mtree.draw(margin=(10, 30, 10, 30)); r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9 <p>style and label axes -- Just as you can style the axes of a Cartesian object in a tree drawing you can similarly use axes styling to modify the scale, set tick marks, change tick or axes label styles, or add titles to subplots. Here we add a title to each plot.</p> In\u00a0[32]: Copied! <pre># draw a tree grid while using shared_axes=True to share time axis\ncanvas, axes, marks = mtree.draw(\n    layout='d', edge_type='c', node_sizes=5, node_mask=False,\n    shape=(1, 4), width=650, height=250, scale_bar=True,\n    shared_axes=True, \n);\n\n# add a label to each subplot\nfor adx, ax in enumerate(axes):\n    ax.label.text = f\"tree {adx}\"\n\n# add a y-axis label to only the first subplot\naxes[0].y.label.text = \"        time (generations)\"\naxes[0].y.label.offset = 25\n</pre> # draw a tree grid while using shared_axes=True to share time axis canvas, axes, marks = mtree.draw(     layout='d', edge_type='c', node_sizes=5, node_mask=False,     shape=(1, 4), width=650, height=250, scale_bar=True,     shared_axes=True,  );  # add a label to each subplot for adx, ax in enumerate(axes):     ax.label.text = f\"tree {adx}\"  # add a y-axis label to only the first subplot axes[0].y.label.text = \"        time (generations)\" axes[0].y.label.offset = 25 r0r1r2r3r4r5r6r7r8r90100200300400        time (generations)tree 0r0r1r2r3r4r5r6r7r8r90100200300400tree 1r0r1r2r3r4r5r6r7r8r90100200300400tree 2r0r1r2r3r4r5r6r7r8r90100200300400tree 3 In\u00a0[43]: Copied! <pre># load nexus trees data from ...\nfish = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\")\n</pre> # load nexus trees data from ... fish = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\") In\u00a0[44]: Copied! <pre># draw with default styling\nfish.draw(shape=(1, 4), height=350);\n</pre> # draw with default styling fish.draw(shape=(1, 4), height=350); PriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXcorteziXbirchmanni_GARCXmalinche_CHIC2XmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXvariatusXevelynaeXmilleriXxiphidiumXmaculatus_JpWildPriapellaPsjonesiiXalvareziXhelleriiXmayaeXsignumXandersiXcouchianusXgordoniXmeyeriXxiphidiumXvariatusXmilleriXevelynaeXmaculatus_JpWildXmalinche_CHIC2Xbirchmanni_GARCXcorteziXnezahuacoyotlXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXclemenciae_GXmonticolusPriapellaPsjonesiiXalvareziXmayaeXsignumXhelleriiXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWildXmonticolusXclemenciae_GXbirchmanni_GARCXmalinche_CHIC2XcorteziXmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisPriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXmonticolusXclemenciae_GXcorteziXnezahuacoyotlXmalinche_CHIC2Xbirchmanni_GARCXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWild <p>For example, here we set a different color to the tip labels style attribute for each tree in the MultiTree object.</p> In\u00a0[47]: Copied! <pre># set different 'tip_labels_colors' for each tree\ncolors = toytree.color.color_cycler()\nfor tree in fish.treelist[:4]:\n    tree.style.tip_labels_colors = next(colors)\n\n# draw several trees\nfish.draw(shape=(1, 4), height=350);\n</pre> # set different 'tip_labels_colors' for each tree colors = toytree.color.color_cycler() for tree in fish.treelist[:4]:     tree.style.tip_labels_colors = next(colors)  # draw several trees fish.draw(shape=(1, 4), height=350); PriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXcorteziXbirchmanni_GARCXmalinche_CHIC2XmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXvariatusXevelynaeXmilleriXxiphidiumXmaculatus_JpWildPriapellaPsjonesiiXalvareziXhelleriiXmayaeXsignumXandersiXcouchianusXgordoniXmeyeriXxiphidiumXvariatusXmilleriXevelynaeXmaculatus_JpWildXmalinche_CHIC2Xbirchmanni_GARCXcorteziXnezahuacoyotlXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXclemenciae_GXmonticolusPriapellaPsjonesiiXalvareziXmayaeXsignumXhelleriiXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWildXmonticolusXclemenciae_GXbirchmanni_GARCXmalinche_CHIC2XcorteziXmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisPriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXmonticolusXclemenciae_GXcorteziXnezahuacoyotlXmalinche_CHIC2Xbirchmanni_GARCXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWild <p>The argument <code>fixed_order</code> is especially useful for multitree drawings for easily comparing trees visually. This fixes the order in which tips in the tree will be ordered, which makes differences between trees visible as conflicts. Here we infer a consensus tree from the full set of trees and use its tip order as the fixed order on which to plot all other trees.</p> In\u00a0[48]: Copied! <pre># get majority-rule consensus tree\nconsfish = fish.get_consensus_tree()\n\n# draw tree grid and use consensus tree order as a fixed_order of tips\nfish.draw(\n    shape=(2, 3),\n    height=600,\n    width=600,\n    fixed_order=True,\n    edge_type='c',\n    shared_axes=True,\n);\n</pre> # get majority-rule consensus tree consfish = fish.get_consensus_tree()  # draw tree grid and use consensus tree order as a fixed_order of tips fish.draw(     shape=(2, 3),     height=600,     width=600,     fixed_order=True,     edge_type='c',     shared_axes=True, ); PriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXcorteziXbirchmanni_GARCXmalinche_CHIC2XmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXvariatusXevelynaeXmilleriXxiphidiumXmaculatus_JpWildPriapellaPsjonesiiXalvareziXhelleriiXmayaeXsignumXandersiXcouchianusXgordoniXmeyeriXxiphidiumXvariatusXmilleriXevelynaeXmaculatus_JpWildXmalinche_CHIC2Xbirchmanni_GARCXcorteziXnezahuacoyotlXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXclemenciae_GXmonticolusPriapellaPsjonesiiXalvareziXmayaeXsignumXhelleriiXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWildXmonticolusXclemenciae_GXbirchmanni_GARCXmalinche_CHIC2XcorteziXmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisPriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXmonticolusXclemenciae_GXcorteziXnezahuacoyotlXmalinche_CHIC2Xbirchmanni_GARCXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWildPriapellaPsjonesiiXalvareziXhelleriiXmayaeXsignumXandersiXbirchmanni_GARCXmalinche_CHIC2XcontinensXpygmaeusXmultilineatusXnigrensisXcorteziXmontezumaeXnezahuacoyotlXxiphidiumXvariatusXevelynaeXcouchianusXgordoniXmeyeriXmilleriXmaculatus_JpWildXmonticolusXclemenciae_GPriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXandersiXcouchianusXgordoniXmeyeriXxiphidiumXvariatusXevelynaeXmilleriXbirchmanni_GARCXmalinche_CHIC2XcontinensXpygmaeusXmultilineatusXnigrensisXmontezumaeXcorteziXnezahuacoyotlXmaculatus_JpWild"},{"location":"drawing-tree-grids/#drawing-tree-grids","title":"Drawing Tree Grids\u00b6","text":"<p>When using <code>toytree.MultiTree</code> objects you can easily draw multiple trees displayed as a grid on a canvas by using the <code>.draw</code> function. Here a number of useful examples are demonstrated.</p>"},{"location":"drawing-tree-grids/#example-dataset","title":"Example dataset\u00b6","text":""},{"location":"drawing-tree-grids/#grid-tree-drawings","title":"Grid tree drawings\u00b6","text":"<p>The <code>.draw</code> function takes similar styling arguments as the <code>ToyTree.draw</code> function but accepts a few additional arguments to also describe how to plot and organize multiple trees on a shared Canvas. This includes <code>shape</code>, <code>separate_axes</code>, and <code>idxs</code>, described below. The <code>MultiTree.draw()</code> function returns three objects, similar to <code>ToyTree.draw()</code>, but instead of returning <code>(Canvas, Cartesian, Mark)</code> it returns <code>(Canvas, List[Cartesian], List[Mark])</code>, with the List elements composing the length of the number of trees drawn.</p> <p>As you can see, the drawing below appears as a grid of multiple trees spaced on a canvas. A similar plot an be made by using <code>toyplot</code> Canvas and Cartesian arguments directly to create a layout, and then adding tree drawings to each Cartesian axes, as explained in the [Advanced Drawing] section. The draw function here simply provides a convenient shortcut. Similar to normal tree drawings, many styling arguments are available. It is possible to apply style arguments to each tree individually, or to apply one style to all, as will be demonstrated below.</p>"},{"location":"drawing-tree-grids/#tree-grid-styling","title":"Tree grid styling\u00b6","text":"<p>Trees in MultiTree grid drawing can be styled individually by setting the style dictionary attribute of each ToyTree in the treelist. Additionally, most styles can be applied as arguments to the draw_tree_grid() function to apply styles to all trees at once.</p>"},{"location":"gentime-figure-1/","title":"Gentime figure 1","text":"In\u00a0[\u00a0]: Copied! <pre>##\n</pre> ## In\u00a0[135]: Copied! <pre>import toyplot\nimport toytree\nimport numpy as np\nimport pandas as pd\n</pre> import toyplot import toytree import numpy as np import pandas as pd In\u00a0[147]: Copied! <pre>balfixNvarG = pd.read_csv(\"./results/bal-fixN-varG-concat.csv\", index_col=0)\nbalvarNfixG = pd.read_csv(\"./results/bal-varN-fixG-concat.csv\", index_col=0)\n</pre> balfixNvarG = pd.read_csv(\"./results/bal-fixN-varG-concat.csv\", index_col=0) balvarNfixG = pd.read_csv(\"./results/bal-varN-fixG-concat.csv\", index_col=0) In\u00a0[148]: Copied! <pre>dists = [\n    balfixNvarG.dist_qrt.mean(),\n    ...,\n]\n</pre> dists = [     balfixNvarG.dist_qrt.mean(),     ..., ] In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[149]: Copied! <pre>data = np.random.uniform(0.25, 0.9, 8)\ndata[0] = dists[0]\n</pre> data = np.random.uniform(0.25, 0.9, 8) data[0] = dists[0] In\u00a0[150]: Copied! <pre>canvas = toyplot.Canvas(width=450, height=250)\naxes = canvas.cartesian()\naxes.x.ticks.locator = toyplot.locator.Explicit(np.arange(data.size) + 0.5, )\naxes.x.label.text = \"Phylogenetic dataset (locus length)\"\naxes.x.spine.style[\"stroke-width\"] = 2.5\naxes.x.ticks.style[\"stroke-width\"] = 2.5\naxes.x.ticks.labels.style[\"font-size\"] = 15\naxes.x.label.style[\"font-size\"] = 16\naxes.x.domain.min = 0\n\naxes.y.label.text = \"Tree distance (error)\"\naxes.y.spine.style[\"stroke-width\"] = 2.5\naxes.y.ticks.style[\"stroke-width\"] = 2.5\naxes.y.ticks.labels.style[\"font-size\"] = 15\naxes.y.ticks.labels.style[\"font-size\"] = 15\naxes.y.label.style[\"font-size\"] = 16\naxes.y.domain.max = 1.0\n\nstarts = np.arange(data.size) + 1/6\nmark = axes.bars(\n    starts, \n    starts + 4/6,\n    data,\n    style={\"stroke\": \"#262626\", \"stroke-width\": 1.5, \"fill\": \"lightgrey\"},\n)\n\ntoytree.utils.set_axes_ticks_external(axes);\n# toytree.utils.set_axes_box_outline(axes);\n</pre> canvas = toyplot.Canvas(width=450, height=250) axes = canvas.cartesian() axes.x.ticks.locator = toyplot.locator.Explicit(np.arange(data.size) + 0.5, ) axes.x.label.text = \"Phylogenetic dataset (locus length)\" axes.x.spine.style[\"stroke-width\"] = 2.5 axes.x.ticks.style[\"stroke-width\"] = 2.5 axes.x.ticks.labels.style[\"font-size\"] = 15 axes.x.label.style[\"font-size\"] = 16 axes.x.domain.min = 0  axes.y.label.text = \"Tree distance (error)\" axes.y.spine.style[\"stroke-width\"] = 2.5 axes.y.ticks.style[\"stroke-width\"] = 2.5 axes.y.ticks.labels.style[\"font-size\"] = 15 axes.y.ticks.labels.style[\"font-size\"] = 15 axes.y.label.style[\"font-size\"] = 16 axes.y.domain.max = 1.0  starts = np.arange(data.size) + 1/6 mark = axes.bars(     starts,      starts + 4/6,     data,     style={\"stroke\": \"#262626\", \"stroke-width\": 1.5, \"fill\": \"lightgrey\"}, )  toytree.utils.set_axes_ticks_external(axes); # toytree.utils.set_axes_box_outline(axes); 0.51.52.53.54.55.56.57.5Phylogenetic dataset (locus length)0.00.51.0Tree distance (error) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"gentime-figure-1/#load-data","title":"LOAD DATA\u00b6","text":""},{"location":"gentime-ne/","title":"Gentime ne","text":"In\u00a0[3]: Copied! <pre>import toytree\nimport toyplot\nimport ipcoal\nimport numpy as np\nimport pandas as pd\n</pre> import toytree import toyplot import ipcoal import numpy as np import pandas as pd In\u00a0[32]: Copied! <pre># get an ultrametric imbalanced tree\nTREE = toytree.rtree.baltree(8, treeheight=1.5e5)\nEDGES = [0, 1, 8, 10, 6, 7, 12, 13, 14]\nNE_DEFAULT = 1e5\nGT_DEFAULT = 1\nRNG = np.random.default_rng(123)\nNLOCI = 1000\nNREPS = 100\nLOCUS_LENS = [1e6, 1e5, 1e4, 1e3]\n</pre> # get an ultrametric imbalanced tree TREE = toytree.rtree.baltree(8, treeheight=1.5e5) EDGES = [0, 1, 8, 10, 6, 7, 12, 13, 14] NE_DEFAULT = 1e5 GT_DEFAULT = 1 RNG = np.random.default_rng(123) NLOCI = 1000 NREPS = 100 LOCUS_LENS = [1e6, 1e5, 1e4, 1e3] In\u00a0[52]: Copied! <pre># set parameters on the species tree\ntree_ne = TREE.copy()\ntree_ne = tree_ne.set_node_data(\"Ne\", {i: NE_DEFAULT * 10 for i in EDGES}, default=NE_DEFAULT)\ntree_ne = tree_ne.set_node_data(\"gt\", default=GT_DEFAULT)\ntree_ne = tree_ne.set_node_data(\"tg\", {i: i.dist / i.gt for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"tc\", {i: i.tg / (2 * i.Ne) for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"theta\", {i: 4 * i.Ne * 1e-8 for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"rho\", {i: 4 * i.Ne * 1e-9 for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"tg_rho\", {i: i.tg * i.rho for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"tg_theta\", {i: i.tg * i.theta * 1e-9 for i in tree_ne})\n\n# convert edge lens to units of generations.\ntree_ne = tree_ne.set_node_data(\"dist\", {i: i.tg for i in tree_ne})\n\n# show data\ntree_ne.get_node_data()\n</pre> # set parameters on the species tree tree_ne = TREE.copy() tree_ne = tree_ne.set_node_data(\"Ne\", {i: NE_DEFAULT * 10 for i in EDGES}, default=NE_DEFAULT) tree_ne = tree_ne.set_node_data(\"gt\", default=GT_DEFAULT) tree_ne = tree_ne.set_node_data(\"tg\", {i: i.dist / i.gt for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"tc\", {i: i.tg / (2 * i.Ne) for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"theta\", {i: 4 * i.Ne * 1e-8 for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"rho\", {i: 4 * i.Ne * 1e-9 for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"tg_rho\", {i: i.tg * i.rho for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"tg_theta\", {i: i.tg * i.theta * 1e-9 for i in tree_ne})  # convert edge lens to units of generations. tree_ne = tree_ne.set_node_data(\"dist\", {i: i.tg for i in tree_ne})  # show data tree_ne.get_node_data() Out[52]: idx name height dist support Ne gt rho tc tg theta 0 0 r0 0.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 1 1 r1 0.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 2 2 r2 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 3 3 r3 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 4 4 r4 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 5 5 r5 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 6 6 r6 0.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 7 7 r7 0.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 8 8 50000.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 9 9 50000.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 10 10 100000.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 11 11 50000.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 12 12 50000.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 13 13 100000.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 14 14 150000.0 0.0 NaN 1000000.0 1 0.0040 0.000 0.0 0.040 In\u00a0[53]: Copied! <pre>c, a, m = tree_ne.draw(scale_bar=True, edge_widths=(\"Ne\", 2, 6), edge_colors=\"gt\");\na.x.label.text = \"Time (generations)\"\n\n# draw tree w/ edge lengths in coal units\nc, a, m = tree_ne.set_node_data(\"dist\", {i: i.tc for i in tree_ne}).draw(scale_bar=True);\na.x.label.text = \"Time (coal units)\"\n</pre> c, a, m = tree_ne.draw(scale_bar=True, edge_widths=(\"Ne\", 2, 6), edge_colors=\"gt\"); a.x.label.text = \"Time (generations)\"  # draw tree w/ edge lengths in coal units c, a, m = tree_ne.set_node_data(\"dist\", {i: i.tc for i in tree_ne}).draw(scale_bar=True); a.x.label.text = \"Time (coal units)\" r0r1r2r3r4r5r6r7150000100000500000Time (generations) r0r1r2r3r4r5r6r70.40.20Time (coal units) In\u00a0[54]: Copied! <pre>tree_gt = TREE.copy()\ntree_gt = tree_gt.set_node_data(\"Ne\", default=NE_DEFAULT)\ntree_gt = tree_gt.set_node_data(\"gt\", {i: GT_DEFAULT * 10 for i in EDGES}, default=GT_DEFAULT)\ntree_gt = tree_gt.set_node_data(\"tg\", {i: i.dist / i.gt for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"tc\", {i: i.tg / (2 * i.Ne) for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"theta\", {i: 4 * i.Ne * 1e-8 for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"rho\", {i: 4 * i.Ne * 1e-9 for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"tg_rho\", {i: i.tg * i.rho for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"tg_theta\", {i: i.tg * i.theta * 1e-9 for i in tree_gt})\n\n# convert dist to units of generations. Draw and show data\ntree_gt = tree_gt.set_node_data(\"dist\", {i: i.tg for i in tree_gt})\ntree_gt.get_node_data()\n</pre> tree_gt = TREE.copy() tree_gt = tree_gt.set_node_data(\"Ne\", default=NE_DEFAULT) tree_gt = tree_gt.set_node_data(\"gt\", {i: GT_DEFAULT * 10 for i in EDGES}, default=GT_DEFAULT) tree_gt = tree_gt.set_node_data(\"tg\", {i: i.dist / i.gt for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"tc\", {i: i.tg / (2 * i.Ne) for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"theta\", {i: 4 * i.Ne * 1e-8 for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"rho\", {i: 4 * i.Ne * 1e-9 for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"tg_rho\", {i: i.tg * i.rho for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"tg_theta\", {i: i.tg * i.theta * 1e-9 for i in tree_gt})  # convert dist to units of generations. Draw and show data tree_gt = tree_gt.set_node_data(\"dist\", {i: i.tg for i in tree_gt}) tree_gt.get_node_data() Out[54]: idx name height dist support Ne gt rho tc tg theta 0 0 r0 90000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 1 1 r1 90000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 2 2 r2 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 3 3 r3 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 4 4 r4 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 5 5 r5 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 6 6 r6 90000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 7 7 r7 90000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 8 8 95000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 9 9 50000.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 10 10 100000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 11 11 50000.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 12 12 95000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 13 13 100000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 14 14 105000.0 0.0 NaN 100000.0 10 0.0004 0.000 0.0 0.004 In\u00a0[55]: Copied! <pre>c, a, m = tree_gt.draw(scale_bar=True, edge_widths=(\"Ne\", 2, 4), edge_colors=\"gt\");\na.x.label.text = \"Time (generations)\"\n\n# draw tree w/ edge lengths in coal units\nc, a, m = tree_gt.set_node_data(\"dist\", {i: i.tc for i in tree_gt}).draw(scale_bar=True);\na.x.label.text = \"Time (coal units)\"\n</pre> c, a, m = tree_gt.draw(scale_bar=True, edge_widths=(\"Ne\", 2, 4), edge_colors=\"gt\"); a.x.label.text = \"Time (generations)\"  # draw tree w/ edge lengths in coal units c, a, m = tree_gt.set_node_data(\"dist\", {i: i.tc for i in tree_gt}).draw(scale_bar=True); a.x.label.text = \"Time (coal units)\" r0r1r2r3r4r5r6r7100000500000Time (generations) r0r1r2r3r4r5r6r70.40.20Time (coal units) In\u00a0[93]: Copied! <pre>def get_n_topos(model):\n    ntopos = []\n    for _, locus in model.df.groupby(\"locus\"):\n        mtree = toytree.mtree(locus.genealogy)\n        ntopos.append(len(mtree.get_unique_topologies()))\n    return np.mean(ntopos)\n</pre> def get_n_topos(model):     ntopos = []     for _, locus in model.df.groupby(\"locus\"):         mtree = toytree.mtree(locus.genealogy)         ntopos.append(len(mtree.get_unique_topologies()))     return np.mean(ntopos) In\u00a0[94]: Copied! <pre>def iter_first_genealogies(model):\n    for _, df in model.df.groupby(\"locus\"):\n        yield toytree.tree(df.iloc[0, 6])\n</pre> def iter_first_genealogies(model):     for _, df in model.df.groupby(\"locus\"):         yield toytree.tree(df.iloc[0, 6]) In\u00a0[77]: Copied! <pre>COLUMNS = [\n    \"concat_tree\", \n    \"nloci\", \"locus_length\", \n    \"nsnps\", \"n_topologies\",\n    \"dist_rf\", \"dist_qrt\",\n]\n\n# setup data\ndata = pd.DataFrame(index=range(NREPS), columns=COLUMNS, dtype=float)\n</pre> COLUMNS = [     \"concat_tree\",      \"nloci\", \"locus_length\",      \"nsnps\", \"n_topologies\",     \"dist_rf\", \"dist_qrt\", ]  # setup data data = pd.DataFrame(index=range(NREPS), columns=COLUMNS, dtype=float) In\u00a0[78]: Copied! <pre>for rep in range(NREPS):\n    \n    # set up model and simulate loci\n    model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    \n    # get inferred concat tree\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    \n    # get distances from true species tree\n    concat_dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    concat_dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    \n    # get mean topologies per locus in true genealogies\n    ntopos_true = get_n_topos(model)\n    \n    # store data\n    data.iloc[rep] = [raxtree.write(), 1, 1e6, model.df.nsnps.sum(), ntopos_true, concat_dist_mci, concat_dist_qrt]\n    \n# write\ndata.to_csv(\"./results/bal-fixN-varG-concat.csv\")\n</pre> for rep in range(NREPS):          # set up model and simulate loci     model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)          # get inferred concat tree     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)          # get distances from true species tree     concat_dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     concat_dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference          # get mean topologies per locus in true genealogies     ntopos_true = get_n_topos(model)          # store data     data.iloc[rep] = [raxtree.write(), 1, 1e6, model.df.nsnps.sum(), ntopos_true, concat_dist_mci, concat_dist_qrt]      # write data.to_csv(\"./results/bal-fixN-varG-concat.csv\") In\u00a0[89]: Copied! <pre>for rep in range(NREPS):\n    \n    # set up model and simulate loci\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    \n    # get inferred concat tree\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    \n    # get distances from true species tree\n    concat_dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    concat_dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    \n    # get mean topologies per locus in true genealogies\n    ntopos_true = get_n_topos(model)\n    \n    # store data\n    data.iloc[rep] = [raxtree.write(), 1, 1e6, model.df.nsnps.sum(), ntopos_true, concat_dist_mci, concat_dist_qrt]\n    \n# write\ndata.to_csv(\"./results/bal-varN-fixG-concat.csv\")\n</pre> for rep in range(NREPS):          # set up model and simulate loci     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)          # get inferred concat tree     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)          # get distances from true species tree     concat_dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     concat_dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference          # get mean topologies per locus in true genealogies     ntopos_true = get_n_topos(model)          # store data     data.iloc[rep] = [raxtree.write(), 1, 1e6, model.df.nsnps.sum(), ntopos_true, concat_dist_mci, concat_dist_qrt]      # write data.to_csv(\"./results/bal-varN-fixG-concat.csv\") In\u00a0[90]: Copied! <pre>COLUMNS = [\n    \"sptree\",\n    \"nloci\", \"locus_length\", \n    \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"n_inferred_topologies\",\n    \"astral_true\", \"astral_true_dist_qrt\", \"astral_true_dist_rf\",\n    \"astral_inferred\", \"astral_inferred_dist_qrt\", \"astral_inferred_dist_rf\",\n]\n</pre> COLUMNS = [     \"sptree\",     \"nloci\", \"locus_length\",      \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"n_inferred_topologies\",     \"astral_true\", \"astral_true_dist_qrt\", \"astral_true_dist_rf\",     \"astral_inferred\", \"astral_inferred_dist_qrt\", \"astral_inferred_dist_rf\", ] In\u00a0[92]: Copied! <pre>get_n_topos(model)\n</pre> get_n_topos(model) Out[92]: <pre>3.811</pre> In\u00a0[91]: Copied! <pre># setup data\ndata = pd.DataFrame(index=range(NREPS), columns=COLUMNS, dtype=float)\n\n# iterate over nreps\nfor i in range(NREPS):\n    \n    # set up model and simulate loci\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1000, nsites=1e3)\n    \n    # get distribution of true genealogies\n    gtrees = list(iter_first_genealogies(model))\n    \n    # get distribution of inferred gene trees\n    raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=2, nworkers=4)\n\n    # get astral tree inferred from genealogies\n    atree_true = ipcoal.phylo.infer_astral_tree(gtrees)\n    \n    # get astral tree inferred from gene trees\n    atree_empirical = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)\n    \n    # get distances from true species tree\n    true_dist_mci = TREE.distance.get_treedist_rfg_mci(atree_true, normalize=True)\n    true_dist_qrt = TREE.distance.get_treedist_quartets(atree_true).similarity_to_reference\n    \n    # get distances from true species tree\n    emp_dist_rf = TREE.distance.get_treedist_rfg_mci(atree_empirical, normalize=True)\n    emp_dist_qrt = TREE.distance.get_treedist_quartets(atree_empirical).similarity_to_reference\n    \n    # get mean topologies per locus in true genealogies\n    ntopos_true = get_n_topos(model)\n    \n    # get number of topologies in empirical gene trees \n    ntopos_inferred = len(toytree.mtree(raxtrees.gene_tree).get_unique_topologies())\n    \n    # store data\n    data.iloc[i] = (\n        \"Ne\",\n        1000, 1e3,\n        model.df.groupby(\"locus\").nsnps.mean(), ntopos_true, ntopos_inferred,\n        atree_true.write(), true_dist_rf, true_dist_qrt,\n        atree_empirical.write(), emp_dist_rf, emp_dist_qrt,\n    )\n    print(\".\", end=\"\")\n\n# write\ndata.to_csv(\"./results/bal-varN-fixG-astral.csv\")\n</pre> # setup data data = pd.DataFrame(index=range(NREPS), columns=COLUMNS, dtype=float)  # iterate over nreps for i in range(NREPS):          # set up model and simulate loci     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1000, nsites=1e3)          # get distribution of true genealogies     gtrees = list(iter_first_genealogies(model))          # get distribution of inferred gene trees     raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=2, nworkers=4)      # get astral tree inferred from genealogies     atree_true = ipcoal.phylo.infer_astral_tree(gtrees)          # get astral tree inferred from gene trees     atree_empirical = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)          # get distances from true species tree     true_dist_mci = TREE.distance.get_treedist_rfg_mci(atree_true, normalize=True)     true_dist_qrt = TREE.distance.get_treedist_quartets(atree_true).similarity_to_reference          # get distances from true species tree     emp_dist_rf = TREE.distance.get_treedist_rfg_mci(atree_empirical, normalize=True)     emp_dist_qrt = TREE.distance.get_treedist_quartets(atree_empirical).similarity_to_reference          # get mean topologies per locus in true genealogies     ntopos_true = get_n_topos(model)          # get number of topologies in empirical gene trees      ntopos_inferred = len(toytree.mtree(raxtrees.gene_tree).get_unique_topologies())          # store data     data.iloc[i] = (         \"Ne\",         1000, 1e3,         model.df.groupby(\"locus\").nsnps.mean(), ntopos_true, ntopos_inferred,         atree_true.write(), true_dist_rf, true_dist_qrt,         atree_empirical.write(), emp_dist_rf, emp_dist_qrt,     )     print(\".\", end=\"\")  # write data.to_csv(\"./results/bal-varN-fixG-astral.csv\") <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/core/indexes/base.py:3652, in Index.get_loc(self, key)\n   3651 try:\n-&gt; 3652     return self._engine.get_loc(casted_key)\n   3653 except KeyError as err:\n\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/_libs/index.pyx:147, in pandas._libs.index.IndexEngine.get_loc()\n\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/_libs/index.pyx:176, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7080, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7088, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 0\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[91], line 35\n     32 ntopos_true = get_n_topos(model)\n     34 # get number of topologies in empirical gene trees \n---&gt; 35 ntopos_inferred = len(toytree.mtree(raxtrees).get_unique_topologies())\n     37 # store data\n     38 data.iloc[i] = (\n     39     \"Ne\",\n     40     1000, 1e3, \n   (...)\n     43     atree_empirical.write(), emp_dist_rf, emp_dist_qrt,\n     44 )\n\nFile ~/Documents/toytree/toytree/io/src/mtreeio.py:49, in mtree(data, **kwargs)\n     46     data = data.to_list()\n     48 # collection of ToyTrees\n---&gt; 49 if isinstance(data[0], ToyTree):\n     50     data = [i.copy() for i in data]\n     51     treelist = data\n\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/core/frame.py:3761, in DataFrame.__getitem__(self, key)\n   3759 if self.columns.nlevels &gt; 1:\n   3760     return self._getitem_multilevel(key)\n-&gt; 3761 indexer = self.columns.get_loc(key)\n   3762 if is_integer(indexer):\n   3763     indexer = [indexer]\n\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/core/indexes/base.py:3654, in Index.get_loc(self, key)\n   3652     return self._engine.get_loc(casted_key)\n   3653 except KeyError as err:\n-&gt; 3654     raise KeyError(key) from err\n   3655 except TypeError:\n   3656     # If we have a listlike key, _check_indexing_error will raise\n   3657     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3658     #  the TypeError.\n   3659     self._check_indexing_error(key)\n\nKeyError: 0</pre> In\u00a0[62]: Copied! <pre>model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\nmodel.sim_loci(nloci=100, nsites=1e4)\nmodel.df.groupby(\"locus\").nsnps.mean()\n</pre> model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG) model.sim_loci(nloci=100, nsites=1e4) model.df.groupby(\"locus\").nsnps.mean() Out[62]: <pre>locus\n0     11.835616\n1     13.235955\n2     13.386364\n3     10.049383\n4     11.224719\n        ...    \n95    11.845238\n96    12.787500\n97    13.144330\n98    10.987805\n99    10.900000\nName: nsnps, Length: 100, dtype: float64</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[133]: Copied! <pre>for i in range(3):\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    print(i, dist_mci, dist_qrt, model.df.nsnps.sum())\n</pre> for i in range(3):     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)     dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference     print(i, dist_mci, dist_qrt, model.df.nsnps.sum()) <pre>0 0.6044988508385621 0.6285714285714286 616328\n1 0.6044988508385621 0.6285714285714286 609840\n2 0.484844581260579 0.4714285714285714 607740\n</pre> In\u00a0[27]: Copied! <pre>model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\nmodel.sim_loci(nloci=1, nsites=1e6)\n</pre> model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG) model.sim_loci(nloci=1, nsites=1e6) In\u00a0[28]: Copied! <pre>raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n</pre> raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4) In\u00a0[23]: Copied! <pre>raxtree.draw(ts='s',  edge_type='c', );\n</pre> raxtree.draw(ts='s',  edge_type='c', ); 012345678910111213r7r0r6r5r4r2r3r1 In\u00a0[10]: Copied! <pre>model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\nmodel.sim_loci(nloci=500, nsites=int(1e6 / 500))\ngtrees = list(iter_first_genealogies(model))\natree = ipcoal.phylo.infer_astral_tree(gtrees)\n</pre> model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG) model.sim_loci(nloci=500, nsites=int(1e6 / 500)) gtrees = list(iter_first_genealogies(model)) atree = ipcoal.phylo.infer_astral_tree(gtrees) In\u00a0[14]: Copied! <pre>atree.root(\"~r[0-3]\").draw();\n</pre> atree.root(\"~r[0-3]\").draw(); r4r5r7r6r2r3r1r0 In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[133]: Copied! <pre>for i in range(3):\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    print(i, dist_mci, dist_qrt, model.df.nsnps.sum())\n</pre> for i in range(3):     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)     dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference     print(i, dist_mci, dist_qrt, model.df.nsnps.sum()) <pre>0 0.6044988508385621 0.6285714285714286 616328\n1 0.6044988508385621 0.6285714285714286 609840\n2 0.484844581260579 0.4714285714285714 607740\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>data = pd.DataFrame(index=range(100), columns=[\"method\", \"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)\nfor i in range(100):\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    ntopos = get_n_topos(model)\n    data.loc[i] = \"raxml\", 1, 1e6, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci\ndata.to_csv(\"./bal-varN-fixG-1\")\n</pre> data = pd.DataFrame(index=range(100), columns=[\"method\", \"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float) for i in range(100):     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)     dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference     ntopos = get_n_topos(model)     data.loc[i] = \"raxml\", 1, 1e6, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci data.to_csv(\"./bal-varN-fixG-1\")  In\u00a0[78]: Copied! <pre>data = pd.DataFrame(index=range(100), columns=[\"method\", \"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)\nfor i in range(100):\n    model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    ntopos = get_n_topos(model)\n    data.loc[i] = \"raxml\", 1, 1e6, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci\n\ndata.to_csv(\"./bal-fixN-varG-1\")\n</pre> data = pd.DataFrame(index=range(100), columns=[\"method\", \"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float) for i in range(100):     model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)     dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference     ntopos = get_n_topos(model)     data.loc[i] = \"raxml\", 1, 1e6, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci  data.to_csv(\"./bal-fixN-varG-1\") Out[78]: nloci mean_snps_per_loc mean_topologies_per_loc tree distance_qrt distance_mci 0 1.0 102808.0 2312.0 ((r7:0.027027,r5:0.02607... 0.428571 0.586306 1 1.0 102403.0 2225.0 (r0:0.023672,r2:0.026822... 0.785714 0.840064 2 1.0 98636.0 1979.0 (((r0:0.024178,r4:0.0246... 0.657143 0.664200 3 1.0 101283.0 2154.0 (((r6:0.022732,r0:0.0263... 0.471429 0.527081 4 1.0 100409.0 2112.0 ((r7:0.02501,r2:0.027519... 0.857143 0.884520 ... ... ... ... ... ... ... 95 1.0 100314.0 2215.0 ((r5:0.025548,r4:0.02442... 0.600000 0.615993 96 1.0 101480.0 2208.0 ((r3:0.028213,((r5:0.026... 0.600000 0.750320 97 1.0 100135.0 2379.0 (r5:0.026733,((r2:0.0258... 0.757143 0.775203 98 1.0 102699.0 2248.0 ((r2:0.025885,r0:0.02612... 0.742857 0.823748 99 1.0 103375.0 2279.0 (r1:0.025407,(((r3:0.025... 0.600000 0.615993 <p>100 rows \u00d7 6 columns</p> In\u00a0[80]: Copied! <pre>\n</pre> In\u00a0[87]: Copied! <pre>for nloci in [500]:#[1, 20, 50, 100, 500, 1000]:\n    nsites = int(1e6 / nloci)\n    \n    data = pd.DataFrame(index=range(100), columns=[\"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)\n\n    for i in range(2):\n        model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\n        model.sim_loci(nloci=nloci, nsites=nsites)\n        raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=4, nworkers=2)\n        astral_tree = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)\n        dist_mci = TREE.distance.get_treedist_rfg_mci(astral_tree, normalize=True)\n        dist_qrt = TREE.distance.get_treedist_quartets(astral_tree).similarity_to_reference\n        ntopos = get_n_topos(model)\n        data.loc[i] = (nloci, nsites, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci)\n    data.to_csv(f\"./bal-fixN-varG-{nloci}\")\n    print(f'finished nloci={nloci}')\n</pre> for nloci in [500]:#[1, 20, 50, 100, 500, 1000]:     nsites = int(1e6 / nloci)          data = pd.DataFrame(index=range(100), columns=[\"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)      for i in range(2):         model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)         model.sim_loci(nloci=nloci, nsites=nsites)         raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=4, nworkers=2)         astral_tree = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)         dist_mci = TREE.distance.get_treedist_rfg_mci(astral_tree, normalize=True)         dist_qrt = TREE.distance.get_treedist_quartets(astral_tree).similarity_to_reference         ntopos = get_n_topos(model)         data.loc[i] = (nloci, nsites, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci)     data.to_csv(f\"./bal-fixN-varG-{nloci}\")     print(f'finished nloci={nloci}') <pre>finished nloci=500\n</pre> In\u00a0[116]: Copied! <pre>genealogy.draw()\n</pre> genealogy.draw() Out[116]: <pre>(&lt;toyplot.canvas.Canvas at 0x7fd55c7d5c00&gt;,\n &lt;toyplot.coordinates.Cartesian at 0x7fd55c861330&gt;,\n &lt;toytree.drawing.src.mark_toytree.ToyTreeMark at 0x7fd557a5f400&gt;)</pre> r1r2r0r7r3r5r4r6 In\u00a0[113]: Copied! <pre>for _, df in model.df.groupby(\"locus\"):\n    genealogy = toytree.tree(df.iloc[0, 6])\n    dist = TREE.distance.get_treedist_quartets(genealogy).similarity_to_reference\n    print(dist)\n</pre> for _, df in model.df.groupby(\"locus\"):     genealogy = toytree.tree(df.iloc[0, 6])     dist = TREE.distance.get_treedist_quartets(genealogy).similarity_to_reference     print(dist) <pre>0.7857142857142857\n0.5857142857142856\n0.6285714285714286\n0.7857142857142857\n0.7142857142857143\n0.7285714285714286\n0.7428571428571429\n0.8285714285714285\n0.6285714285714286\n0.7428571428571429\n0.6285714285714286\n0.8142857142857143\n0.5714285714285714\n0.6857142857142857\n0.7714285714285715\n0.6\n0.6714285714285715\n0.48571428571428577\n0.7428571428571429\n0.8285714285714285\n0.6428571428571428\n0.6285714285714286\n0.8142857142857143\n0.6714285714285715\n0.8142857142857143\n0.6428571428571428\n0.6714285714285715\n0.6142857142857143\n0.6714285714285715\n0.6\n0.8142857142857143\n0.7714285714285715\n0.6\n0.8\n0.8285714285714285\n0.48571428571428577\n0.8428571428571429\n0.6142857142857143\n0.7285714285714286\n0.7428571428571429\n0.7142857142857143\n0.5428571428571429\n0.5\n0.4285714285714286\n0.5857142857142856\n0.6\n0.6714285714285715\n0.7428571428571429\n0.6285714285714286\n0.8\n0.5428571428571429\n0.7285714285714286\n0.7714285714285715\n0.6428571428571428\n0.5571428571428572\n0.6571428571428571\n0.4285714285714286\n0.6857142857142857\n0.7428571428571429\n0.7714285714285715\n0.8428571428571429\n0.6285714285714286\n0.7428571428571429\n0.7285714285714286\n0.8142857142857143\n0.7571428571428571\n0.5285714285714286\n0.7857142857142857\n0.8428571428571429\n0.6571428571428571\n0.7714285714285715\n0.7857142857142857\n0.8\n0.5\n0.6\n0.7142857142857143\n0.3571428571428571\n0.7428571428571429\n0.6142857142857143\n0.6857142857142857\n0.6\n0.7142857142857143\n0.6714285714285715\n0.6428571428571428\n0.7571428571428571\n0.5142857142857142\n0.7428571428571429\n0.4714285714285714\n0.5571428571428572\n0.37142857142857144\n0.6285714285714286\n0.4714285714285714\n0.7142857142857143\n0.7\n0.7714285714285715\n0.5857142857142856\n0.5714285714285714\n0.4285714285714286\n0.7428571428571429\n0.7285714285714286\n0.6142857142857143\n0.6714285714285715\n0.6714285714285715\n0.8428571428571429\n0.8\n0.7571428571428571\n0.8142857142857143\n0.48571428571428577\n0.7714285714285715\n0.7857142857142857\n0.4714285714285714\n0.6857142857142857\n0.6714285714285715\n0.7857142857142857\n0.7285714285714286\n0.7142857142857143\n0.7857142857142857\n0.5\n0.7428571428571429\n0.24285714285714288\n0.5142857142857142\n0.7714285714285715\n0.7714285714285715\n0.6285714285714286\n0.7285714285714286\n0.6714285714285715\n0.7428571428571429\n0.4285714285714286\n0.7714285714285715\n0.37142857142857144\n0.4571428571428572\n0.6428571428571428\n0.7857142857142857\n0.7857142857142857\n0.7142857142857143\n0.8\n0.6285714285714286\n0.5857142857142856\n0.8285714285714285\n0.6\n0.7428571428571429\n0.6428571428571428\n0.7714285714285715\n0.8285714285714285\n0.8285714285714285\n0.5285714285714286\n0.6428571428571428\n0.7285714285714286\n0.7285714285714286\n0.7142857142857143\n0.6714285714285715\n0.6285714285714286\n0.8142857142857143\n0.5\n0.6714285714285715\n0.30000000000000004\n0.8571428571428572\n0.5285714285714286\n0.6\n0.6428571428571428\n0.6571428571428571\n0.7714285714285715\n0.6857142857142857\n0.41428571428571426\n0.6142857142857143\n0.5857142857142856\n0.7857142857142857\n0.5714285714285714\n0.4714285714285714\n0.6\n0.6285714285714286\n0.5285714285714286\n0.5857142857142856\n0.6285714285714286\n0.6142857142857143\n0.6857142857142857\n0.4285714285714286\n0.8\n0.4285714285714286\n0.8428571428571429\n0.6428571428571428\n0.5142857142857142\n0.7714285714285715\n0.6285714285714286\n0.8\n0.5857142857142856\n0.6285714285714286\n0.8142857142857143\n0.6714285714285715\n0.6857142857142857\n0.7428571428571429\n0.6428571428571428\n0.6857142857142857\n0.5714285714285714\n0.7857142857142857\n0.6285714285714286\n0.7428571428571429\n0.7857142857142857\n0.7142857142857143\n0.5285714285714286\n0.6571428571428571\n0.6714285714285715\n0.8428571428571429\n0.6857142857142857\n0.7428571428571429\n0.6142857142857143\n0.6714285714285715\n0.6857142857142857\n0.7285714285714286\n0.7571428571428571\n0.7428571428571429\n0.3571428571428571\n0.8142857142857143\n0.3571428571428571\n0.7428571428571429\n0.8142857142857143\n0.8142857142857143\n0.8285714285714285\n0.4285714285714286\n0.5571428571428572\n0.5857142857142856\n0.6857142857142857\n0.7428571428571429\n0.5285714285714286\n0.7285714285714286\n0.8142857142857143\n0.6\n0.7142857142857143\n0.5285714285714286\n0.5142857142857142\n0.6\n0.7857142857142857\n0.6428571428571428\n0.5571428571428572\n0.7857142857142857\n0.6428571428571428\n0.8142857142857143\n0.5\n0.6142857142857143\n0.8142857142857143\n0.6285714285714286\n0.6428571428571428\n0.7285714285714286\n0.6571428571428571\n0.7428571428571429\n0.8\n0.6142857142857143\n0.4714285714285714\n0.5\n0.7714285714285715\n0.7857142857142857\n0.6857142857142857\n0.8\n0.7285714285714286\n0.5142857142857142\n0.7142857142857143\n0.4285714285714286\n0.41428571428571426\n0.6285714285714286\n0.6714285714285715\n0.5285714285714286\n0.6\n0.6857142857142857\n0.8142857142857143\n0.6857142857142857\n0.7142857142857143\n0.8\n0.7285714285714286\n0.3571428571428571\n0.7142857142857143\n0.6\n0.7428571428571429\n0.6428571428571428\n0.7857142857142857\n0.6285714285714286\n0.7142857142857143\n0.7714285714285715\n0.5857142857142856\n0.7428571428571429\n0.8\n0.6\n0.7857142857142857\n0.5285714285714286\n0.7857142857142857\n0.6142857142857143\n0.6428571428571428\n0.8285714285714285\n0.48571428571428577\n0.6571428571428571\n0.7\n0.3571428571428571\n0.8428571428571429\n0.5142857142857142\n0.6428571428571428\n0.4714285714285714\n0.6142857142857143\n0.8142857142857143\n0.6142857142857143\n0.4714285714285714\n0.3571428571428571\n0.7857142857142857\n0.7428571428571429\n0.7571428571428571\n0.7142857142857143\n0.7285714285714286\n0.5\n0.7142857142857143\n0.6714285714285715\n0.6857142857142857\n0.4285714285714286\n0.7714285714285715\n0.7428571428571429\n0.5142857142857142\n0.6714285714285715\n0.6857142857142857\n0.4285714285714286\n0.7714285714285715\n0.8285714285714285\n0.4285714285714286\n0.7142857142857143\n0.6857142857142857\n0.6428571428571428\n0.6714285714285715\n0.7571428571428571\n0.7285714285714286\n0.6714285714285715\n0.8571428571428572\n0.5142857142857142\n0.5714285714285714\n0.7\n0.4285714285714286\n0.7285714285714286\n0.4285714285714286\n0.3571428571428571\n0.7285714285714286\n0.5571428571428572\n0.7714285714285715\n0.3571428571428571\n0.7428571428571429\n0.6714285714285715\n0.8142857142857143\n0.7142857142857143\n0.3571428571428571\n0.8142857142857143\n0.7\n0.3571428571428571\n0.7285714285714286\n0.6857142857142857\n0.4285714285714286\n0.7285714285714286\n0.7714285714285715\n0.6285714285714286\n0.7142857142857143\n0.6\n0.5714285714285714\n0.7714285714285715\n0.7571428571428571\n0.5142857142857142\n0.8142857142857143\n0.7285714285714286\n0.7428571428571429\n0.7285714285714286\n0.5714285714285714\n0.8285714285714285\n0.8142857142857143\n0.6\n0.6428571428571428\n0.5857142857142856\n0.8428571428571429\n0.7714285714285715\n0.5\n0.7142857142857143\n0.41428571428571426\n0.8142857142857143\n0.6428571428571428\n0.6\n0.5428571428571429\n0.5142857142857142\n0.5\n0.6\n0.5\n0.3571428571428571\n0.7571428571428571\n0.6714285714285715\n0.6142857142857143\n0.6428571428571428\n0.3571428571428571\n0.4714285714285714\n0.6142857142857143\n0.7285714285714286\n0.6285714285714286\n0.7714285714285715\n0.8142857142857143\n0.7428571428571429\n0.8285714285714285\n0.6428571428571428\n0.7428571428571429\n0.7\n0.6\n0.5142857142857142\n0.7142857142857143\n0.7857142857142857\n0.7571428571428571\n0.6428571428571428\n0.7857142857142857\n0.7714285714285715\n0.5714285714285714\n0.7857142857142857\n0.4571428571428572\n0.8428571428571429\n0.6714285714285715\n0.7285714285714286\n0.3571428571428571\n0.8428571428571429\n0.6428571428571428\n0.7142857142857143\n0.4285714285714286\n0.7285714285714286\n0.5\n0.48571428571428577\n0.6428571428571428\n0.7857142857142857\n0.6285714285714286\n0.6714285714285715\n0.7714285714285715\n0.7142857142857143\n0.7142857142857143\n0.7142857142857143\n0.6\n0.5428571428571429\n0.6142857142857143\n0.3571428571428571\n0.7142857142857143\n0.6\n0.6142857142857143\n0.6428571428571428\n0.7857142857142857\n0.6714285714285715\n0.6\n0.6285714285714286\n0.6285714285714286\n0.6\n0.6714285714285715\n0.5285714285714286\n0.6285714285714286\n0.6428571428571428\n0.7285714285714286\n0.5857142857142856\n0.7714285714285715\n0.7428571428571429\n0.8571428571428572\n0.6\n0.6428571428571428\n0.7714285714285715\n0.7285714285714286\n0.44285714285714284\n0.4571428571428572\n0.8428571428571429\n0.6142857142857143\n0.7428571428571429\n0.8285714285714285\n0.6285714285714286\n0.5428571428571429\n0.7142857142857143\n0.8285714285714285\n0.5571428571428572\n0.6142857142857143\n0.7285714285714286\n0.7571428571428571\n0.7285714285714286\n0.5285714285714286\n0.22857142857142854\n0.5285714285714286\n0.5857142857142856\n0.7\n0.4285714285714286\n0.4571428571428572\n0.6428571428571428\n0.7857142857142857\n0.6714285714285715\n0.7142857142857143\n0.6142857142857143\n0.6428571428571428\n0.7142857142857143\n0.5857142857142856\n0.6142857142857143\n0.7428571428571429\n0.7\n0.6714285714285715\n0.4571428571428572\n0.5142857142857142\n0.7857142857142857\n0.7714285714285715\n0.6428571428571428\n0.6571428571428571\n0.7857142857142857\n0.8142857142857143\n0.4285714285714286\n0.6714285714285715\n0.6714285714285715\n</pre> In\u00a0[\u00a0]: Copied! <pre>for nloci in [1, 20, 50, 100, 500, 1000]:\n    nsites = int(1e6 / nloci)\n    \n    data = pd.DataFrame(index=range(100), columns=[\"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)\n\n    for i in range(100):\n        model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n        model.sim_loci(nloci=nloci, nsites=nsites)\n        raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=4, nworkers=2)\n        astral_tree = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)\n        dist_mci = TREE.distance.get_treedist_rfg_mci(astral_tree, normalize=True)\n        dist_qrt = TREE.distance.get_treedist_quartets(astral_tree).similarity_to_reference\n        ntopos = get_n_topos(model)\n        data.loc[i] = (nloci, nsites, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci)\n    data.to_csv(f\"./bal-varN-fixG-{nloci}\")\n    print(f'finished nloci={nloci}')\n</pre> for nloci in [1, 20, 50, 100, 500, 1000]:     nsites = int(1e6 / nloci)          data = pd.DataFrame(index=range(100), columns=[\"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)      for i in range(100):         model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)         model.sim_loci(nloci=nloci, nsites=nsites)         raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=4, nworkers=2)         astral_tree = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)         dist_mci = TREE.distance.get_treedist_rfg_mci(astral_tree, normalize=True)         dist_qrt = TREE.distance.get_treedist_quartets(astral_tree).similarity_to_reference         ntopos = get_n_topos(model)         data.loc[i] = (nloci, nsites, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci)     data.to_csv(f\"./bal-varN-fixG-{nloci}\")     print(f'finished nloci={nloci}') In\u00a0[85]: Copied! <pre>cat ./bal-fixN-varG-20\n</pre> cat ./bal-fixN-varG-20 <pre>,method,nloci,locus_length,mean_snps_per_loc,mean_topologies_per_loc,tree,distance_qrt,distance_mci\r\n0,astral,20.0,50000.0,100037.0,3.719,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n1,astral,20.0,50000.0,101689.0,3.733,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n2,astral,20.0,50000.0,101243.0,3.799,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n3,astral,20.0,50000.0,101487.0,3.7,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n4,astral,20.0,50000.0,101650.0,3.737,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n5,,,,,,,,\r\n6,,,,,,,,\r\n7,,,,,,,,\r\n8,,,,,,,,\r\n9,,,,,,,,\r\n10,,,,,,,,\r\n11,,,,,,,,\r\n12,,,,,,,,\r\n13,,,,,,,,\r\n14,,,,,,,,\r\n15,,,,,,,,\r\n16,,,,,,,,\r\n17,,,,,,,,\r\n18,,,,,,,,\r\n19,,,,,,,,\r\n20,,,,,,,,\r\n21,,,,,,,,\r\n22,,,,,,,,\r\n23,,,,,,,,\r\n24,,,,,,,,\r\n25,,,,,,,,\r\n26,,,,,,,,\r\n27,,,,,,,,\r\n28,,,,,,,,\r\n29,,,,,,,,\r\n30,,,,,,,,\r\n31,,,,,,,,\r\n32,,,,,,,,\r\n33,,,,,,,,\r\n34,,,,,,,,\r\n35,,,,,,,,\r\n36,,,,,,,,\r\n37,,,,,,,,\r\n38,,,,,,,,\r\n39,,,,,,,,\r\n40,,,,,,,,\r\n41,,,,,,,,\r\n42,,,,,,,,\r\n43,,,,,,,,\r\n44,,,,,,,,\r\n45,,,,,,,,\r\n46,,,,,,,,\r\n47,,,,,,,,\r\n48,,,,,,,,\r\n49,,,,,,,,\r\n50,,,,,,,,\r\n51,,,,,,,,\r\n52,,,,,,,,\r\n53,,,,,,,,\r\n54,,,,,,,,\r\n55,,,,,,,,\r\n56,,,,,,,,\r\n57,,,,,,,,\r\n58,,,,,,,,\r\n59,,,,,,,,\r\n60,,,,,,,,\r\n61,,,,,,,,\r\n62,,,,,,,,\r\n63,,,,,,,,\r\n64,,,,,,,,\r\n65,,,,,,,,\r\n66,,,,,,,,\r\n67,,,,,,,,\r\n68,,,,,,,,\r\n69,,,,,,,,\r\n70,,,,,,,,\r\n71,,,,,,,,\r\n72,,,,,,,,\r\n73,,,,,,,,\r\n74,,,,,,,,\r\n75,,,,,,,,\r\n76,,,,,,,,\r\n77,,,,,,,,\r\n78,,,,,,,,\r\n79,,,,,,,,\r\n80,,,,,,,,\r\n81,,,,,,,,\r\n82,,,,,,,,\r\n83,,,,,,,,\r\n84,,,,,,,,\r\n85,,,,,,,,\r\n86,,,,,,,,\r\n87,,,,,,,,\r\n88,,,,,,,,\r\n89,,,,,,,,\r\n90,,,,,,,,\r\n91,,,,,,,,\r\n92,,,,,,,,\r\n93,,,,,,,,\r\n94,,,,,,,,\r\n95,,,,,,,,\r\n96,,,,,,,,\r\n97,,,,,,,,\r\n98,,,,,,,,\r\n99,,,,,,,,\r\n</pre> In\u00a0[18]: Copied! <pre>model = ipcoal.Model(tree_gt)\nmodel.sim_loci(nloci=1, nsites=1e6)\n</pre> model = ipcoal.Model(tree_gt) model.sim_loci(nloci=1, nsites=1e6) In\u00a0[19]: Copied! <pre>raxtree = ipcoal.phylo.infer_raxml_ng_tree(model)\n</pre> raxtree = ipcoal.phylo.infer_raxml_ng_tree(model) In\u00a0[22]: Copied! <pre>raxtree.draw(ts='s', edge_type='c',);\n# fixed_order=TREE.get_tip_labels());\n</pre> raxtree.draw(ts='s', edge_type='c',); # fixed_order=TREE.get_tip_labels()); 012345678910111213r7r6r4r1r3r0r5r2 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"gentime-ne/#species-tree-scenario-w-fixed-ne-and-variable-gt","title":"Species tree scenario w/ fixed <code>Ne</code> and variable <code>gt</code>\u00b6","text":"<p>Define two species trees w/ different parameterizations. One has variable effective populations (Ne) and fixed generation times (gt), the other has fixed Ne and variable gt. Both have the same species tree in terms of topology and edge lengths in coalescent units.</p>"},{"location":"gentime-ne/#tree1-variable-ne-fixed-gt","title":"Tree1: Variable <code>Ne</code>, fixed <code>gt</code>\u00b6","text":""},{"location":"gentime-ne/#tree-2-fixed-ne-variable-gt","title":"Tree 2: Fixed <code>Ne</code>, variable <code>gt</code>\u00b6","text":""},{"location":"gentime-ne/#some-useful-functions","title":"Some useful functions\u00b6","text":""},{"location":"gentime-ne/#phylogenetic-inference","title":"Phylogenetic inference\u00b6","text":"<ul> <li>N loci = 1000</li> <li>Locus length = 1e6, 1e5, 1e4, 1e3</li> <li>N replicates = 100</li> </ul>"},{"location":"gentime-ne/#concatenation","title":"Concatenation\u00b6","text":""},{"location":"gentime-ne/#astral","title":"Astral\u00b6","text":""},{"location":"heatmap/","title":"ToyTree with matrix/heatmap","text":"In\u00a0[5]: Copied! <pre>import toytree\nimport numpy as np\nimport toyplot\n\n# load tree with variable name lengths\ntree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")\ntree = tree.root(13) #13th node corresponds to przwilenskii outgroup\n</pre> import toytree import numpy as np import toyplot  # load tree with variable name lengths tree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\") tree = tree.root(13) #13th node corresponds to przwilenskii outgroup In\u00a0[6]: Copied! <pre># generate some random data for this columns\nspdata = np.random.randint(low=1, high=10, size=(tree.ntips, 5))\nspdata\n</pre> # generate some random data for this columns spdata = np.random.randint(low=1, high=10, size=(tree.ntips, 5)) spdata Out[6]: <pre>array([[2, 5, 7, 7, 7],\n       [6, 2, 2, 4, 2],\n       [5, 3, 9, 3, 5],\n       [8, 6, 5, 9, 6],\n       [5, 6, 7, 2, 4],\n       [8, 2, 9, 4, 3],\n       [4, 2, 2, 3, 2],\n       [9, 2, 1, 4, 8],\n       [6, 6, 1, 5, 3],\n       [3, 5, 2, 8, 2],\n       [7, 9, 1, 5, 1],\n       [1, 4, 1, 8, 7],\n       [9, 8, 7, 6, 4]])</pre> In\u00a0[11]: Copied! <pre># scale tree\nctree = tree.mod.edges_scale_to_root_height()\n\n# get canvas and axes with tree plot\ncanvas, axes, mark = ctree.draw(\n    width=600,\n    height=300,\n    tip_labels_align=True,\n    tip_labels_style={\"-toyplot-anchor-shift\": \"80px\"}\n    \n);\n\n# add n columns of data (here random data)\nncols = 5\nxoffset = 1\nfor col in range(5):\n    \n    # select the column of data\n    data = spdata[:, col]\n    \n    # plot the data column\n    axes.scatterplot(\n        np.repeat(col, tree.ntips) + xoffset, \n        np.arange(tree.ntips),\n        marker='s',\n        size=10,\n        color=\"magenta\",           \n        opacity=0.1 + data[::-1] / data.max(),\n        title=data,\n    );\n\n# stretch domain to fit long tip names\naxes.x.domain.max = 40\n</pre> # scale tree ctree = tree.mod.edges_scale_to_root_height()  # get canvas and axes with tree plot canvas, axes, mark = ctree.draw(     width=600,     height=300,     tip_labels_align=True,     tip_labels_style={\"-toyplot-anchor-shift\": \"80px\"}      );  # add n columns of data (here random data) ncols = 5 xoffset = 1 for col in range(5):          # select the column of data     data = spdata[:, col]          # plot the data column     axes.scatterplot(         np.repeat(col, tree.ntips) + xoffset,          np.arange(tree.ntips),         marker='s',         size=10,         color=\"magenta\",                    opacity=0.1 + data[::-1] / data.max(),         title=data,     );  # stretch domain to fit long tip names axes.x.domain.max = 40 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides26585849637195236622265948729579211211774392434585867256432832174 In\u00a0[8]: Copied! <pre># a random rectangular matrix\nmatrix = np.arange(tree.ntips * 5).reshape(tree.ntips, 5)\nmatrix.shape\n</pre> # a random rectangular matrix matrix = np.arange(tree.ntips * 5).reshape(tree.ntips, 5) matrix.shape Out[8]: <pre>(13, 5)</pre> In\u00a0[9]: Copied! <pre># create a canvas\ncanvas = toyplot.Canvas(width=500, height=350);\n\n# add tree \naxes = canvas.cartesian(bounds=(50, 150, 70, 250))\ntree.draw(axes=axes, tip_labels=False, tip_labels_align=True)\n\n# add matrix\ntable = canvas.table(\n    rows=13,\n    columns=5, \n    margin=0,\n    bounds=(175, 250, 65, 255),\n)\n\ncolormap = toyplot.color.brewer.map(\"BlueRed\")\n\n# apply a color to each cell in the table\nfor ridx in range(matrix.shape[0]):\n    for cidx in range(matrix.shape[1]):\n        cell = table.cells.cell[ridx, cidx]\n        cell.style = {\n            \"fill\": colormap.colors(matrix[ridx, cidx], 0, 100), \n        }\n\n# style the gaps between cells\ntable.body.gaps.columns[:] = 3\ntable.body.gaps.rows[:] = 3 \n\n# hide axes coordinates\naxes.show = False\n</pre> # create a canvas canvas = toyplot.Canvas(width=500, height=350);  # add tree  axes = canvas.cartesian(bounds=(50, 150, 70, 250)) tree.draw(axes=axes, tip_labels=False, tip_labels_align=True)  # add matrix table = canvas.table(     rows=13,     columns=5,      margin=0,     bounds=(175, 250, 65, 255), )  colormap = toyplot.color.brewer.map(\"BlueRed\")  # apply a color to each cell in the table for ridx in range(matrix.shape[0]):     for cidx in range(matrix.shape[1]):         cell = table.cells.cell[ridx, cidx]         cell.style = {             \"fill\": colormap.colors(matrix[ridx, cidx], 0, 100),          }  # style the gaps between cells table.body.gaps.columns[:] = 3 table.body.gaps.rows[:] = 3   # hide axes coordinates axes.show = False In\u00a0[10]: Copied! <pre># create a canvas\ncanvas = toyplot.Canvas(width=500, height=350);\n\n# add tree \naxes = canvas.cartesian(bounds=(50, 150, 70, 250))\ntree.draw(axes=axes, tip_labels=False, tip_labels_align=True)\n\n# add matrix\ncolormap = toyplot.color.brewer.map(\"BlueRed\")\ntable = canvas.matrix(\n    (matrix, colormap),\n    bounds=(120, 300, 25, 295), \n    tshow=True,\n    tlabel=\"Traits\",\n    lshow=False,\n    rshow=True,\n    margin=0,\n    rlocator=toyplot.locator.Explicit(range(tree.ntips), tree.get_tip_labels()[::-1])\n)\n\n# hide axes coordinates\naxes.show = False\n</pre> # create a canvas canvas = toyplot.Canvas(width=500, height=350);  # add tree  axes = canvas.cartesian(bounds=(50, 150, 70, 250)) tree.draw(axes=axes, tip_labels=False, tip_labels_align=True)  # add matrix colormap = toyplot.color.brewer.map(\"BlueRed\") table = canvas.matrix(     (matrix, colormap),     bounds=(120, 300, 25, 295),      tshow=True,     tlabel=\"Traits\",     lshow=False,     rshow=True,     margin=0,     rlocator=toyplot.locator.Explicit(range(tree.ntips), tree.get_tip_labels()[::-1]) )  # hide axes coordinates axes.show = False 012340.0000001.0000002.0000003.0000004.00000041478_cyathophylloides5.0000006.0000007.0000008.0000009.00000041954_cyathophylloides10.00000011.00000012.00000013.00000014.00000030686_cyathophylla15.00000016.00000017.00000018.00000019.00000029154_superba20.00000021.00000022.00000023.00000024.00000038362_rex25.00000026.00000027.00000028.00000029.00000039618_rex30.00000031.00000032.00000033.00000034.00000035236_rex35.00000036.00000037.00000038.00000039.00000035855_rex40.00000041.00000042.00000043.00000044.00000040578_rex45.00000046.00000047.00000048.00000049.00000030556_thamno50.00000051.00000052.00000053.00000054.00000033413_thamno55.00000056.00000057.00000058.00000059.00000033588_przewalskii60.00000061.00000062.00000063.00000064.00000032082_przewalskiiTraits"},{"location":"heatmap/#plot-tree-with-matrixheatmap","title":"Plot tree with matrix/heatmap\u00b6","text":""},{"location":"heatmap/#method-1","title":"Method 1:\u00b6","text":"<p>The simplest method is to plot the tree and markers on shared coordinate axes. To make it easy to space items on the x-axis I set the tree to be 2X the width of the data (matrix), which allows me to use units of x=1 to space items on the x-axis. Then I generate a canvas and axes by drawing a tree, as usual, and here I add the data as square scatterplot markers with different opacities to represent the (randomly generated) data.</p> <p>The only tricky thing here is that you need to use <code>tip_labels_style</code> to offset the x-location of the tre tip labels, and also to extend the x-axis max domain if the names are long to prevent them from getting cut off.</p>"},{"location":"heatmap/#method-2","title":"Method 2:\u00b6","text":"<p>Using both a matrix and cartesian axes in toyplot. The key to aligning the two is that matrices have a margin of 50px by default. There aren't as many options to style matrix cells as there are in the option above. Here I used the right-side matrix labels to add and align tip names.</p>"},{"location":"highlights/","title":"Colored rectangles to highlight clades","text":"In\u00a0[2]: Copied! <pre>import toytree\nimport toyplot\n\n# generate a random tree\nrtre = toytree.rtree.unittree(20, seed=12345)\n\n# make the canvas and axes\ncanvas = toyplot.Canvas(width=250, height=400)\naxes = canvas.cartesian()\naxes.show = True\n\n# draw a rectangle (x1, x2, y1, y2)\naxes.rectangle(\n    -0.75, 0.35, -0.5, 4.5, \n    opacity=0.25,\n    color='yellow',\n)\n\n# draw a rectangle (x1, x2, y1, y2)\naxes.rectangle(\n    -0.75, 0.35, 4.5, 8.5, \n    opacity=0.25,\n    color='magenta',\n)\n\n# add tree to the axes \nrtre.draw(axes=axes);\n</pre> import toytree import toyplot  # generate a random tree rtre = toytree.rtree.unittree(20, seed=12345)  # make the canvas and axes canvas = toyplot.Canvas(width=250, height=400) axes = canvas.cartesian() axes.show = True  # draw a rectangle (x1, x2, y1, y2) axes.rectangle(     -0.75, 0.35, -0.5, 4.5,      opacity=0.25,     color='yellow', )  # draw a rectangle (x1, x2, y1, y2) axes.rectangle(     -0.75, 0.35, 4.5, 8.5,      opacity=0.25,     color='magenta', )  # add tree to the axes  rtre.draw(axes=axes); r0r1r2r3r4r5r6r7r8r9r10r11r12r13r14r15r16r17r18r19-1.0-0.50.00.501020"},{"location":"highlights/#colored-rectangles-to-highlight-clades","title":"Colored rectangles to highlight clades\u00b6","text":"<p>The easiest way to add colored shapes to a plot is with the Toyplot <code>.rectangle</code> or <code>.fill()</code> functions of cartesian <code>axes</code> objects. For this you simply need to know the coordinates of the area that you wish to fill (See Coordinates). The example below draws two rectangles in the coordinate space and then adds a tree on top of these. You could make more complex polygon shapes using the <code>fill</code> function (see Toyplot docs). Remember you can use <code>axes.show=True</code> to see the axes coordinates if you need a reminder of how to set the x and y coordinates of the rectangles.</p>"},{"location":"infer-consensus/","title":"Consensus trees","text":"In\u00a0[\u00a0]: Copied! <pre>import toytree\n\ntrees = [toytree.rtree.unittree(8, seed=i) for i in range(6)]\nctree = toytree.infer.get_consensus_tree(trees, min_freq=0.5)\nc, a, m = ctree.draw(node_labels='support', node_sizes=12, tip_labels=True, scale_bar=True)\nc\n</pre> import toytree  trees = [toytree.rtree.unittree(8, seed=i) for i in range(6)] ctree = toytree.infer.get_consensus_tree(trees, min_freq=0.5) c, a, m = ctree.draw(node_labels='support', node_sizes=12, tip_labels=True, scale_bar=True) c"},{"location":"infer-consensus/#inference-consensus-trees","title":"Inference: Consensus Trees\u00b6","text":"<p>Build a majority-rule consensus tree from a set of trees that share the same tips, and visualize node supports.</p>"},{"location":"infer-neighbor-joining/","title":"Neighbor-joining","text":"In\u00a0[\u00a0]: Copied! <pre>import toytree\n\ntree = toytree.rtree.unittree(8, seed=321)\ndist = tree.distance.get_tip_distance_matrix()\nnj = toytree.infer.neighbor_joining_tree(dist)\n# optional: root the unrooted tree for display\nnj = nj.mod.root_on_minimal_ancestor_deviation()\nc, a, m = nj.draw(layout='r', tip_labels=True, scale_bar=True)\nc\n</pre> import toytree  tree = toytree.rtree.unittree(8, seed=321) dist = tree.distance.get_tip_distance_matrix() nj = toytree.infer.neighbor_joining_tree(dist) # optional: root the unrooted tree for display nj = nj.mod.root_on_minimal_ancestor_deviation() c, a, m = nj.draw(layout='r', tip_labels=True, scale_bar=True) c"},{"location":"infer-neighbor-joining/#inference-neighbor-joining","title":"Inference: Neighbor-Joining\u00b6","text":"<p>Neighbor-joining infers a tree from a distance matrix without assuming a molecular clock.</p>"},{"location":"infer-parsimony/","title":"Parsimony indices","text":"In\u00a0[\u00a0]: Copied! <pre>import toytree\n\ntree = toytree.rtree.unittree(12, seed=42)\ntraits = tree.pcm.simulate_discrete_data(nstates=3, tips_only=True, nreplicates=1, seed=7)\nci = toytree.infer.consistency_and_retention_indices(tree, traits.t0, npermutations=500, rng=7)\nprint(ci)\n\ntrait = traits.t0.to_dict()\ncolor_map = {0: '#4c78a8', 1: '#f58518', 2: '#54a24b'}\ntip_colors = [color_map[trait[name]] for name in tree.get_tip_labels()]\nc, a, m = tree.draw(layout='r', tip_labels=True, tip_labels_colors=tip_colors, scale_bar=True)\nc\n</pre> import toytree  tree = toytree.rtree.unittree(12, seed=42) traits = tree.pcm.simulate_discrete_data(nstates=3, tips_only=True, nreplicates=1, seed=7) ci = toytree.infer.consistency_and_retention_indices(tree, traits.t0, npermutations=500, rng=7) print(ci)  trait = traits.t0.to_dict() color_map = {0: '#4c78a8', 1: '#f58518', 2: '#54a24b'} tip_colors = [color_map[trait[name]] for name in tree.get_tip_labels()] c, a, m = tree.draw(layout='r', tip_labels=True, tip_labels_colors=tip_colors, scale_bar=True) c"},{"location":"infer-parsimony/#inference-parsimony-ci-ri","title":"Inference: Parsimony (CI / RI)\u00b6","text":"<p>Compute parsimony indices for a discrete trait and visualize the trait values on the tips.</p>"},{"location":"infer-upgma/","title":"UPGMA","text":"In\u00a0[\u00a0]: Copied! <pre>import toytree\n\ntree = toytree.rtree.unittree(8, seed=123)\ndist = tree.distance.get_tip_distance_matrix()\nupgma = toytree.infer.upgma_tree(dist)\nc, a, m = upgma.draw(layout='r', tip_labels=True, scale_bar=True)\nc\n</pre> import toytree  tree = toytree.rtree.unittree(8, seed=123) dist = tree.distance.get_tip_distance_matrix() upgma = toytree.infer.upgma_tree(dist) c, a, m = upgma.draw(layout='r', tip_labels=True, scale_bar=True) c"},{"location":"infer-upgma/#inference-upgma","title":"Inference: UPGMA\u00b6","text":"<p>UPGMA infers an ultrametric tree from a distance matrix. This example constructs a distance matrix from a random tree, then infers a UPGMA tree and draws it.</p>"},{"location":"installation/","title":"Installation","text":"<p><code>toytree</code> can be installed using pip or conda (or mamba), any of which will pull in all required dependencies. We also provide instructions below for installing from source (GitHub).</p>"},{"location":"installation/#conda-install-recommended","title":"Conda install (recommended)","text":"<pre><code>$ conda install toytree -c conda-forge\n</code></pre>"},{"location":"installation/#pip-install","title":"Pip install","text":"<pre><code>$ pip install toytree\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>Our goal is to maintain <code>toytree</code> as a minimalist library that does not require substantial dependencies outside of the standard Python scientific stack (i.e., numpy, scipy, and pandas). </p> <pre><code>- python&gt;=3.7\n- numpy\n- scipy\n- pandas\n- loguru\n- requests\n- toyplot\n- ghostscript  # to save PNGs\n</code></pre>"},{"location":"installation/#installing-development-versions","title":"Installing Development Versions","text":"<pre><code>$ git clone https://github.com/eaton-lab/toytree.git\n$ cd toytree\n$ conda install toytree -c conda-forge --only-deps\n$ pip install -e . --no-deps\n</code></pre>"},{"location":"installation/#building-the-documentation","title":"Building the documentation","text":"<pre><code>$ conda install mkdocs-material mkdocstrings-python mkdocs-jupyter -c conda-forge\n</code></pre>"},{"location":"make-ultrametric/","title":"make ultrametric","text":"In\u00a0[\u00a0]: Copied! <pre>import toytree\n\ntree = toytree.rtree.unittree(30, seed=42)\n\n# strict clock\nclock = tree.mod.edges_make_ultrametric_pl_clock()\nc1, a1, m1 = clock.draw(layout='r', tip_labels=False, scale_bar=True)\nc1\n</pre> import toytree  tree = toytree.rtree.unittree(30, seed=42)  # strict clock clock = tree.mod.edges_make_ultrametric_pl_clock() c1, a1, m1 = clock.draw(layout='r', tip_labels=False, scale_bar=True) c1  In\u00a0[\u00a0]: Copied! <pre># discrete rates\ndiscrete = tree.mod.edges_make_ultrametric_pl_discrete()\nc2, a2, m2 = discrete.draw(layout='r', tip_labels=False, scale_bar=True)\nc2\n</pre> # discrete rates discrete = tree.mod.edges_make_ultrametric_pl_discrete() c2, a2, m2 = discrete.draw(layout='r', tip_labels=False, scale_bar=True) c2  In\u00a0[\u00a0]: Copied! <pre># relaxed rates\nrelaxed = tree.mod.edges_make_ultrametric_pl_relaxed()\nc3, a3, m3 = relaxed.draw(layout='r', tip_labels=False, scale_bar=True)\nc3\n</pre> # relaxed rates relaxed = tree.mod.edges_make_ultrametric_pl_relaxed() c3, a3, m3 = relaxed.draw(layout='r', tip_labels=False, scale_bar=True) c3  In\u00a0[\u00a0]: Copied! <pre># Grid search for discrete ncategories and relaxed lam\nncategories_grid = [2, 3, 4, 5]\nlam_grid = [0.1, 0.5, 1.0, 2.0, 5.0]\n\nphiic_discrete = {}\nfor k in ncategories_grid:\n    fit = tree.mod.edges_make_ultrametric_pl_discrete(full=True, ncategories=k)\n    phiic_discrete[k] = fit['PHIIC']\n\nphiic_relaxed = {}\nfor lam in lam_grid:\n    fit = tree.mod.edges_make_ultrametric_pl_relaxed(full=True, lam=lam)\n    phiic_relaxed[lam] = fit['PHIIC']\n\nphiic_discrete, phiic_relaxed\n</pre> # Grid search for discrete ncategories and relaxed lam ncategories_grid = [2, 3, 4, 5] lam_grid = [0.1, 0.5, 1.0, 2.0, 5.0]  phiic_discrete = {} for k in ncategories_grid:     fit = tree.mod.edges_make_ultrametric_pl_discrete(full=True, ncategories=k)     phiic_discrete[k] = fit['PHIIC']  phiic_relaxed = {} for lam in lam_grid:     fit = tree.mod.edges_make_ultrametric_pl_relaxed(full=True, lam=lam)     phiic_relaxed[lam] = fit['PHIIC']  phiic_discrete, phiic_relaxed  <p>Use PHIIC to compare models fitted under different assumptions. Lower PHIIC indicates a better balance of fit and complexity.</p> <p>Discrete model (<code>edges_make_ultrametric_pl_discrete</code>) Choose <code>ncategories</code> by fitting several candidates (e.g., 2\u20135) and selecting the model with the lowest PHIIC.</p> <p>Relaxed model (<code>edges_make_ultrametric_pl_relaxed</code>) Choose the penalty strength <code>lam</code> (lambda) by fitting a grid of values and selecting the lowest PHIIC. Larger <code>lam</code> penalizes rate variation more strongly.</p> <p>Model choice Fit the clock, discrete, and relaxed models, then select the model with the lowest PHIIC as the best tradeoff between fit and parsimony.</p> In\u00a0[\u00a0]: Copied! <pre># PHIIC-based model selection\nclock_fit = tree.mod.edges_make_ultrametric_pl_clock(full=True)\ndiscrete_fit = tree.mod.edges_make_ultrametric_pl_discrete(full=True)\nrelaxed_fit = tree.mod.edges_make_ultrametric_pl_relaxed(full=True)\n\nphiic = {\n    'clock': clock_fit['PHIIC'],\n    'discrete': discrete_fit['PHIIC'],\n    'relaxed': relaxed_fit['PHIIC'],\n}\nphiic\n</pre> # PHIIC-based model selection clock_fit = tree.mod.edges_make_ultrametric_pl_clock(full=True) discrete_fit = tree.mod.edges_make_ultrametric_pl_discrete(full=True) relaxed_fit = tree.mod.edges_make_ultrametric_pl_relaxed(full=True)  phiic = {     'clock': clock_fit['PHIIC'],     'discrete': discrete_fit['PHIIC'],     'relaxed': relaxed_fit['PHIIC'], } phiic"},{"location":"make-ultrametric/#make-trees-ultrametric-penalized-likelihood","title":"Make Trees Ultrametric (Penalized Likelihood)\u00b6","text":"<p>This page summarizes the penalized likelihood approaches available in <code>toytree.mod</code> for adjusting edge lengths to make a tree ultrametric. These methods aim to balance model fit with penalties that discourage excessive rate variation.</p>"},{"location":"make-ultrametric/#clock-model-edges_make_ultrametric_pl_clock","title":"Clock model (<code>edges_make_ultrametric_pl_clock</code>)\u00b6","text":"<p>Assumes a strict molecular clock (single rate across all branches). This is the most constrained model and typically yields the smoothest ultrametric tree. Use this when you expect rate constancy or want the simplest correction.</p>"},{"location":"make-ultrametric/#discrete-rates-model-edges_make_ultrametric_pl_discrete","title":"Discrete rates model (<code>edges_make_ultrametric_pl_discrete</code>)\u00b6","text":"<p>Allows a small number of discrete rate categories across branches. This model accommodates heterogeneity while still limiting complexity by restricting the number of rates.</p>"},{"location":"make-ultrametric/#relaxed-rates-model-edges_make_ultrametric_pl_relaxed","title":"Relaxed rates model (<code>edges_make_ultrametric_pl_relaxed</code>)\u00b6","text":"<p>Allows branch-specific rates with a penalty that discourages abrupt rate changes. This is the most flexible option and is often used when rate variation is expected across the tree.</p>"},{"location":"make-ultrametric/#notes","title":"Notes\u00b6","text":"<p>All methods optimize edge lengths subject to a penalty term, so results depend on the chosen model and penalty settings. If you have calibration constraints, include them in the input parameters to guide the fit.</p>"},{"location":"make-ultrametric/#parameter-notes","title":"Parameter notes\u00b6","text":"<p>Most penalized likelihood functions accept optimization controls such as <code>max_iter</code>, <code>max_fun</code>, and <code>max_refine</code>. Increasing these can improve convergence or solution quality, but also increases runtime. Use higher values if the fit fails to converge or if you suspect local optima.</p> <p>Additional model-specific parameters:</p> <ul> <li><code>ncategories</code> (discrete model): number of rate categories. Larger values increase flexibility but also complexity.</li> <li><code>lam</code> (relaxed model): strength of the rate-variation penalty. Larger values impose stronger smoothing of rates across branches.</li> <li><code>calibrations</code>: constraints on node ages. Calibrations can strongly influence the inferred ultrametric tree.</li> </ul> <p>If convergence warnings appear, try increasing <code>max_iter</code> / <code>max_fun</code>, and consider adjusting <code>lam</code> or <code>ncategories</code>.</p>"},{"location":"make-ultrametric/#runnable-examples-30-tips","title":"Runnable examples (30 tips)\u00b6","text":""},{"location":"make-ultrametric/#model-selection","title":"Model selection\u00b6","text":"<p>Use PHIIC to compare model fit across clock, discrete, and relaxed penalized likelihood fits. Lower PHIIC indicates a better tradeoff between fit and complexity.</p>"},{"location":"mod-edges/","title":"edge/dist changes","text":"In\u00a0[3]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[4]: Copied! <pre># example tree for demonstrations\ntree = toytree.rtree.unittree(ntips=6, seed=123)\ntree.draw();\n</pre> # example tree for demonstrations tree = toytree.rtree.unittree(ntips=6, seed=123) tree.draw(); r0r1r2r3r4r5 In\u00a0[7]: Copied! <pre># module level API takes tree as the first arg\nrtree = toytree.mod.edges_extend_tips_to_align(tree)\n\n# object-level API knows the tree is the object to operate on \nrtree = tree.mod.edges_extend_tips_to_align()\n</pre> # module level API takes tree as the first arg rtree = toytree.mod.edges_extend_tips_to_align(tree)  # object-level API knows the tree is the object to operate on  rtree = tree.mod.edges_extend_tips_to_align() In\u00a0[98]: Copied! <pre>rtree = toytree.rtree.rtree(ntips=5)\nmod_tree = toytree.mod.edges_extend_tips_to_align(rtree,)\ntoytree.mtree([rtree, mod_tree]).draw(scale_bar=True);\n</pre> rtree = toytree.rtree.rtree(ntips=5) mod_tree = toytree.mod.edges_extend_tips_to_align(rtree,) toytree.mtree([rtree, mod_tree]).draw(scale_bar=True); r0r1r2r3r43210r0r1r2r3r43210 In\u00a0[102]: Copied! <pre>mod_tree = toytree.mod.edges_scale_to_root_height(tree, 10.)\ntoytree.mtree([tree, mod_tree]).draw(scale_bar=True);\n</pre> mod_tree = toytree.mod.edges_scale_to_root_height(tree, 10.) toytree.mtree([tree, mod_tree]).draw(scale_bar=True); r0r1r2r3r4r510.50r0r1r2r3r4r51050 In\u00a0[116]: Copied! <pre>mod_tree = toytree.mod.edges_set_node_heights(tree, {0: 0.1, -1: 2, \"r3\": 0.2})\ntoytree.mtree([tree, mod_tree]).draw(scale_bar=True, node_sizes=15, node_labels=\"idx\");\n</pre> mod_tree = toytree.mod.edges_set_node_heights(tree, {0: 0.1, -1: 2, \"r3\": 0.2}) toytree.mtree([tree, mod_tree]).draw(scale_bar=True, node_sizes=15, node_labels=\"idx\"); 678910r0r1r2r3r4r510.50678910r0r1r2r3r4r521.510.50 In\u00a0[118]: Copied! <pre>mod_tree1 = toytree.mod.edges_slider(tree, prop=0.5, seed=123)\nmod_tree2 = toytree.mod.edges_slider(tree, prop=0.5, seed=321)\ntoytree.mtree([tree, mod_tree1, mod_tree2]).draw(scale_bar=True, node_sizes=15, node_labels=\"idx\");\n</pre> mod_tree1 = toytree.mod.edges_slider(tree, prop=0.5, seed=123) mod_tree2 = toytree.mod.edges_slider(tree, prop=0.5, seed=321) toytree.mtree([tree, mod_tree1, mod_tree2]).draw(scale_bar=True, node_sizes=15, node_labels=\"idx\"); 678910r0r1r2r3r4r510.50678910r0r1r2r3r4r510.50678910r0r1r2r3r4r510.50 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"mod-edges/#modifying-tree-edges-with-mod","title":"Modifying tree edges with <code>mod</code>\u00b6","text":"<p>The submodule <code>toytree.mod</code> includes many options for efficiently modifying a tree. In this section we describe methods for modifying tree edges (dist values). While it is possible to accomplish this by editing attributes of the Node objects themselves, such as their <code>.dist</code>, this can be error-prone if you are not highly experienced. Instead, the we provide a suite of methods for this.</p>"},{"location":"mod-edges/#module-level-versus-object-level-apis","title":"Module-level versus Object-level APIs\u00b6","text":"<p>The methods in <code>toytree.mod</code> can also be called directly from ToyTree objects using the object-level API.</p>"},{"location":"mod-edges/#methods","title":"Methods\u00b6","text":""},{"location":"mod-edges/#edges_extend_tips_to_align","title":"edges_extend_tips_to_align\u00b6","text":"<p>Return a ToyTree with tips Node dists extended to align. Tip Node dists are extended to align with the Node that is farthest from the root (defined as height=0). This is a simple way to make a tree ultrametric.</p>"},{"location":"mod-edges/#edges_scale_to_root_height","title":"edges_scale_to_root_height\u00b6","text":"<p>Return ToyTree rescaled to a specific total tree height. Edge lengths (Node dist values) are all multiplied by a constant factor to make the root Node height align at the specified height. By default the tree is scaled to set the root crown height, but if the tree has a dist value assigned to the treenode it can alternatively be scaled to set the stem height using <code>include_stem=True</code>.</p>"},{"location":"mod-edges/#edges_set_node_heights","title":"edges_set_node_heights\u00b6","text":"<p>Return a ToyTree with one or more Node heights set explicitly. Enter a dictionary mapping node queries to heights. Nodes that are not included as keys will remain at there existing height, but their dist values may be changed to modify the heights of other Nodes, since height is an emergent property of the dist values of many connected Nodes. This same operation can be achieved using <code>set_node_data</code> to set node heights, but is explicitly defined as a separate function name to make it clear to users as an option for manipulating edge lengths.</p>"},{"location":"mod-edges/#edges_slider","title":"edges_slider\u00b6","text":"<p>Return ToyTree with node heights randomly shifted within bounds. Node heights are moved up or down uniformly between their parent and highest child node heights in 'levelorder' (from root to tips). Root and tip heights are fixed, only internal node heights change.</p>"},{"location":"mod-edges/#model-based-edge-scaling","title":"Model-based edge scaling\u00b6","text":"<p>IN DEVELOPMENT...</p>"},{"location":"mod-edges/#penalized-likelihood","title":"Penalized likelihood\u00b6","text":"<p>See also: Make trees ultrametric.</p>"},{"location":"mod-topology/","title":"topology changes","text":"In\u00a0[81]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[82]: Copied! <pre># example tree for demonstrations\ntree = toytree.rtree.unittree(ntips=6, seed=123)\ntree.draw();\n</pre> # example tree for demonstrations tree = toytree.rtree.unittree(ntips=6, seed=123) tree.draw(); r0r1r2r3r4r5 In\u00a0[10]: Copied! <pre># module level API takes tree as the first arg\nrtree = toytree.mod.root(tree, \"r4\")\n\n# object-level API knows the tree is the object to operate on \nrtree = tree.mod.root(\"r4\")\n</pre> # module level API takes tree as the first arg rtree = toytree.mod.root(tree, \"r4\")  # object-level API knows the tree is the object to operate on  rtree = tree.mod.root(\"r4\") In\u00a0[43]: Copied! <pre>mod_tree = toytree.mod.add_internal_node(tree, \"r2\", dist=0.1, name=\"X\")\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"name\");\n</pre> mod_tree = toytree.mod.add_internal_node(tree, \"r2\", dist=0.1, name=\"X\") toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"name\"); r0r1r2r3r4r5Xr0r1r3r2r4r5 In\u00a0[59]: Copied! <pre>mod_tree = toytree.mod.add_child_node(tree, 6, name=\"X\")\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\");\n</pre> mod_tree = toytree.mod.add_child_node(tree, 6, name=\"X\") toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\"); 678910r0r1r2r3r4r57891011r0r1Xr2r3r4r5 In\u00a0[60]: Copied! <pre>mod_tree = toytree.mod.add_sister_node(tree, \"r3\", name=\"X\")\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\");\n</pre> mod_tree = toytree.mod.add_sister_node(tree, \"r3\", name=\"X\") toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\"); 678910r0r1r2r3r4r57891011r0r1r2r3Xr4r5 In\u00a0[83]: Copied! <pre>mod_tree = toytree.mod.add_internal_node_and_child(tree, \"r3\", name=\"C\", parent_name=\"P\")\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"name\");\n</pre> mod_tree = toytree.mod.add_internal_node_and_child(tree, \"r3\", name=\"C\", parent_name=\"P\") toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"name\"); r0r1r2r3r4r5Pr0r1r2r3Cr4r5 In\u00a0[85]: Copied! <pre># get a subtree from this tree or a different one\nsubtree = tree.mod.extract_subtree(\"r0\", \"r1\", \"r2\", \"r3\")\n# insert this subtree at a selected node in the this tree\nmod_tree = toytree.mod.add_internal_node_and_subtree(tree, \"r4\", subtree=subtree, subtree_rescale=True, parent_name=\"P\")\n# draw\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"name\", height=300);\n</pre> # get a subtree from this tree or a different one subtree = tree.mod.extract_subtree(\"r0\", \"r1\", \"r2\", \"r3\") # insert this subtree at a selected node in the this tree mod_tree = toytree.mod.add_internal_node_and_subtree(tree, \"r4\", subtree=subtree, subtree_rescale=True, parent_name=\"P\") # draw toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"name\", height=300); r0r1r2r3r4r5Pr0r1r2r3r5r4r0r1r2r3 In\u00a0[86]: Copied! <pre>mod_tree = toytree.mod.remove_nodes(tree, \"r1\", \"r2\", \"r3\", )\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\");\n</pre> mod_tree = toytree.mod.remove_nodes(tree, \"r1\", \"r2\", \"r3\", ) toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\"); 678910r0r1r2r3r4r54567r0r4r5 In\u00a0[96]: Copied! <pre># get a tree with a unary node\nmod_tree1 = toytree.mod.add_internal_node(tree, \"r2\", name=\"X\")\n# remove the unary node\nmod_tree2 = toytree.mod.remove_unary_nodes(mod_tree1)\ntoytree.mtree([mod_tree1, mod_tree2]).draw(node_sizes=15, node_labels=\"idx\");\n</pre> # get a tree with a unary node mod_tree1 = toytree.mod.add_internal_node(tree, \"r2\", name=\"X\") # remove the unary node mod_tree2 = toytree.mod.remove_unary_nodes(mod_tree1) toytree.mtree([mod_tree1, mod_tree2]).draw(node_sizes=15, node_labels=\"idx\"); 67891011r0r1r3r2r4r5678910r0r1r3r2r4r5 In\u00a0[179]: Copied! <pre># create a mod tree with two sister nodes labeled 'r1'\nmod_tree1 = tree.mod.add_internal_node_and_child(\"r1\", name=\"r1\")\n# merge nodes with identical names\nmod_tree2 = toytree.mod.merge_nodes(mod_tree1, merge_method=\"name\", )\ntoytree.mtree([mod_tree1, mod_tree2]).draw(node_sizes=15, node_labels=\"idx\");\n</pre> # create a mod tree with two sister nodes labeled 'r1' mod_tree1 = tree.mod.add_internal_node_and_child(\"r1\", name=\"r1\") # merge nodes with identical names mod_tree2 = toytree.mod.merge_nodes(mod_tree1, merge_method=\"name\", ) toytree.mtree([mod_tree1, mod_tree2]).draw(node_sizes=15, node_labels=\"idx\"); 678910r0r1r1r2r3r45678r0r1r2r3r4 In\u00a0[98]: Copied! <pre>mod_tree = toytree.mod.collapse_nodes(tree, 7)\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\");\n</pre> mod_tree = toytree.mod.collapse_nodes(tree, 7) toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\"); 678910r0r1r2r3r4r56789r0r1r2r3r4r5 In\u00a0[103]: Copied! <pre>mod_tree = toytree.mod.rotate_node(tree, 8)\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\");\n</pre> mod_tree = toytree.mod.rotate_node(tree, 8) toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\"); 678910r0r1r2r3r4r5678910r2r3r0r1r4r5 In\u00a0[166]: Copied! <pre>mod_tree = toytree.mod.prune(tree, \"r0\", \"r1\", \"r2\")\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\", scale_bar=True);\n</pre> mod_tree = toytree.mod.prune(tree, \"r0\", \"r1\", \"r2\") toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\", scale_bar=True); 678910r0r1r2r3r4r510.5034r0r1r20.60.40.20 In\u00a0[171]: Copied! <pre>mod_tree = toytree.mod.drop_tips(tree, \"r0\", \"r1\", \"r2\")\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\", scale_bar=True);\n</pre> mod_tree = toytree.mod.drop_tips(tree, \"r0\", \"r1\", \"r2\") toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\", scale_bar=True); 678910r0r1r2r3r4r510.5034r4r5r310.50 In\u00a0[175]: Copied! <pre>mod_tree = toytree.mod.extract_subtree(tree, \"r0\", \"r3\")\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\", scale_bar=True);\n</pre> mod_tree = toytree.mod.extract_subtree(tree, \"r0\", \"r3\") toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\", scale_bar=True); 678910r0r1r2r3r4r510.50456r0r1r2r30.60.40.20 In\u00a0[170]: Copied! <pre>sub1, sub2 = toytree.mod.bisect(tree, 6)\ntoytree.mtree([tree, sub1, sub2]).draw(node_sizes=15, node_labels=\"idx\", scale_bar=True);\n</pre> sub1, sub2 = toytree.mod.bisect(tree, 6) toytree.mtree([tree, sub1, sub2]).draw(node_sizes=15, node_labels=\"idx\", scale_bar=True); 678910r0r1r2r3r4r510.502r0r10.30.20.10456r4r5r2r310.50 In\u00a0[157]: Copied! <pre>mod_tree1 = toytree.mod.collapse_nodes(tree, 7, 6)\nmod_tree2 = toytree.mod.resolve_polytomies(mod_tree1, dist=0.1)\ntoytree.mtree([mod_tree1, mod_tree2]).draw(node_sizes=15, node_labels=\"idx\");\n</pre> mod_tree1 = toytree.mod.collapse_nodes(tree, 7, 6) mod_tree2 = toytree.mod.resolve_polytomies(mod_tree1, dist=0.1) toytree.mtree([mod_tree1, mod_tree2]).draw(node_sizes=15, node_labels=\"idx\"); 678r0r1r2r3r4r5678910r0r1r2r3r4r5 In\u00a0[105]: Copied! <pre>mod_tree = toytree.mod.ladderize(tree, direction=False)\ntoytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\");\n</pre> mod_tree = toytree.mod.ladderize(tree, direction=False) toytree.mtree([tree, mod_tree]).draw(node_sizes=15, node_labels=\"idx\"); 678910r0r1r2r3r4r5678910r4r5r0r1r2r3 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"mod-topology/#modifying-tree-topologies-with-mod","title":"Modifying tree topologies with <code>mod</code>\u00b6","text":"<p>The submodule <code>toytree.mod</code> includes many options for efficiently modifying a tree. In this section we describe methods for modifying the topology -- i.e., the relationships among nodes. While it is possible to accomplish this by editing attributes of the Node objects themselves, such as <code>.up</code> and <code>.children</code>, this can be error-prone if you are not highly experienced. Instead, the we provide a suite of methods for common topology manipulations that are intended to work efficiently and to retain other information such as node and edge features correctly. You can find these methods listed in the table of contents to the right. Below we describe examples of each of these methods.</p>"},{"location":"mod-topology/#module-level-versus-object-level-apis","title":"Module-level versus Object-level APIs\u00b6","text":"<p>The methods in <code>toytree.mod</code> can also be called directly from ToyTree objects using the object-level API.</p>"},{"location":"mod-topology/#node-level-modifications","title":"Node-level modifications\u00b6","text":""},{"location":"mod-topology/#add_internal_node","title":"add_internal_node\u00b6","text":"<p>Splits a branch to insert a new internal Node.</p>"},{"location":"mod-topology/#add_child_node","title":"add_child_node\u00b6","text":"<p>This function selects an existing Node to act as the parent, and inserts a new Node as a child of that parent. The new child's name and dist can be set. If no dist value is entered then the child's dist is set to match that of its new sister Nodes, or 1.0. Unless a unary internal node already exists (e.g., you call <code>add_internal_node</code>) adding an child to an existing internal node will typically create a polytomy. Thus this method may often be paired with <code>add_child_node</code>.</p>"},{"location":"mod-topology/#add_sister_node","title":"add_sister_node\u00b6","text":"<p>This function selects an existing Node to act as the sister, and inserts a new Node as a child of the same parent. The new sister Node's name and dist can be set. If no dist value is entered then the its dist is set to match the max dist of its sister Nodes or 1. This function is equivalent to :func:<code>.add_child_node</code> but the query is used to select a sister rather than a parent.</p>"},{"location":"mod-topology/#add_internal_node_and_child","title":"add_internal_node_and_child\u00b6","text":"<p>Splits a branch spanning from query node (A) to its parent (B) to create a new internal Node (C) and child Node (D). The new parent and child Nodes can be given names and dist values. If no value is entered for <code>parent_dist</code> then the parent Node is inserted at the midpoint of the edge. If a parent_dist value is entered then it must fit within the length of the query Node's dist or an error is raised. The new child Node dist is not constrained. If no value is entered then it will be automatically set to match the dist of its sister Node.</p>"},{"location":"mod-topology/#add_internal_node_and_subtree","title":"add_internal_node_and_subtree\u00b6","text":"<p>Add a subtree by splitting an edge to create a new parent Node and inserting the subtree as a child (i.e., tree-grafting). By default, if left as None, the subtree stem dist will be set to half the distance to the farthest leaf, and the subtree will be scaled to fill the other half distance so that it aligns as the farthest tip node distance.</p>"},{"location":"mod-topology/#remove_nodes","title":"remove_nodes\u00b6","text":"<p>If multiple Nodes are entered they are removed in a postorder traversal of the tree. Nodes can be selected using Node Queries.</p>"},{"location":"mod-topology/#remove_unary_nodes","title":"remove_unary_nodes\u00b6","text":"<p>Some operations can leave behind \"unary nodes\" which only have a single child Node instead of the typical pattern in a tree of having 2 or more children. You could find and remove these nodes using <code>remove_nodes</code>, but another option to use <code>remove_unary_nodes</code> which will search for and remove these nodes for you.</p>"},{"location":"mod-topology/#merge_nodes","title":"merge_nodes\u00b6","text":"<p>The method <code>merge_nodes</code> can be used to remove nodes from a tree based on a Callable function that return True or False. The specified \"merge_method\" function will be performed at each Node in the tree, and if it returns True the node will be collapsed. A second function \"selection_method\" can be used to select which node will be retained. The default is to select the Node with the lowest idx (using the min function).</p>"},{"location":"mod-topology/#collapse_nodes","title":"collapse_nodes\u00b6","text":"<p>Nodes can be entered as Node instances, Node names strings, or Node int idx labels, and/or Nodes can be selected by minimum dist or support values. Selected Nodes are collapsed into multi-furcating polytomies. For example, set min_support=50 to collapse all nodes with support &lt; 50, and/or select Node idx 10 to collapse Node 10.</p>"},{"location":"mod-topology/#rotate_nodes","title":"rotate_nodes\u00b6","text":"<p>Return ToyTree with one Node rotated (children order reversed). Rotates only one Node per call. Internal Nodes can be selected by idx label, or by entering multiple tip Node names from which the MRCA will be selected and rotated.</p>"},{"location":"mod-topology/#subtree-level-modification","title":"Subtree-level modification\u00b6","text":""},{"location":"mod-topology/#prune","title":"prune\u00b6","text":"<p>The <code>prune()</code> method returns a tree with a subset of queried Nodes along with the minimal spanning edges required to connect the Nodes. Nodes can be queried as individual arguments or as a set of indices, e.g. prune([0,1,2]). When called on a rooted tree, the user can require the originial root to be retained in the pruned tree using <code>require_root=True</code>. By default, this is False and the lowest MRCA connecting the queried Nodes will instead be kept as the new root. When internal Nodes are discarded by <code>prune</code> their distances will be merged into the distance of the queried Node such that the original distance between the root and the queried Node remains the same. If <code>preserve_dists=False</code>, then only the original distances assigned to the queried Nodes are retained.</p>"},{"location":"mod-topology/#drop_tips","title":"drop_tips\u00b6","text":"<p>Return a ToyTree with some tip Nodes removed. The ToyTree with the selected tip Nodes (and any remaining internal nodes without children) are removed while retaining the original edge lengths between remaining nodes. This is effectively the inverse of <code>prune</code>. Tip names can be selected using a Query method of Node instances, Node names, or Node idx int labels. Only selected tip Nodes affect the result.</p>"},{"location":"mod-topology/#extract_subtree","title":"extract_subtree\u00b6","text":"<p>Return a subtree/clade extracted from a larger tree as a ToyTree. It will find the MRCA of the queried nodes and return a tree representing this subclade.</p>"},{"location":"mod-topology/#bisect","title":"bisect\u00b6","text":"<p>The <code>bisect()</code> method returns a tree bisected into two subtrees on a selected edge. This edge is given by the edge above a queried Node. When used on a rooted tree, querying the TreeNode returns a subtree for each child as its own TreeNode with its original distance value. When used on an unrooted tree, the TreeNode cannot be queried. When any other Node is queried, it will split the edge above it to create two subtrees with the queried Node bing a TreeNode of one new subtree. Including the argument <code>reroot=True</code> will cause the Node above the query to become the new TreeNode in its subtree, otherwise the original TreeNode will be retained.</p>"},{"location":"mod-topology/#tree-level-modification","title":"Tree-level modification\u00b6","text":""},{"location":"mod-topology/#resolve_polytomies","title":"resolve_polytomies\u00b6","text":"<p><code>resolve_polytomies()</code> can be used to randomly resolve polytomies in a tree. It accepts options to set defaults dist and support values on resolved nodes, and can accept a random seed for reproducible results.</p>"},{"location":"mod-topology/#ladderize","title":"ladderize\u00b6","text":"<p><code>ladderize()</code> formats a tree such that a Node's right/lower child always has more descendants than its left/upper child. The user can also choose to order it in reverse order such that the left/upper child has more descendants by using the argument <code>direction=True</code>.</p>"},{"location":"mod-topology/#rootingunrooting","title":"Rooting/Unrooting\u00b6","text":"<p>Several methods are available for rooting trees. Please see the separate rooting trees documentation page. See also: Rooting trees for rooting methods and options.</p>"},{"location":"multitree/","title":"MultiTree","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre>multinewick = \"\"\"\\\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((a:1,d:1):1,(b:1,e:1):1):1,c:3);\n(((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5);\n(((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3);\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4);\n(((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3);\n(((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3);\n\"\"\"\n</pre> multinewick = \"\"\"\\ (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((a:1,d:1):1,(b:1,e:1):1):1,c:3); (((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5); (((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3); (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4); (((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3); (((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3); \"\"\" In\u00a0[3]: Copied! <pre># create an mtree from a string, list of strings, url, or file.\nmtree1 = toytree.mtree(multinewick)\nmtree1\n</pre> # create an mtree from a string, list of strings, url, or file. mtree1 = toytree.mtree(multinewick) mtree1 Out[3]: <pre>&lt;toytree.MultiTree ntrees=8&gt;</pre> In\u00a0[4]: Copied! <pre># generate 50 random coalescent trees each with 6 tips\ncoaltrees = [toytree.rtree.coaltree(k=6) for i in range(50)]\n</pre> # generate 50 random coalescent trees each with 6 tips coaltrees = [toytree.rtree.coaltree(k=6) for i in range(50)] In\u00a0[5]: Copied! <pre># create a MultiTree from a list of ToyTrees\nmtree2 = toytree.mtree(coaltrees)\nmtree2\n</pre> # create a MultiTree from a list of ToyTrees mtree2 = toytree.mtree(coaltrees) mtree2 Out[5]: <pre>&lt;toytree.MultiTree ntrees=50&gt;</pre> In\u00a0[6]: Copied! <pre># get first tree\nmtree1[0]\n</pre> # get first tree mtree1[0] Out[6]: <pre>&lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;</pre> In\u00a0[7]: Copied! <pre># get all trees\nmtree1[:]\n</pre> # get all trees mtree1[:] Out[7]: <pre>[&lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab9270&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab8b20&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab8550&gt;,\n &lt;toytree.ToyTree at 0x7f03c5abb7f0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5abbbe0&gt;,\n &lt;toytree.ToyTree at 0x7f03c58ec190&gt;]</pre> In\u00a0[8]: Copied! <pre># slice the first three trees\nmtree1[:3]\n</pre> # slice the first three trees mtree1[:3] Out[8]: <pre>[&lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab9270&gt;]</pre> In\u00a0[9]: Copied! <pre># iterate over ToyTrees in a MultiTree\nfor tree in mtree1:\n    print(tree)\n</pre> # iterate over ToyTrees in a MultiTree for tree in mtree1:     print(tree) <pre>&lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;\n&lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;\n&lt;toytree.ToyTree at 0x7f03c5ab9270&gt;\n&lt;toytree.ToyTree at 0x7f03c5ab8b20&gt;\n&lt;toytree.ToyTree at 0x7f03c5ab8550&gt;\n&lt;toytree.ToyTree at 0x7f03c5abb7f0&gt;\n&lt;toytree.ToyTree at 0x7f03c5abbbe0&gt;\n&lt;toytree.ToyTree at 0x7f03c58ec190&gt;\n</pre> In\u00a0[10]: Copied! <pre># re-arrange trees in the treelist to send the first to be last\nmtree1.treelist = mtree1.treelist[1:] + [mtree1.treelist[0]]\nmtree1[:]\n</pre> # re-arrange trees in the treelist to send the first to be last mtree1.treelist = mtree1.treelist[1:] + [mtree1.treelist[0]] mtree1[:] Out[10]: <pre>[&lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab9270&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab8b20&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab8550&gt;,\n &lt;toytree.ToyTree at 0x7f03c5abb7f0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5abbbe0&gt;,\n &lt;toytree.ToyTree at 0x7f03c58ec190&gt;,\n &lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;]</pre> In\u00a0[11]: Copied! <pre>mtree1.ntrees\n</pre> mtree1.ntrees Out[11]: <pre>8</pre> In\u00a0[12]: Copied! <pre>mtree1.all_tree_tip_labels_same()\n</pre> mtree1.all_tree_tip_labels_same() Out[12]: <pre>True</pre> In\u00a0[13]: Copied! <pre>mtree1.all_tree_topologies_same()\n</pre> mtree1.all_tree_topologies_same() Out[13]: <pre>False</pre> In\u00a0[14]: Copied! <pre>mtree1.all_tree_tips_aligned()\n</pre> mtree1.all_tree_tips_aligned() Out[14]: <pre>False</pre> In\u00a0[15]: Copied! <pre># get a consensus tree \nctree = mtree1.get_consensus_tree()\n\n# plot the tree showing 'support' values\nctree.draw(\n    ts='r', layout=\"unrooted\", width=350, height=350,\n    node_labels=\"support\", node_sizes=14, node_as_edge_data=True);\n</pre> # get a consensus tree  ctree = mtree1.get_consensus_tree()  # plot the tree showing 'support' values ctree.draw(     ts='r', layout=\"unrooted\", width=350, height=350,     node_labels=\"support\", node_sizes=14, node_as_edge_data=True); 0.750.75abdec In\u00a0[16]: Copied! <pre># get (tree, count) for each unique topology in the MultiTree\nmtree1.get_unique_topologies()\n</pre> # get (tree, count) for each unique topology in the MultiTree mtree1.get_unique_topologies() Out[16]: <pre>[[&lt;toytree.ToyTree at 0x7f03c5ab9270&gt;, 6],\n [&lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;, 1],\n [&lt;toytree.ToyTree at 0x7f03c58ec190&gt;, 1]]</pre> In\u00a0[19]: Copied! <pre># draw a 2x4 grid of trees with 30px margins between them\nmtree1.draw(ts='o', shape=(2, 4), width=600, height=300, margin=25, fixed_order=['c', 'b', 'e', 'a', 'd']);\n</pre> # draw a 2x4 grid of trees with 30px margins between them mtree1.draw(ts='o', shape=(2, 4), width=600, height=300, margin=25, fixed_order=['c', 'b', 'e', 'a', 'd']); adbecabdecabdecabdecbadecabdecbdaecabdec In\u00a0[27]: Copied! <pre># draw a cloud tree\nmtree1.draw_cloud_tree(\n    scale_bar=True,\n    edge_style={\n        \"stroke-opacity\": 0.1,\n        \"stroke-width\": 3,\n    },\n);\n</pre> # draw a cloud tree mtree1.draw_cloud_tree(     scale_bar=True,     edge_style={         \"stroke-opacity\": 0.1,         \"stroke-width\": 3,     }, ); adbec3210"},{"location":"multitree/#multitree","title":"MultiTree\u00b6","text":"<p>The <code>toytree.MultiTree</code> class object is used to represent a collection of <code>ToyTree</code> objects and includes attributes and methods for describing this set or performing operations on it. Common examples of tree sets include bootstrap replicate samples or posterior distributions of sampled trees; common operations on sets of trees include consensus tree inference, computing discordance or distance statistics, and plotting tree grids or cloud trees.</p>"},{"location":"multitree/#generating-multitrees","title":"Generating MultiTrees\u00b6","text":"<p>MultiTree objects can be generated from a list of Toytrees or newick strings, or by parsing a file, url, or string of text that includes newick trees separated by newlines. The convenience function <code>toytree.mtree()</code> can be used to parse multitree input data similar to how the function <code>toytree.tree</code> is used to parse individual trees, and supports the same file formats.</p>"},{"location":"multitree/#from-tree-data","title":"From tree data\u00b6","text":"<p>Below is an example multi-newick string representing multiple trees as newick strings separated by newlines. You can create a MultiTree from this input data, entered as a string or filepath, by passing it to the <code>toytree.mtree()</code> convenience parsing function. Each tree will be parsed individually and stored as a list of <code>ToyTree</code> objects contained within a returned <code>MultiTree</code> object.</p>"},{"location":"multitree/#from-a-collection-of-trees","title":"From a collection of trees\u00b6","text":"<p>Similarly, you can create a <code>MultiTree</code> by providing a collection of <code>ToyTree</code> objects to the <code>toytree.mtree</code> function. Here we generate a list of 50 random coalescent trees and pass the list as input to create a new <code>MultiTree</code>.</p>"},{"location":"multitree/#indexable-and-iterable","title":"Indexable and Iterable\u00b6","text":"<p>One or more trees can be indexed or sliced from a <code>MultiTree</code>, and sequential trees can be accessed through iteration. The trees themselves are stored in the <code>.treelist</code> attribute of the <code>MultiTree</code> object as a list. This can be modified to remove, add, or reorder the trees. Several example operations are shown below for accessing one or more trees.</p>"},{"location":"multitree/#attributes-and-types-of-tree-sets","title":"Attributes and types of tree sets\u00b6","text":"<p>Most of the time <code>MultiTree</code> objects are used to hold a collection of trees that all share the same tip labels, such as a collection of bootstrap replicates. But, in other cases, a <code>MultiTree</code> could hold a collection of unrelated trees, in which case some of the built-in functions for comparing trees (such as consensus tree inference) will raise an error, but it still provides a useful container for drawing trees. These methods will raise a ToyTreeError when attempted if the tree set is a mixed collection of trees. The  <code>MultiTree</code> class contains several functions to quickly check attributes of the tree set to examine the number of trees, whether they share the same tip names, and whether the trees are rooted or ultrametric.</p>"},{"location":"multitree/#consensus-trees","title":"Consensus trees\u00b6","text":"<p>A majority-rule consensus tree is a tree that represents the most common non-conflicting splits among a set of input trees. In <code>toytree</code> this can be inferred from a <code>MultiTree</code> object using the <code>.get_consensus_tree</code>, which returns a <code>ToyTree</code> with the consensus topology on which several types of statistics have been stored to nodes. This can be useful in several contexts, but one of the simplest is to find the most common order of tip names among a set of trees, so that when you make a <code>MultiTree</code> plot you can order tips in the same way to more easily visualize variation among trees. There are many options and uses for consensus trees, check out the Consensus Trees documentation section for more details.</p> <p>In the example below we get a consensus tree from the <code>mtree1</code> multitree object which contains 8 trees. The support values on this returned tree represent the proportion of trees in the input set that contain each clade in the consensus tree. By default, the returned tree is unrooted, since the input trees may vary in their rooting. Here the trees exhibit variation in the relationships among <code>(a,b,d,e)</code> with <code>(a,b)</code> and <code>(d,e)</code> each occurring in 75% of trees.</p>"},{"location":"multitree/#unique-trees","title":"Unique trees\u00b6","text":"<p>Given a set of trees it is useful to be able to pull out just the unique topologies from the set. The function <code>get_unique_topologies()</code> returns a list of <code>(tree, int)</code> tuples from a <code>MultiTree</code> with each unique topology paired with its number of occurrences in the set. Note, this condenses all trees with the same topology into a single representative, using the first occurrence as the returned tree, thus branch length variation is not retained. See the <code>toytree.distance</code> subpackage for many additional methods for comparing trees and computing differences/distances between them.</p>"},{"location":"multitree/#drawing-with-multitrees","title":"Drawing with MultiTrees\u00b6","text":"<p>There are two main ways to draw groups of trees from <code>MultiTree</code> objects. The first is simply called <code>.draw()</code> and is used to plot multiple trees onto a shared canvas arranged into a grid. These trees can be arranged each on their own axes, or on shared axes to better compare scales. The second method is <code>.draw_cloud_tree</code>, which plots a set of trees over top of one another, usually at low opacity, as a way of examining discordance and variation among a set of trees. These are sometimes called cloud trees, densitrees, or other similar names. A simple example of each is shown below.</p>"},{"location":"multitree/#grid-tree-drawings","title":"Grid tree drawings\u00b6","text":"<p>The <code>.draw()</code> function of a <code>MultiTree</code> returns multiple tree drawings layed out on a grid. The shape of the grid, and which trees from the tree set are drawn, can be set with the <code>shape</code> and <code>idxs</code> arguments. This also accepts all of the standard drawing arguments that can be used when drawing individual trees. See Drawing Tree Grids.</p>"},{"location":"multitree/#cloud-tree-drawings","title":"Cloud tree drawings\u00b6","text":"<p>It is sometimes even more informative to plot a number of trees on top of each other to visualize their discordance. These are sometimes called \u201cdensitree\u201d plots, or here, \u201ccloud tree plots\u201d. See the documentation section on Drawing Cloud Trees for more details and examples.</p>"},{"location":"node-distance/","title":"node distances","text":"In\u00a0[1]: Copied! <pre>import toytree\n\n# a tree used in examples\ntree = toytree.rtree.unittree(ntips=12, seed=123)\ntree.draw(ts='s');\n</pre> import toytree  # a tree used in examples tree = toytree.rtree.unittree(ntips=12, seed=123) tree.draw(ts='s'); 012345678910111213141516171819202122r0r1r2r3r4r5r6r7r8r9r10r11 In\u00a0[2]: Copied! <pre># get all nodes between node 0 and 15\ntree.distance.get_node_path(0, 15)\n</pre> # get all nodes between node 0 and 15 tree.distance.get_node_path(0, 15) Out[2]: <pre>(&lt;Node(idx=0, name='r0')&gt;,\n &lt;Node(idx=13)&gt;,\n &lt;Node(idx=17)&gt;,\n &lt;Node(idx=16)&gt;,\n &lt;Node(idx=15)&gt;)</pre> In\u00a0[3]: Copied! <pre>list(tree.distance.iter_node_path(0, 15))\n</pre> list(tree.distance.iter_node_path(0, 15)) Out[3]: <pre>[&lt;Node(idx=0, name='r0')&gt;,\n &lt;Node(idx=13)&gt;,\n &lt;Node(idx=17)&gt;,\n &lt;Node(idx=16)&gt;,\n &lt;Node(idx=15)&gt;]</pre> In\u00a0[4]: Copied! <pre>tree.distance.get_farthest_node(\"r0\")\n</pre> tree.distance.get_farthest_node(\"r0\") Out[4]: <pre>&lt;Node(idx=9, name='r9')&gt;</pre> In\u00a0[5]: Copied! <pre>tree.distance.get_farthest_node_distance(15)\n</pre> tree.distance.get_farthest_node_distance(15) Out[5]: <pre>1.6666666666666665</pre> In\u00a0[6]: Copied! <pre>tree.distance.get_descendant_dists(15)\n</pre> tree.distance.get_descendant_dists(15) Out[6]: <pre>{&lt;Node(idx=15)&gt;: 0,\n &lt;Node(idx=3, name='r3')&gt;: 0.3333333333333333,\n &lt;Node(idx=14)&gt;: 0.16666666666666666,\n &lt;Node(idx=4, name='r4')&gt;: 0.3333333333333333,\n &lt;Node(idx=5, name='r5')&gt;: 0.3333333333333333}</pre> In\u00a0[7]: Copied! <pre>list(tree.distance.iter_descendant_dists(15))\n</pre> list(tree.distance.iter_descendant_dists(15)) Out[7]: <pre>[(&lt;Node(idx=15)&gt;, 0),\n (&lt;Node(idx=3, name='r3')&gt;, 0.3333333333333333),\n (&lt;Node(idx=14)&gt;, 0.16666666666666666),\n (&lt;Node(idx=4, name='r4')&gt;, 0.3333333333333333),\n (&lt;Node(idx=5, name='r5')&gt;, 0.3333333333333333)]</pre> In\u00a0[8]: Copied! <pre>tree.distance.get_node_distance_matrix(df=True)\n</pre> tree.distance.get_node_distance_matrix(df=True) Out[8]: r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 ... 13 14 15 16 17 18 19 20 21 22 r0 0.000000 1.000000 1.000000 1.333333 1.333333 1.333333 1.333333 1.666667 1.666667 2.000000 ... 0.500000 1.166667 1.000000 0.833333 0.666667 1.000000 0.833333 1.333333 1.166667 1.000000 r1 1.000000 0.000000 0.666667 1.333333 1.333333 1.333333 1.333333 1.666667 1.666667 2.000000 ... 0.500000 1.166667 1.000000 0.833333 0.666667 1.000000 0.833333 1.333333 1.166667 1.000000 r2 1.000000 0.666667 0.000000 1.333333 1.333333 1.333333 1.333333 1.666667 1.666667 2.000000 ... 0.500000 1.166667 1.000000 0.833333 0.666667 1.000000 0.833333 1.333333 1.166667 1.000000 r3 1.333333 1.333333 1.333333 0.000000 0.666667 0.666667 1.000000 1.666667 1.666667 2.000000 ... 0.833333 0.500000 0.333333 0.500000 0.666667 1.000000 0.833333 1.333333 1.166667 1.000000 r4 1.333333 1.333333 1.333333 0.666667 0.000000 0.333333 1.000000 1.666667 1.666667 2.000000 ... 0.833333 0.166667 0.333333 0.500000 0.666667 1.000000 0.833333 1.333333 1.166667 1.000000 r5 1.333333 1.333333 1.333333 0.666667 0.333333 0.000000 1.000000 1.666667 1.666667 2.000000 ... 0.833333 0.166667 0.333333 0.500000 0.666667 1.000000 0.833333 1.333333 1.166667 1.000000 r6 1.333333 1.333333 1.333333 1.000000 1.000000 1.000000 0.000000 1.666667 1.666667 2.000000 ... 0.833333 0.833333 0.666667 0.500000 0.666667 1.000000 0.833333 1.333333 1.166667 1.000000 r7 1.666667 1.666667 1.666667 1.666667 1.666667 1.666667 1.666667 0.000000 1.333333 2.000000 ... 1.166667 1.500000 1.333333 1.166667 1.000000 0.666667 0.833333 1.333333 1.166667 1.000000 r8 1.666667 1.666667 1.666667 1.666667 1.666667 1.666667 1.666667 1.333333 0.000000 2.000000 ... 1.166667 1.500000 1.333333 1.166667 1.000000 0.666667 0.833333 1.333333 1.166667 1.000000 r9 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 0.000000 ... 1.500000 1.833333 1.666667 1.500000 1.333333 1.333333 1.166667 0.666667 0.833333 1.000000 r10 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 1.333333 ... 1.500000 1.833333 1.666667 1.500000 1.333333 1.333333 1.166667 0.666667 0.833333 1.000000 r11 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 1.666667 ... 1.500000 1.833333 1.666667 1.500000 1.333333 1.333333 1.166667 1.000000 0.833333 1.000000 12 0.666667 0.333333 0.333333 1.000000 1.000000 1.000000 1.000000 1.333333 1.333333 1.666667 ... 0.166667 0.833333 0.666667 0.500000 0.333333 0.666667 0.500000 1.000000 0.833333 0.666667 13 0.500000 0.500000 0.500000 0.833333 0.833333 0.833333 0.833333 1.166667 1.166667 1.500000 ... 0.000000 0.666667 0.500000 0.333333 0.166667 0.500000 0.333333 0.833333 0.666667 0.500000 14 1.166667 1.166667 1.166667 0.500000 0.166667 0.166667 0.833333 1.500000 1.500000 1.833333 ... 0.666667 0.000000 0.166667 0.333333 0.500000 0.833333 0.666667 1.166667 1.000000 0.833333 15 1.000000 1.000000 1.000000 0.333333 0.333333 0.333333 0.666667 1.333333 1.333333 1.666667 ... 0.500000 0.166667 0.000000 0.166667 0.333333 0.666667 0.500000 1.000000 0.833333 0.666667 16 0.833333 0.833333 0.833333 0.500000 0.500000 0.500000 0.500000 1.166667 1.166667 1.500000 ... 0.333333 0.333333 0.166667 0.000000 0.166667 0.500000 0.333333 0.833333 0.666667 0.500000 17 0.666667 0.666667 0.666667 0.666667 0.666667 0.666667 0.666667 1.000000 1.000000 1.333333 ... 0.166667 0.500000 0.333333 0.166667 0.000000 0.333333 0.166667 0.666667 0.500000 0.333333 18 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 0.666667 0.666667 1.333333 ... 0.500000 0.833333 0.666667 0.500000 0.333333 0.000000 0.166667 0.666667 0.500000 0.333333 19 0.833333 0.833333 0.833333 0.833333 0.833333 0.833333 0.833333 0.833333 0.833333 1.166667 ... 0.333333 0.666667 0.500000 0.333333 0.166667 0.166667 0.000000 0.500000 0.333333 0.166667 20 1.333333 1.333333 1.333333 1.333333 1.333333 1.333333 1.333333 1.333333 1.333333 0.666667 ... 0.833333 1.166667 1.000000 0.833333 0.666667 0.666667 0.500000 0.000000 0.166667 0.333333 21 1.166667 1.166667 1.166667 1.166667 1.166667 1.166667 1.166667 1.166667 1.166667 0.833333 ... 0.666667 1.000000 0.833333 0.666667 0.500000 0.500000 0.333333 0.166667 0.000000 0.166667 22 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 ... 0.500000 0.833333 0.666667 0.500000 0.333333 0.333333 0.166667 0.333333 0.166667 0.000000 <p>23 rows \u00d7 23 columns</p> In\u00a0[9]: Copied! <pre>tree.distance.get_node_distance(15, 17)\n</pre> tree.distance.get_node_distance(15, 17) Out[9]: <pre>0.3333333333333333</pre> In\u00a0[10]: Copied! <pre>tree.distance.get_tip_distance_matrix(df=True)\n</pre> tree.distance.get_tip_distance_matrix(df=True) Out[10]: r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r0 0.000000 1.000000 1.000000 1.333333 1.333333 1.333333 1.333333 1.666667 1.666667 2.000000 2.000000 2.000000 r1 1.000000 0.000000 0.666667 1.333333 1.333333 1.333333 1.333333 1.666667 1.666667 2.000000 2.000000 2.000000 r2 1.000000 0.666667 0.000000 1.333333 1.333333 1.333333 1.333333 1.666667 1.666667 2.000000 2.000000 2.000000 r3 1.333333 1.333333 1.333333 0.000000 0.666667 0.666667 1.000000 1.666667 1.666667 2.000000 2.000000 2.000000 r4 1.333333 1.333333 1.333333 0.666667 0.000000 0.333333 1.000000 1.666667 1.666667 2.000000 2.000000 2.000000 r5 1.333333 1.333333 1.333333 0.666667 0.333333 0.000000 1.000000 1.666667 1.666667 2.000000 2.000000 2.000000 r6 1.333333 1.333333 1.333333 1.000000 1.000000 1.000000 0.000000 1.666667 1.666667 2.000000 2.000000 2.000000 r7 1.666667 1.666667 1.666667 1.666667 1.666667 1.666667 1.666667 0.000000 1.333333 2.000000 2.000000 2.000000 r8 1.666667 1.666667 1.666667 1.666667 1.666667 1.666667 1.666667 1.333333 0.000000 2.000000 2.000000 2.000000 r9 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 0.000000 1.333333 1.666667 r10 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 1.333333 0.000000 1.666667 r11 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 1.666667 1.666667 0.000000 In\u00a0[11]: Copied! <pre>tree.distance.get_internal_node_distance_matrix(df=True)\n</pre> tree.distance.get_internal_node_distance_matrix(df=True) Out[11]: 12 13 14 15 16 17 18 19 20 21 22 12 0.000000 0.166667 0.833333 0.666667 0.500000 0.333333 0.666667 0.500000 1.000000 0.833333 0.666667 13 0.166667 0.000000 0.666667 0.500000 0.333333 0.166667 0.500000 0.333333 0.833333 0.666667 0.500000 14 0.833333 0.666667 0.000000 0.166667 0.333333 0.500000 0.833333 0.666667 1.166667 1.000000 0.833333 15 0.666667 0.500000 0.166667 0.000000 0.166667 0.333333 0.666667 0.500000 1.000000 0.833333 0.666667 16 0.500000 0.333333 0.333333 0.166667 0.000000 0.166667 0.500000 0.333333 0.833333 0.666667 0.500000 17 0.333333 0.166667 0.500000 0.333333 0.166667 0.000000 0.333333 0.166667 0.666667 0.500000 0.333333 18 0.666667 0.500000 0.833333 0.666667 0.500000 0.333333 0.000000 0.166667 0.666667 0.500000 0.333333 19 0.500000 0.333333 0.666667 0.500000 0.333333 0.166667 0.166667 0.000000 0.500000 0.333333 0.166667 20 1.000000 0.833333 1.166667 1.000000 0.833333 0.666667 0.666667 0.500000 0.000000 0.166667 0.333333 21 0.833333 0.666667 1.000000 0.833333 0.666667 0.500000 0.500000 0.333333 0.166667 0.000000 0.166667 22 0.666667 0.500000 0.833333 0.666667 0.500000 0.333333 0.333333 0.166667 0.333333 0.166667 0.000000"},{"location":"node-distance/#node-paths-and-distances","title":"Node paths and distances\u00b6","text":"<p>The <code>toytree.distance</code> module includes a number of methods for evaluating distances between nodes in a tree. This includes methods for generating paths between nodes such that each node or edge along the path can be evaluated, as well as methods for measuring distances as the sum of these values. A set of related methods for measuring \"tree distances\" as the differences between tree topologies are also contained in this module, but are described in a separate tutorial. Here we focus on distances between nodes within a single tree.</p>"},{"location":"node-distance/#node-paths","title":"Node Paths\u00b6","text":""},{"location":"node-distance/#get_node_path","title":"get_node_path\u00b6","text":"<p>The <code>get_node_path</code> method returns a tuple of Node objects between two queried Nodes of a tree (including both terminal nodes). This traces the shortest connecting path on the tree.</p>"},{"location":"node-distance/#iter_node_path","title":"iter_node_path\u00b6","text":"<p>The <code>iter_node_path</code> is a generator similar to the function above. This can be more efficient when writing a method that performs many iterations over a large tree, since the search can be terminated when a particular target is found while iterating along each path.</p>"},{"location":"node-distance/#get_farthest_node","title":"get_farthest_node\u00b6","text":"<p>Returns the node that is farthest from a selected node. If multiple nodes are equidistant the one with the lowest idx label is returned.</p>"},{"location":"node-distance/#node-distances","title":"Node Distances\u00b6","text":"<p>Several methods are available to measure distances between nodes. The most general is <code>get_node_distance_matrix</code>, which returns the distances between all nodes. However, several other methods also provide convenient methods for measuring distances between nodes with particular relationships.</p>"},{"location":"node-distance/#get_farthest_node_distance","title":"get_farthest_node_distance\u00b6","text":"<p>Returns the distance to the farthest node from a selected node.</p>"},{"location":"node-distance/#get_descendant_dists","title":"get_descendant_dists\u00b6","text":"<p>Returns a dictionary mapping Nodes to distances, where each node is a descendant of the selected target node, and the distances are the descendant node's distance from the target node.</p>"},{"location":"node-distance/#iter_descendant_dists","title":"iter_descendant_dists\u00b6","text":"<p>Similar to above but returns a generator that iterates over descendant nodes.</p>"},{"location":"node-distance/#get_node_distance_matrix","title":"get_node_distance_matrix\u00b6","text":"<p>This returns an array with distances between all nodes as the sum of the edges separating them. The nodes are listed in node idx order. By default the result is returned as a numpy array, but using the argument <code>df=True</code> will return as a pandas DataFrame where nodes with names will be labeled by their name, and other labels (e.g. internal) by their idx label. The option <code>topology_only</code> can be used to measure distance as the number of nodes between each pair, rather than the sum edge lengths.</p>"},{"location":"node-distance/#get_node_distance","title":"get_node_distance\u00b6","text":"<p>Returns the sum distance between two nodes. A shorter and faster call than getting the full distance matrix to calculate one distance.</p>"},{"location":"node-distance/#get_tip_distance_matrix","title":"get_tip_distance_matrix\u00b6","text":"<p>Return a distance matrix for only the tip nodes in the tree.</p>"},{"location":"node-distance/#get_internal_node_distance_matrix","title":"get_internal_node_distance_matrix\u00b6","text":"<p>Return a distance matrix for only the internal nodes in a tree.</p>"},{"location":"node/","title":"Node","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># create an example tree\ntree = toytree.rtree.rtree(ntips=8, seed=321)\ntree.draw('c');\n</pre> # create an example tree tree = toytree.rtree.rtree(ntips=8, seed=321) tree.draw('c'); r0r1r2r3r4r5r6r701234 In\u00a0[3]: Copied! <pre># create a new Node\nsingle_node = toytree.Node(name=\"single\")\nsingle_node\n</pre> # create a new Node single_node = toytree.Node(name=\"single\") single_node Out[3]: <pre>&lt;Node(name='single')&gt;</pre> In\u00a0[4]: Copied! <pre># select a Node from a ToyTree\nnode3 = tree[3]\nnode3\n</pre> # select a Node from a ToyTree node3 = tree[3] node3 Out[4]: <pre>&lt;Node(idx=3, name='r3')&gt;</pre> In\u00a0[5]: Copied! <pre># check that an object's type is a Node \nisinstance(node3, toytree.Node)\n</pre> # check that an object's type is a Node  isinstance(node3, toytree.Node) Out[5]: <pre>True</pre> In\u00a0[6]: Copied! <pre># a name can be accessed from a Node\nsingle_node.name\n</pre> # a name can be accessed from a Node single_node.name Out[6]: <pre>'single'</pre> In\u00a0[7]: Copied! <pre># a name can be accessed from a Node in a ToyTree\ntree[3].name\n</pre> # a name can be accessed from a Node in a ToyTree tree[3].name Out[7]: <pre>'r3'</pre> In\u00a0[8]: Copied! <pre># returns .name from Nodes in the order they will be plotted (idxorder)\ntree.get_tip_labels()\n</pre> # returns .name from Nodes in the order they will be plotted (idxorder) tree.get_tip_labels() Out[8]: <pre>['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7']</pre> In\u00a0[9]: Copied! <pre># a Node that is not part of a ToyTree has idx=-1\nsingle_node.idx\n</pre> # a Node that is not part of a ToyTree has idx=-1 single_node.idx Out[9]: <pre>-1</pre> In\u00a0[10]: Copied! <pre># Nodes in a ToyTree have unique idx values between 0 and nnodes - 1\nnode3.idx\n</pre> # Nodes in a ToyTree have unique idx values between 0 and nnodes - 1 node3.idx Out[10]: <pre>3</pre> In\u00a0[11]: Copied! <pre># default Node dist\nsingle_node.dist\n</pre> # default Node dist single_node.dist Out[11]: <pre>0.0</pre> In\u00a0[12]: Copied! <pre># the dist from node 3 to its parent\nnode3.dist\n</pre> # the dist from node 3 to its parent node3.dist Out[12]: <pre>1.0</pre> In\u00a0[13]: Copied! <pre># the default support value\nsingle_node.support\n</pre> # the default support value single_node.support Out[13]: <pre>nan</pre> In\u00a0[14]: Copied! <pre># the default .up is None (no value is returned here)\nsingle_node.up\n</pre> # the default .up is None (no value is returned here) single_node.up In\u00a0[15]: Copied! <pre># node3's parent is Node 10\nnode3.up\n</pre> # node3's parent is Node 10 node3.up Out[15]: <pre>&lt;Node(idx=10)&gt;</pre> In\u00a0[16]: Copied! <pre># the parent of node3's parent is Node 11\nnode3.up.up\n</pre> # the parent of node3's parent is Node 11 node3.up.up Out[16]: <pre>&lt;Node(idx=13)&gt;</pre> In\u00a0[17]: Copied! <pre># this single Node has no children\nsingle_node.children\n</pre> # this single Node has no children single_node.children Out[17]: <pre>()</pre> In\u00a0[18]: Copied! <pre># internal Node 8 in the tree has two children\ntree[8].children\n</pre> # internal Node 8 in the tree has two children tree[8].children Out[18]: <pre>(&lt;Node(idx=0, name='r0')&gt;, &lt;Node(idx=1, name='r1')&gt;)</pre> In\u00a0[19]: Copied! <pre># single node has not height\nsingle_node.height\n</pre> # single node has not height single_node.height Out[19]: <pre>0.0</pre> In\u00a0[20]: Copied! <pre># leaf node 3 height\nnode3.height\n</pre> # leaf node 3 height node3.height Out[20]: <pre>1.0</pre> In\u00a0[21]: Copied! <pre># internal node 8 height\ntree[8].height\n</pre> # internal node 8 height tree[8].height Out[21]: <pre>2.0</pre> In\u00a0[22]: Copied! <pre>node3.is_leaf()\n</pre> node3.is_leaf() Out[22]: <pre>True</pre> In\u00a0[23]: Copied! <pre>node3.is_root()\n</pre> node3.is_root() Out[23]: <pre>False</pre> In\u00a0[24]: Copied! <pre>node3.get_ancestors()\n</pre> node3.get_ancestors() Out[24]: <pre>(&lt;Node(idx=10)&gt;, &lt;Node(idx=13)&gt;, &lt;Node(idx=14)&gt;)</pre> In\u00a0[25]: Copied! <pre>node3.get_descendants()\n</pre> node3.get_descendants() Out[25]: <pre>(&lt;Node(idx=3, name='r3')&gt;,)</pre> In\u00a0[26]: Copied! <pre>node3.get_leaves()\n</pre> node3.get_leaves() Out[26]: <pre>[&lt;Node(idx=3, name='r3')&gt;]</pre> In\u00a0[27]: Copied! <pre>node3.get_sisters()\n</pre> node3.get_sisters() Out[27]: <pre>(&lt;Node(idx=4, name='r4')&gt;,)</pre> In\u00a0[28]: Copied! <pre>node3.get_leaf_names()\n</pre> node3.get_leaf_names() Out[28]: <pre>['r3']</pre> <p>Each of the <code>get_[x]</code> functions above is also available as a generator function named <code>iter_[x]</code>, which is more efficient for fetching such data over very large trees, or for terminating a traversal over part of the tree once a condition has been met. The <code>traverse()</code> function is also a generator function.</p> In\u00a0[29]: Copied! <pre>node3.iter_ancestors()\n</pre> node3.iter_ancestors() Out[29]: <pre>&lt;generator object Node.iter_ancestors at 0x7f3ba6ca9bd0&gt;</pre> In\u00a0[30]: Copied! <pre>node3.traverse(\"idxorder\")\n</pre> node3.traverse(\"idxorder\") Out[30]: <pre>&lt;generator object Node._traverse_idxorder at 0x7f3ba6ca9d20&gt;</pre> In\u00a0[31]: Copied! <pre># edges are simply pairs of Nodes with a child,parent relationship\ntree.get_edges(feature='idx', df=True)\n</pre> # edges are simply pairs of Nodes with a child,parent relationship tree.get_edges(feature='idx', df=True) Out[31]: child parent 0 0 8 1 1 8 2 2 9 3 3 10 4 4 10 5 5 11 6 6 11 7 7 12 8 8 9 9 9 14 10 10 13 11 11 12 12 12 13 13 13 14 In\u00a0[32]: Copied! <pre># catch 'ToyTreeError' exception raised when trying to modify a Node attribute\ntry:\n    single_node.idx = 10\nexcept toytree.utils.ToytreeError as exc:\n    print(\"ToyTreeError:\", exc)\n</pre> # catch 'ToyTreeError' exception raised when trying to modify a Node attribute try:     single_node.idx = 10 except toytree.utils.ToytreeError as exc:     print(\"ToyTreeError:\", exc) <pre>ToyTreeError: Cannot set .idx attribute of a Node. If you are an advanced user then you can do so by setting ._idx. See the docs section on Modifying Nodes and Tree Topology.\n</pre> In\u00a0[33]: Copied! <pre># an example toytree.mod function that modifies node attributes\nrtree = tree.mod.root(\"r4\")\n\n# the new tree has different idx values b/c the traversal order changed\ntoytree.mtree([tree, rtree]).draw(ts='p');\n</pre> # an example toytree.mod function that modifies node attributes rtree = tree.mod.root(\"r4\")  # the new tree has different idx values b/c the traversal order changed toytree.mtree([tree, rtree]).draw(ts='p'); 01234567891011121314r0r1r2r3r4r5r6r701234567891011121314r4r3r5r6r7r0r1r2 In\u00a0[34]: Copied! <pre># create a new tree copy\nmodtree = tree.copy()\n\n# modify one or more private node attributes\nmodtree[0]._dist += 2\nmodtree[1]._dist += 3\n\n# call update to update idxs, heights, etc.\nmodtree._update()\n\n# show the old and new tree with longer .dists for nodes 0,1 and .heights for all nodes\ntoytree.mtree([tree, modtree]).draw(ts='p', scale_bar=True);\n</pre> # create a new tree copy modtree = tree.copy()  # modify one or more private node attributes modtree[0]._dist += 2 modtree[1]._dist += 3  # call update to update idxs, heights, etc. modtree._update()  # show the old and new tree with longer .dists for nodes 0,1 and .heights for all nodes toytree.mtree([tree, modtree]).draw(ts='p', scale_bar=True); 01234567891011121314r0r1r2r3r4r5r6r70123401234567891011121314r0r1r2r3r4r5r6r70246 <ol> <li>Generate random or fixed trees. See the <code>rtree</code> documentation section for more details. This includes options to generate trees under a variety of algorithms and of different sizes.</li> </ol> In\u00a0[35]: Copied! <pre># generate a 6-tip balanced tree with crown height of 1M units\ntoytree.rtree.baltree(6, treeheight=1e6).draw(scale_bar=True);\n</pre> # generate a 6-tip balanced tree with crown height of 1M units toytree.rtree.baltree(6, treeheight=1e6).draw(scale_bar=True); r0r1r2r3r4r510000005000000 <ol> <li>Parse a Newick string to generate a tree from scratch with desired characteristics.</li> </ol> In\u00a0[36]: Copied! <pre># generate a ToyTree with this specific data\ntoytree.tree(\"(((a:3,b:2):1),(c:3,d:2):5);\").draw(scale_bar=True);\n</pre> # generate a ToyTree with this specific data toytree.tree(\"(((a:3,b:2):1),(c:3,d:2):5);\").draw(scale_bar=True); abcd7.552.50 <ol> <li>Modify a tree using one or more <code>toytree.mod</code> functions:</li> </ol> In\u00a0[37]: Copied! <pre># get a 4-tip balanced tree\ntree4 = toytree.rtree.baltree(4)\n\n# add a new sister (internal and tip node) to tip node 'r1'\nmodtree4 = toytree.mod.add_internal_node_and_child(tree4, 'r1', name=\"child\", parent_name=\"parent\")\n\n# draw to highlight new parent and child nodes\nmodtree4.draw('r', node_mask=modtree4.get_node_mask(5), node_colors=\"lightgrey\");\n</pre> # get a 4-tip balanced tree tree4 = toytree.rtree.baltree(4)  # add a new sister (internal and tip node) to tip node 'r1' modtree4 = toytree.mod.add_internal_node_and_child(tree4, 'r1', name=\"child\", parent_name=\"parent\")  # draw to highlight new parent and child nodes modtree4.draw('r', node_mask=modtree4.get_node_mask(5), node_colors=\"lightgrey\"); parentr0r1childr2r3 <ol> <li>Create connections among <code>Node</code> objects and create a <code>ToyTree</code> from them. You can do this by setting <code>._up</code>, <code>._children</code>, and <code>._dist</code> values on a set of nodes.</li> </ol> In\u00a0[38]: Copied! <pre># create several tips nodes\nnodeA = toytree.Node(\"A\", dist=1)\nnodeB = toytree.Node(\"B\", dist=1)\nnodeC = toytree.Node(\"C\", dist=1)\n\n# create several internal Nodes\nnodeAB = toytree.Node(\"AB\", dist=1)\nnodeABC = toytree.Node(\"ABC\", dist=1)\n\n# connect the nodes\nnodeA._up = nodeAB\nnodeB._up = nodeAB\nnodeC._up = nodeABC\nnodeAB._up = nodeABC\nnodeAB._children = (nodeA, nodeB)\nnodeABC._children = (nodeAB, nodeC)\n\n# draw the tree (the tree traversal data is cached at this step)\ntoytree.tree(nodeABC).draw(ts='r', node_colors=\"lightgrey\");\n</pre> # create several tips nodes nodeA = toytree.Node(\"A\", dist=1) nodeB = toytree.Node(\"B\", dist=1) nodeC = toytree.Node(\"C\", dist=1)  # create several internal Nodes nodeAB = toytree.Node(\"AB\", dist=1) nodeABC = toytree.Node(\"ABC\", dist=1)  # connect the nodes nodeA._up = nodeAB nodeB._up = nodeAB nodeC._up = nodeABC nodeAB._up = nodeABC nodeAB._children = (nodeA, nodeB) nodeABC._children = (nodeAB, nodeC)  # draw the tree (the tree traversal data is cached at this step) toytree.tree(nodeABC).draw(ts='r', node_colors=\"lightgrey\"); ABABCABC <p>Similarly, this process could be applied to an existing tree to add or remove connections by changing the same types of node attributes. The important thing is that the <code>ToyTree._update()</code> function is called at the end to update values across connected nodes. The <code>Node</code> object includes convenience functions <code>_add_child</code> and <code>_remove_child</code> which change the <code>._up</code> and <code>._children</code> attributes together, but setting them manually may be more clear.</p> In\u00a0[39]: Copied! <pre># get a 4-tip balanced tree\ntree4 = toytree.rtree.baltree(4, treeheight=2)\n\n# add a new sister (internal and tip node) to tip node 0\ntree4[0]._add_child(toytree.Node(\"child0\", dist=1))\ntree4[0]._add_child(toytree.Node(\"child1\", dist=1))\n\n# connects node data across three\ntree4._update()\n\n# draw to highlight new nodes. Note former node (idx=0, name='r0') is now node idx=5\ntree4.draw('r', node_mask=tree4.get_node_mask(5), node_colors=\"lightgrey\");\n</pre> # get a 4-tip balanced tree tree4 = toytree.rtree.baltree(4, treeheight=2)  # add a new sister (internal and tip node) to tip node 0 tree4[0]._add_child(toytree.Node(\"child0\", dist=1)) tree4[0]._add_child(toytree.Node(\"child1\", dist=1))  # connects node data across three tree4._update()  # draw to highlight new nodes. Note former node (idx=0, name='r0') is now node idx=5 tree4.draw('r', node_mask=tree4.get_node_mask(5), node_colors=\"lightgrey\"); r0child0child1r1r2r3"},{"location":"node/#toytreenode","title":"toytree.Node\u00b6","text":"<p>The <code>toytree.Node</code> class is primarily used for data storage. Minimally, it contains attributes storing a <code>.name</code>, <code>.dist</code> (edge length), and <code>.support</code> values, as well as attributes <code>.up</code> and <code>.children</code> which point to other <code>Node</code> objects to represent connections between them.</p> <p>A single <code>Node</code> instance is generally of little use, it is only when nodes form connections that they have emergent properties in the form  a network/tree structure. Thus, most methods in the <code>toytree</code> library are associated with <code>ToyTree</code> objects which are a container around a collection of <code>Nodes</code>. However, <code>Node</code> objects themselves are important to understand as the underlying object storing data within trees. This section describes the structure of <code>Node</code> objects and the design behind their intended use.</p>"},{"location":"node/#the-node-class","title":"The Node class\u00b6","text":"<p>The <code>Node</code> class is accessible from <code>toytree.Node</code> and can be used to create new instances or to check or validate the type of a <code>Node</code> instance. Unless you are a developer you are not likely to create new <code>Node</code> objects often, but instead will most often interact them by selecting them from within <code>ToyTrees</code>.</p>"},{"location":"node/#attributes","title":"Attributes\u00b6","text":""},{"location":"node/#name-str","title":"name: str\u00b6","text":"<p>The default <code>name</code> attribute is an empty string. Leaf nodes usually have names associated with them whereas internal nodes usually do not. This will depend on the data that a tree is parsed or constructed from, and whether additional names are added. Some characters are not allowed in node names (<code>[:;(),\\[\\]\\t\\n\\r=]</code>) as they would interfere with Newick string parsing when written to a file. Names can be accessed from a <code>Node</code>'s <code>.name</code> attribute, and can be used to query nodes from a <code>ToyTree</code>.</p>"},{"location":"node/#idx-int","title":"idx: int\u00b6","text":"<p>The default <code>idx</code> attribute is an int value of -1, which means that the node is not part of a <code>ToyTree</code>. If a node is in a <code>ToyTree</code> then it will be assigned a unique idx integer between 0 and nnodes-1. The leaf nodes in a tree have idx values between 0 and ntips - 1, and all internal nodes are labeled by increasing numbers in a post-order left-then-right traversal. This is termed an idxorder traversal. When a tree structure changes (e.g. during re-rooting) the idx values of nodes are updated and can change (see Traversal). A node's idx value can be checked from its <code>.idx</code> attribute, or if it is in a <code>ToyTree</code> then by calling <code>.get_node_data()</code> or plotting the tree to visualize idx values.</p>"},{"location":"node/#dist-float","title":"dist: float\u00b6","text":"<p>The default <code>dist</code> attribute is a float of 0. The value represents the distance from a node to its parent. In other words, it is the length of an edge connecting them. The dist attribute is thus not actually a feature of a node, but of an edge between nodes, but is nevertheless stored to a <code>Node</code> object. We call this an <code>edge_feature</code> of a <code>Node</code>, since it will change if the tree is re-rooted, changing which Node is parent to another. The value of a dist can range from very small to very large values, such as when representing the expected number of substitutions per site on a phylogeny, or divergence times in millions of years.</p>"},{"location":"node/#support-float","title":"support: float\u00b6","text":"<p>The default <code>support</code> value is <code>numpy.nan</code>, which represents the absence of support information. Tip (leaf) nodes are not expected to have support information, since they do not represent a split in a tree. Similarly, the root node support is <code>nan</code> since it does not represent a true split.</p>"},{"location":"node/#up-node","title":"up: Node\u00b6","text":"<p>The <code>.up</code> attribute references a node's parent. The default value is <code>None</code>. This is also the value of the <code>.up</code> attribute of the root <code>Node</code> in a <code>ToyTree</code>, since it has no parent. A <code>Node</code> can only have one parent. If a tree is re-rooted the relationship between nodes can change such that a <code>Node</code> that was previously a child can become a parent, and thus the <code>Node</code> attributes are automatically updated during this process.</p>"},{"location":"node/#children-tuple","title":"children: tuple\u00b6","text":"<p>The <code>.children</code> attribute is a tuple of zero or more <code>Node</code> objects that are descended from a node. The default is an empty tuple. If a tree is re-rooted the relationship between nodes can change such that a <code>Node</code> that was previously a child can become a parent, and thus the <code>Node</code> attributes are automatically updated during this process.</p>"},{"location":"node/#height-float","title":"height: float\u00b6","text":"<p>The default <code>height</code> value is a float of 0. The height of a <code>Node</code> is an emergent property of a tree of connected nodes. It is the height above the node that is the farthest distance from the root. This value is automatically updated for every node in a <code>ToyTree</code> when a tree is modified during the cached traversal.</p>"},{"location":"node/#methods","title":"Methods\u00b6","text":"<p>The <code>Node</code> object provides a number of functions for fetching information about a node's position relative to other connected nodes. Some of this information is also accessible from a <code>ToyTree</code> object, but is sometimes easier to access it from a Node object directly.</p>"},{"location":"node/#nodes-vs-edges","title":"Nodes vs 'Edges'\u00b6","text":"<p>Notably, <code>toytree</code> does not implement a separate \"Edge\" class to represent edges in a tree. Instead, edges are simply represented by the connections between <code>Node</code> objects -- by their <code>.up</code> and <code>.children</code> attributes. (This can be important when storing new data types to a tree; see Edge features). Thus you can think of edges as pairs of nodes. You can fetch the edge information from a <code>ToyTree</code> in a variety of ways. Below we use the function <code>get_edges</code> which has options for returning this information in a number of tabular formats.</p>"},{"location":"node/#mutability-of-nodes","title":"Mutability of Nodes\u00b6","text":"<p>The data assigned to nodes may represent a feature of the node itself, or it may represent a feature of the edge connecting that node to its parent. In the latter case, it is important that the data be treated appropriately if the tree is modified, such as when a node is pruned from the tree, or the tree is re-rooted. In these cases, the edge features, such as the <code>.dist</code>, <code>.support</code>, and the connection information <code>.up</code> and <code>.children</code>, need to be automatically updated. Similarly, emergent properties of nodes in a tree, such as the <code>.height</code> of a node relative to the farthest leaf must be re-computed.</p> <p>The automatic updating of these attributes is done at the level of a <code>ToyTree</code>, not within individual <code>Nodes</code>, and thus we have intentionally designed these elements of <code>Node</code> objects to be immutable (you cannot modify them directly). Thus, users cannot call <code>node.idx = 3</code>  or <code>node.height = 100</code> to set these atrributes to a new value, since these attributes are properties of the node's placement with respect to other nodes in the tree, which need to also be updated. If you try to set one of these values a <code>ToyTreeError</code> exception will be raised like in the example below where we catch the exception and print it. For developers there is a simple workaround for this described further below.</p>"},{"location":"node/#calling-mod-functions","title":"Calling mod functions\u00b6","text":"<p>Instead of modifying a node's attributes directly you should instead call one of the tree modification functions from the <code>toytree.mod</code> subpackage that will ensure that the rest of the tree data is automatically updated along with the modified node data. Examples include the <code>.root</code>, <code>.drop_tips</code>, <code>prune</code>, <code>ladderize</code>, <code>rotate_nodes</code>, <code>edges_set_node_heights</code>, and many others which modify one or more <code>.up</code>, <code>.children</code>, <code>.idx</code>, <code>.dist</code>, or <code>.height</code> attributes of nodes in unison.</p>"},{"location":"node/#developing-mod-functions","title":"Developing mod functions\u00b6","text":"<p>Sometimes, however, you may really want to directly modify one or more core features of a <code>Node</code>, in which case it is possible, we just want to make sure that you are well aware of the necessary considerations to avoid errors in your code. You can examine the source code of the many <code>.mod</code> subpackage functions above for examples. Each of these core attributes is available as a private attribute (e.g., <code>._dist</code>, <code>._idx</code>) which can be modified without raising an exception. The key, however, is that after one or more private node attributes have been modified, the <code>ToyTree</code> traversal caching function named <code>._update()</code> must be called at the end to ensure that all of the linked attributes of nodes are updated.</p>"},{"location":"node/#building-trees-from-nodes","title":"Building trees from Nodes\u00b6","text":"<p>There are several ways of constructing trees in <code>toytree</code> from scratch. This most simple is to use one of the random tree generation functions from the <code>toytree.rtree</code> subpackage. A second method is to write a Newick string and parse it using the <code>toytree.tree</code> function. A third is to build or modify a tree using one or more functions from <code>toytree.mod</code> such as <code>.add_child_node</code>. And finally, the fourth method is to link together <code>Node</code> objects manually. The last is the most low-level method, which requires eventually calling <code>ToyTree._update()</code> to cache the traversal order and store idx values. Each of these is demonstrated below.</p>"},{"location":"parse_trees/","title":"parsing tree data","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># example newick string\nDATA = \"((tip1:2,tip2:2):1,tip3:3);\"\n\n# load/parse into a ToyTree\ntree = toytree.tree(DATA)\ntree\n</pre> # example newick string DATA = \"((tip1:2,tip2:2):1,tip3:3);\"  # load/parse into a ToyTree tree = toytree.tree(DATA) tree Out[2]: <pre>&lt;toytree.ToyTree at 0x7f6e4600b640&gt;</pre> <p>Take Home</p> <p>       You can parse almost any tree data (file, string, nexus, newick, etc) using toytree.tree().   </p> In\u00a0[3]: Copied! <pre># newick: represents a topology using nested parentheses\nNEWICK0 = \"((,),);\"\n</pre> # newick: represents a topology using nested parentheses NEWICK0 = \"((,),);\" In\u00a0[4]: Copied! <pre># newick: name strings are usually present for tips as `(label,)`\nNEWICK1 = \"((tip1,tip2),tip3);\"\n</pre> # newick: name strings are usually present for tips as `(label,)` NEWICK1 = \"((tip1,tip2),tip3);\" In\u00a0[5]: Copied! <pre># newick: names can also be present for internal nodes as `()label`\nNEWICK2 = \"((tip1,tip2)internal1,tip3)internal2;\"\n</pre> # newick: names can also be present for internal nodes as `()label` NEWICK2 = \"((tip1,tip2)internal1,tip3)internal2;\" In\u00a0[6]: Copied! <pre># newick: edge lengths (dists) are usually present as `()label:dist`\nNEWICK3 = \"((tip1:2,tip2:2):1,tip3:3);\"\n</pre> # newick: edge lengths (dists) are usually present as `()label:dist` NEWICK3 = \"((tip1:2,tip2:2):1,tip3:3);\" In\u00a0[7]: Copied! <pre># newick: support values can be stored in place of internal names `()support`\nNEWICK4 = \"((tip1,tip2)100,tip3);\"\n</pre> # newick: support values can be stored in place of internal names `()support` NEWICK4 = \"((tip1,tip2)100,tip3);\" In\u00a0[8]: Copied! <pre># nhx: additional metadata is stored as key=value pairs as `()[meta]`\nNHX1 = \"((tip1[&amp;trait=2],tip2[&amp;trait=4])[&amp;trait=3],tip3[&amp;trait=1])[&amp;trait=5];\"\n</pre> # nhx: additional metadata is stored as key=value pairs as `()[meta]` NHX1 = \"((tip1[&amp;trait=2],tip2[&amp;trait=4])[&amp;trait=3],tip3[&amp;trait=1])[&amp;trait=5];\" In\u00a0[9]: Copied! <pre># nexus: newick/NHX data with other code blocks between (begin... end;)  \nNEXUS1 = \"\"\"\n#NEXUS\nbegin trees;\n    translate\n        1 apple,\n        2 blueberry,\n        3 cantaloupe,\n        4 durian,\n    ;\n    tree tree0 = [&amp;U] ((1,2),(3,4));\nend;\n\"\"\"\n</pre> # nexus: newick/NHX data with other code blocks between (begin... end;)   NEXUS1 = \"\"\" #NEXUS begin trees;     translate         1 apple,         2 blueberry,         3 cantaloupe,         4 durian,     ;     tree tree0 = [&amp;U] ((1,2),(3,4)); end; \"\"\" In\u00a0[10]: Copied! <pre># parse all 7 tree data strings from above into ToyTree objects\ndata = [NEWICK0, NEWICK1, NEWICK2, NEWICK3, NEWICK4, NHX1, NEXUS1]\ntrees = [toytree.tree(i) for i in data]\ntrees\n</pre> # parse all 7 tree data strings from above into ToyTree objects data = [NEWICK0, NEWICK1, NEWICK2, NEWICK3, NEWICK4, NHX1, NEXUS1] trees = [toytree.tree(i) for i in data] trees Out[10]: <pre>[&lt;toytree.ToyTree at 0x7f6e4600be50&gt;,\n &lt;toytree.ToyTree at 0x7f6e46048280&gt;,\n &lt;toytree.ToyTree at 0x7f6e460485e0&gt;,\n &lt;toytree.ToyTree at 0x7f6e46048a90&gt;,\n &lt;toytree.ToyTree at 0x7f6e46048f40&gt;,\n &lt;toytree.ToyTree at 0x7f6e460493f0&gt;,\n &lt;toytree.ToyTree at 0x7f6e46049900&gt;]</pre> In\u00a0[11]: Copied! <pre># print newick with str labels for tips and internal nodes\nprint(f\"Newick = {NEWICK2}\")\n\n# parse the newick string with .tree()\ntree = toytree.tree(NEWICK2)\n\n# show the tree data (labels were assigned to 'name' feature)\ntree.get_node_data()\n</pre> # print newick with str labels for tips and internal nodes print(f\"Newick = {NEWICK2}\")  # parse the newick string with .tree() tree = toytree.tree(NEWICK2)  # show the tree data (labels were assigned to 'name' feature) tree.get_node_data() <pre>Newick = ((tip1,tip2)internal1,tip3)internal2;\n</pre> Out[11]: idx name height dist support 0 0 tip1 0.0 1.0 NaN 1 1 tip2 0.0 1.0 NaN 2 2 tip3 1.0 1.0 NaN 3 3 internal1 1.0 1.0 NaN 4 4 internal2 2.0 0.0 NaN In\u00a0[12]: Copied! <pre># print newick with str labels for tips and int labels for internal nodes\nprint(f\"Newick = {NEWICK4}\")\n\n# parse the newick string with .tree()\ntree = toytree.tree(NEWICK4)\n\n# show the tree data (labels assigned to 'support' for internal Node)\ntree.get_node_data()\n</pre> # print newick with str labels for tips and int labels for internal nodes print(f\"Newick = {NEWICK4}\")  # parse the newick string with .tree() tree = toytree.tree(NEWICK4)  # show the tree data (labels assigned to 'support' for internal Node) tree.get_node_data() <pre>Newick = ((tip1,tip2)100,tip3);\n</pre> Out[12]: idx name height dist support 0 0 tip1 0.0 1.0 NaN 1 1 tip2 0.0 1.0 NaN 2 2 tip3 1.0 1.0 NaN 3 3 1.0 1.0 100.0 4 4 2.0 0.0 NaN In\u00a0[13]: Copied! <pre># parse the newick string with internal str labels and assign\ntre0 = toytree.tree(NEWICK2, internal_labels=\"arbitrary\")\n\n# show the tree data where labels were assigned to \"arbitrary\"\ntre0.get_node_data()\n</pre> # parse the newick string with internal str labels and assign tre0 = toytree.tree(NEWICK2, internal_labels=\"arbitrary\")  # show the tree data where labels were assigned to \"arbitrary\" tre0.get_node_data() Out[13]: idx name height dist support arbitrary 0 0 tip1 0.0 1.0 NaN NaN 1 1 tip2 0.0 1.0 NaN NaN 2 2 tip3 1.0 1.0 NaN NaN 3 3 1.0 1.0 NaN internal1 4 4 2.0 0.0 NaN internal2 In\u00a0[14]: Copied! <pre># only tip Node metadata\nNHX1 = \"((a[&amp;N=1],b[&amp;N=2]),c[&amp;N=3]);\"\n# only internal Node metadata\nNHX2 = \"((a,b)[&amp;N=4],c)[&amp;N=5];\"\n# both tip and internal Node metadata\nNHX3 = \"((a[&amp;N=1],b[&amp;N=2])[&amp;N=4],c[&amp;N=3])[&amp;N=5];\"\n# only edge metadata\nNHX4 = \"((a:1[&amp;E=1],b:1[&amp;E=2]):1[&amp;E=4],c:1[&amp;E=3]);\"\n# both node and edge metadata\nNHX5 = \"((a[&amp;N=1]:1[&amp;E=1],b[&amp;N=2]:1[&amp;E=2])[&amp;N=4]:1[&amp;E=4],c[&amp;N=3]:1[&amp;E=3])[&amp;N=5];\"\n</pre> # only tip Node metadata NHX1 = \"((a[&amp;N=1],b[&amp;N=2]),c[&amp;N=3]);\" # only internal Node metadata NHX2 = \"((a,b)[&amp;N=4],c)[&amp;N=5];\" # both tip and internal Node metadata NHX3 = \"((a[&amp;N=1],b[&amp;N=2])[&amp;N=4],c[&amp;N=3])[&amp;N=5];\" # only edge metadata NHX4 = \"((a:1[&amp;E=1],b:1[&amp;E=2]):1[&amp;E=4],c:1[&amp;E=3]);\" # both node and edge metadata NHX5 = \"((a[&amp;N=1]:1[&amp;E=1],b[&amp;N=2]:1[&amp;E=2])[&amp;N=4]:1[&amp;E=4],c[&amp;N=3]:1[&amp;E=3])[&amp;N=5];\" In\u00a0[15]: Copied! <pre># NHX1 has only tip node data mapped to feature \"N\"\ntoytree.tree(NHX1).get_node_data()\n</pre> # NHX1 has only tip node data mapped to feature \"N\" toytree.tree(NHX1).get_node_data() Out[15]: idx name height dist support N 0 0 a 0.0 1.0 NaN 1.0 1 1 b 0.0 1.0 NaN 2.0 2 2 c 1.0 1.0 NaN 3.0 3 3 1.0 1.0 NaN NaN 4 4 2.0 0.0 NaN NaN In\u00a0[16]: Copied! <pre># NHX5 has all node data mapped to feature \"N\" and edge data to feature \"E\"\ntoytree.tree(NHX5).get_node_data()\n</pre> # NHX5 has all node data mapped to feature \"N\" and edge data to feature \"E\" toytree.tree(NHX5).get_node_data() Out[16]: idx name height dist support E N 0 0 a 0.0 1.0 NaN 1.0 1.0 1 1 b 0.0 1.0 NaN 2.0 2.0 2 2 c 1.0 1.0 NaN 3.0 3.0 3 3 1.0 1.0 NaN 4.0 4.0 4 4 2.0 0.0 NaN NaN 5.0 In\u00a0[17]: Copied! <pre># nexus: Newick/NHX data with other code blocks between (begin... end;)  \nNEXUS_EXAMPLE = \"\"\"\n#NEXUS\nbegin data;\n    ...\nend;\n\nbegin mrbayes;\n    ...\nend;\n\nbegin trees;\n    translate\n        1 apple,\n        2 blueberry,\n        3 cantaloupe,\n        4 durian,\n    ;\n    tree tree0 = [&amp;U] ((1,2),(3,4));\nend;\n\"\"\"\n</pre> # nexus: Newick/NHX data with other code blocks between (begin... end;)   NEXUS_EXAMPLE = \"\"\" #NEXUS begin data;     ... end;  begin mrbayes;     ... end;  begin trees;     translate         1 apple,         2 blueberry,         3 cantaloupe,         4 durian,     ;     tree tree0 = [&amp;U] ((1,2),(3,4)); end; \"\"\" In\u00a0[18]: Copied! <pre># parse NEXUS file and show tree data\ntree = toytree.tree(NEXUS_EXAMPLE)\ntree.get_node_data()\n</pre> # parse NEXUS file and show tree data tree = toytree.tree(NEXUS_EXAMPLE) tree.get_node_data() Out[18]: idx name height dist support 0 0 apple 0.0 1.0 NaN 1 1 blueberry 0.0 1.0 NaN 2 2 cantaloupe 0.0 1.0 NaN 3 3 durian 0.0 1.0 NaN 4 4 1.0 1.0 NaN 5 5 1.0 1.0 NaN 6 6 2.0 0.0 NaN In\u00a0[19]: Copied! <pre># a str with Newick data separated by new lines\nMULTILINE_NEWICK = \"\"\"\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((a:1,d:1):1,(b:1,e:1):1):1,c:3);\n(((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5);\n(((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3);\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4);\n(((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3);\n(((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3);\n\"\"\"\n\n# parse with .mtree\nmtree = toytree.mtree(MULTILINE_NEWICK)\nmtree\n</pre> # a str with Newick data separated by new lines MULTILINE_NEWICK = \"\"\" (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((a:1,d:1):1,(b:1,e:1):1):1,c:3); (((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5); (((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3); (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4); (((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3); (((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3); \"\"\"  # parse with .mtree mtree = toytree.mtree(MULTILINE_NEWICK) mtree Out[19]: <pre>&lt;toytree.MultiTree ntrees=8&gt;</pre> In\u00a0[20]: Copied! <pre># a Nexus str with trees in a trees block\nMULTI_N5XUS = \"\"\"\n#NEXUS\nbegin trees;\n    translate\n        1 a,\n        2 b,\n        3 c,\n        4 d,\n        5 e,\n    ;\n    tree 1 = [&amp;R] (((1:1,2:1):1,(4:1.5,5:1.5):0.5):1,3:3);\n    tree 2 = [&amp;R] (((1:1,4:1):1,(2:1,5:1):1):1,3:3);\n    tree 3 = [&amp;R] (((1:1.5,2:1.5):1,(4:1,5:1):1.5):1,3:3.5);\n    tree 4 = [&amp;R] (((1:1.25,2:1.25):0.75,(4:1,5:1):1):1,3:3);\n    tree 5 = [&amp;R] (((1:1,2:1):1,(4:1.5,5:1.5):0.5):1,3:3);\n    tree 6 = [&amp;R] (((2:1,1:1):1,(4:1.5,5:1.5):0.5):2,3:4);\n    tree 7 = [&amp;R] (((1:1.5,2:1.5):0.5,(4:1,5:1):1):1,3:3);\n    tree 8 = [&amp;R] (((2:1.5,4:1.5):0.5,(1:1,5:1):1):1,3:3);\nend;\n\"\"\"\n\n# pars5 with .mtree\nmtree = toytree.mtree(MULTI_N5XUS)\nmtree\n</pre> # a Nexus str with trees in a trees block MULTI_N5XUS = \"\"\" #NEXUS begin trees;     translate         1 a,         2 b,         3 c,         4 d,         5 e,     ;     tree 1 = [&amp;R] (((1:1,2:1):1,(4:1.5,5:1.5):0.5):1,3:3);     tree 2 = [&amp;R] (((1:1,4:1):1,(2:1,5:1):1):1,3:3);     tree 3 = [&amp;R] (((1:1.5,2:1.5):1,(4:1,5:1):1.5):1,3:3.5);     tree 4 = [&amp;R] (((1:1.25,2:1.25):0.75,(4:1,5:1):1):1,3:3);     tree 5 = [&amp;R] (((1:1,2:1):1,(4:1.5,5:1.5):0.5):1,3:3);     tree 6 = [&amp;R] (((2:1,1:1):1,(4:1.5,5:1.5):0.5):2,3:4);     tree 7 = [&amp;R] (((1:1.5,2:1.5):0.5,(4:1,5:1):1):1,3:3);     tree 8 = [&amp;R] (((2:1.5,4:1.5):0.5,(1:1,5:1):1):1,3:3); end; \"\"\"  # pars5 with .mtree mtree = toytree.mtree(MULTI_N5XUS) mtree Out[20]: <pre>&lt;toytree.MultiTree ntrees=8&gt;</pre> <p>If you call <code>toytree.mtree</code> on a file containing a single tree then it will simply return a <code>MultiTree</code> object containing only a single <code>ToyTree</code> within it. If you call <code>toytree.tree</code> on a file containing multiple trees it will return the first tree in the file as a <code>ToyTree</code>, but will also print a warning to make sure you know that the input contained multiple trees.</p> In\u00a0[21]: Copied! <pre># calling .mtree on a single tree input is OK\ntoytree.mtree(NEWICK1)\n</pre> # calling .mtree on a single tree input is OK toytree.mtree(NEWICK1) Out[21]: <pre>&lt;toytree.MultiTree ntrees=1&gt;</pre> In\u00a0[22]: Copied! <pre># calling .tree on a multiple tree input is also OK, but raises a WARNING\ntoytree.tree(MULTILINE_NEWICK)\n</pre> # calling .tree on a multiple tree input is also OK, but raises a WARNING toytree.tree(MULTILINE_NEWICK) <pre>\u26a0\ufe0f toytree | parse:parse_tree | Data contains (8) trees.\nLoading first using `toytree.tree`. Use `toytree.mtree` to instead load a MultiTree.\n</pre> Out[22]: <pre>&lt;toytree.ToyTree at 0x7f6e4600aec0&gt;</pre> In\u00a0[23]: Copied! <pre>toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")\n</pre> toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\") Out[23]: <pre>&lt;toytree.ToyTree at 0x7f6e45e92ad0&gt;</pre>"},{"location":"parse_trees/#tree-parsing-io","title":"Tree Parsing (I/O)\u00b6","text":"<p>Parsing tree data involves loading a tree topology and associated metadata from a serialized text format into a data structure. <code>toytree</code> loads trees from a variety of text formats (Newick, nexus, NHX) stored in a file, URL, or string, and returns a <code>ToyTree</code> class object.</p> <p>This is made incredibly simple in <code>toytree</code> through the general purpose <code>toytree.tree()</code> function. In most cases, you can simply call this method on your data (string, file, or URL), without having to even specify the input data type or format.</p>"},{"location":"parse_trees/#tree-data-formats","title":"Tree data formats\u00b6","text":"<p>Below are examples of the common Newick, NHX, and Nexus tree data formats. Newick is the base format from which the other two formats are extensions. More details on parsing each format is described further below. While a few additional formats (e.g., JSON or XML) are sometimes used to store tree data, these Newick-based formats are most common.</p>"},{"location":"parse_trees/#parsing-toytrees-tldr","title":"Parsing ToyTrees (tldr;)\u00b6","text":"<p>Parsing tree data is made simple in <code>toytree</code> through the general purpose <code>toytree.tree()</code> function. For example, this method can parse all of the above data strings correctly without the need of any additional arguments to specify the data or metadata formats. Moreover, it can can parse these data regardless of whether they are entered as a string, or as a file path, or even a public URL. In this way, <code>toytree.tree()</code> acts as a sort of swiss army knife for tree data parsing.</p>"},{"location":"parse_trees/#newick-format","title":"Newick format\u00b6","text":"<p>A <code>ToyTree</code> can be flexibly loaded from a range of text formats. When parsing Newick data it is important to be aware of its limitations. Specifically, that internal node labels are sometimes used for different purposes, to store either node names, node support values (as int or floats), and sometimes for other forms of metadata. The <code>toytree.tree</code> function will auto-detect whether these labels should be stored as names or supports based on their values being numeric or not, however, you can also override this behavior to assign the values to a feature name of your choice. This is demonstrated below using two examples of Newick strings with different internal node label types (<code>NEWICK2</code> and <code>NEWICK4</code>, from above).</p>"},{"location":"parse_trees/#internal-labels-as-names","title":"Internal labels as names\u00b6","text":"<p>If any internal node labels present are non-numeric then they will be parsed and stored as \"name\" features of Nodes. In the example below the Newick string is parsed into a ToyTree object and its <code>.get_node_data()</code> function is called to show the tree's metadata, showing that labels were assigned to 'name'.</p>"},{"location":"parse_trees/#internal-labels-as-support","title":"Internal labels as support\u00b6","text":"<p>In contrast to the example above, you can see that the internal labels here are numeric and have thus been stored as \"support\" features instead of \"name\", and the internal nodes have names set to the default empty strings. This is the typical format of a Newick string generated by phylogenetic inference software, usually representing some kind of support values. Note that tip nodes/edges do not have support values, nor does the root edge. Support values are actually features of edges, not nodes. This is important for how they are re-oriented when trees are re-rooted (see Edge Features).</p>"},{"location":"parse_trees/#internal-labels-explicit","title":"Internal labels explicit\u00b6","text":"<p>As you've seen the use of internal Newick labels can be inconsistent, which is one of the main reasons that the extended Newick format (NHX) was developed, which will be introduced next. Nevertheless, instead of relying on the <code>toytree.tree</code> function to automatically parse the internal label as a name or support value, you can optionally enter the feature name you want the values assigned to explicitly using the <code>internal_labels</code> arg. For example, you could enter \"name\", or \"support\", in which case it will still be parsed as <code>str</code> or <code>float</code> tyeps, or you can enter any other name to store as a different feature name.</p>"},{"location":"parse_trees/#nhx-format","title":"NHX format\u00b6","text":"<p>The extended New Hampshire format (NHX) has emerged as a more recent and popular format for tree data storage (although unfortunately the precise rules for the format are not consistently followed). In addition to the standard information in Newick data provided by parentheses (topology) and edge lengths, any additional and arbitrary metadata can be stored within square brackets.</p> <p>The <code>toytree.tree()</code> function will automatically detect if square brackets are present in a Newick string and parse the associated metadata. It is important to note that different programs sometimes vary in the way that they store data inside of the square brackets, and so <code>toytree.tree</code> takes a number of additional optional arguments that can be entered to properly parse the NHX metadata. Below are some examples.</p> <p>Finally, NHX format has the advantage over Newick in that it can distinguish between data that is assigned to Nodes versus Edges in a tree. Data on edges, such as support values, are treated differently than data on nodes, such as trait values, when re-rooting trees (See Data/Features for more on this).</p>"},{"location":"parse_trees/#nexus-format","title":"NEXUS format\u00b6","text":"<p>The NEXUS format is popular in the field of phylogenetics because it provides a flexible format for storing a variety of information -- both data and instructions -- that can be used by multiple software tools. A NEXUS file starts with a \"#NEXUS\" header, and then contains one or more blocks delimited by \"begin\" and \"end;\" statements. For example, a \"data\" block would start with \"begin data\" and could contain morphological or molecular data. Another block might include code instructions for the mrbayes software, which takes a NEXUS file as input with instructions for an analysis. This could then write results to a \"trees\" block, which contains one or more Newick or NHX strings. In this way, a NEXUS file can fully describe an analysis from data -&gt; analysis -&gt; trees, as in the example below.</p> <p>For now, as far as <code>toytree</code> is concerned, only the \"trees\" block is of interest, and all other block are ignored. The <code>toytree.tree()</code> function will parse the tree data inside a NEXUS file just as it parses other Newick or NHX strings.</p>"},{"location":"parse_trees/#parsing-multitrees","title":"Parsing MultiTrees\u00b6","text":"<p>Sometimes data from multiple trees are stored together in a single file, such as the results of a bootstrap analysis, or a posterior distribution of trees from a Bayesian phylogenetic inference. <code>toytree</code> can parse and load all trees in a multiple tree input using the <code>toytree.mtree</code> function. This returns a <code>MultiTree</code> object (see MultiTree), which has methods that can apply to sets of trees, and from which individual <code>ToyTrees</code> can be indexed and extracted.</p>"},{"location":"parse_trees/#loading-trees-from-urls","title":"Loading trees from URLs\u00b6","text":"<p>A convenient feature of <code>toytree.tree</code> is the ability to laod tree data from a public URI. If you provide a string as input that begins with \"http\" then the str data of that URI will be checked for valid tree data. If so, it is returned as a tree. You can thus store your trees on any public site, such as a GitHub repo, and easily load it in without having to write out a long file path.</p>"},{"location":"pcm-fit-discrete/","title":"fit discrete traits","text":"In\u00a0[\u00a0]: Copied! <pre>import toytree\n\ntree = toytree.rtree.unittree(12, treeheight=1.0, seed=2)\n</pre> import toytree  tree = toytree.rtree.unittree(12, treeheight=1.0, seed=2)  In\u00a0[\u00a0]: Copied! <pre>traits = toytree.pcm.simulate_discrete_data(\n    tree=tree,\n    nstates=3,\n    model='ER',\n    nreplicates=1,\n    trait_name='state',\n    tips_only=True,\n)\nfit = tree.pcm.infer_ancestral_states_discrete_mk(\n    data=traits,\n    nstates=3,\n    model='ER',\n    inplace=False,\n)\nfit['model_fit']\n</pre> traits = toytree.pcm.simulate_discrete_data(     tree=tree,     nstates=3,     model='ER',     nreplicates=1,     trait_name='state',     tips_only=True, ) fit = tree.pcm.infer_ancestral_states_discrete_mk(     data=traits,     nstates=3,     model='ER',     inplace=False, ) fit['model_fit']  In\u00a0[\u00a0]: Copied! <pre>df = fit['data']\ndf.head()\n</pre> df = fit['data'] df.head()  In\u00a0[\u00a0]: Copied! <pre>cm = toytree.color.CMAPS['Set2'] if hasattr(toytree, 'color') else None\nstates = df['state_anc']\n# use a simple palette for three states\npalette = ['#4c78a8', '#f58518', '#54a24b']\nnode_colors = [palette[int(states[i])] if str(states[i]) != 'nan' else '#c7c7c7' for i in range(tree.nnodes)]\nc, a, m = tree.draw(layout='r', node_colors=node_colors, node_sizes=14, tip_labels=True, scale_bar=True)\nc\n</pre> cm = toytree.color.CMAPS['Set2'] if hasattr(toytree, 'color') else None states = df['state_anc'] # use a simple palette for three states palette = ['#4c78a8', '#f58518', '#54a24b'] node_colors = [palette[int(states[i])] if str(states[i]) != 'nan' else '#c7c7c7' for i in range(tree.nnodes)] c, a, m = tree.draw(layout='r', node_colors=node_colors, node_sizes=14, tip_labels=True, scale_bar=True) c  In\u00a0[\u00a0]: Copied! <pre># infer and store posterior probabilities on the tree\nout = tree.pcm.infer_ancestral_states_discrete_mk(\n    data=traits,\n    nstates=3,\n    model='ER',\n    inplace=True,\n)\nc, a, m = tree.draw(layout='d', tip_labels=True, scale_bar=True)\ntree.annotate.add_node_pie_markers(\n    a, 'state_anc_posterior', size=10, istroke_width=1, mask=False\n)\nc\n</pre> # infer and store posterior probabilities on the tree out = tree.pcm.infer_ancestral_states_discrete_mk(     data=traits,     nstates=3,     model='ER',     inplace=True, ) c, a, m = tree.draw(layout='d', tip_labels=True, scale_bar=True) tree.annotate.add_node_pie_markers(     a, 'state_anc_posterior', size=10, istroke_width=1, mask=False ) c  In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\n# Example: constrain relative rates (ARD)\nrates = np.array([[0, 2.0, 0.5], [1.0, 0, 0.2], [0.8, 1.5, 0]])\nfit_rates = tree.pcm.infer_ancestral_states_discrete_mk(\n    data=traits,\n    nstates=3,\n    model='ARD',\n    fixed_rates=rates,\n    inplace=False,\n)\nfit_rates['model_fit']\n</pre> import numpy as np  # Example: constrain relative rates (ARD) rates = np.array([[0, 2.0, 0.5], [1.0, 0, 0.2], [0.8, 1.5, 0]]) fit_rates = tree.pcm.infer_ancestral_states_discrete_mk(     data=traits,     nstates=3,     model='ARD',     fixed_rates=rates,     inplace=False, ) fit_rates['model_fit']  In\u00a0[\u00a0]: Copied! <pre># Example: constrain state frequencies\nfreqs = np.array([0.7, 0.2, 0.1])\nfit_freqs = tree.pcm.infer_ancestral_states_discrete_mk(\n    data=traits,\n    nstates=3,\n    model='ER',\n    fixed_state_frequencies=freqs,\n    inplace=False,\n)\nfit_freqs['model_fit']\n</pre> # Example: constrain state frequencies freqs = np.array([0.7, 0.2, 0.1]) fit_freqs = tree.pcm.infer_ancestral_states_discrete_mk(     data=traits,     nstates=3,     model='ER',     fixed_state_frequencies=freqs,     inplace=False, ) fit_freqs['model_fit']  In\u00a0[\u00a0]: Copied! <pre># Example: set a root prior\nroot_prior = np.array([0.05, 0.05, 0.90])\nfit_root = tree.pcm.infer_ancestral_states_discrete_mk(\n    data=traits,\n    nstates=3,\n    model='ER',\n    root_prior=root_prior,\n    inplace=False,\n)\nfit_root['model_fit']\n</pre> # Example: set a root prior root_prior = np.array([0.05, 0.05, 0.90]) fit_root = tree.pcm.infer_ancestral_states_discrete_mk(     data=traits,     nstates=3,     model='ER',     root_prior=root_prior,     inplace=False, ) fit_root['model_fit']  In\u00a0[\u00a0]: Copied! <pre># Example: scale overall rate\nfit_slow = tree.pcm.infer_ancestral_states_discrete_mk(\n    data=traits,\n    nstates=3,\n    model='ER',\n    rate_scalar=0.2,\n    inplace=False,\n)\nfit_fast = tree.pcm.infer_ancestral_states_discrete_mk(\n    data=traits,\n    nstates=3,\n    model='ER',\n    rate_scalar=2.0,\n    inplace=False,\n)\nfit_slow['model_fit']\nfit_fast['model_fit']\n</pre> # Example: scale overall rate fit_slow = tree.pcm.infer_ancestral_states_discrete_mk(     data=traits,     nstates=3,     model='ER',     rate_scalar=0.2,     inplace=False, ) fit_fast = tree.pcm.infer_ancestral_states_discrete_mk(     data=traits,     nstates=3,     model='ER',     rate_scalar=2.0,     inplace=False, ) fit_slow['model_fit'] fit_fast['model_fit']  In\u00a0[\u00a0]: Copied! <pre># Without fossil constraint\nbase = tree.pcm.infer_ancestral_states_discrete_mk(\n    data=traits,\n    nstates=3,\n    model='ER',\n    inplace=False,\n)\n\n# With a fossil constraint on an internal node\nfossil_series = traits.copy().reindex(range(tree.nnodes))\nfossil_series.loc[tree[-2]._idx] = 1\nfossil = tree.pcm.infer_ancestral_states_discrete_mk(\n    data=fossil_series,\n    nstates=3,\n    model='ER',\n    inplace=False,\n)\n\n# Plot a comparison of inferred states\npalette = ['#4c78a8', '#f58518', '#54a24b']\ndef plot_states(df, title):\n    states = df['state_anc']\n    node_colors = [palette[int(states[i])] if str(states[i]) != 'nan' else '#c7c7c7' for i in range(tree.nnodes)]\n    c, a, m = tree.draw(layout='r', node_colors=node_colors, node_sizes=12, tip_labels=True, scale_bar=True)\n    a.label.text = title\n    return c\n\nc_base = plot_states(base['data'], 'no fossil constraint')\nc_fossil = plot_states(fossil['data'], 'with fossil constraint')\nc_base\n</pre> # Without fossil constraint base = tree.pcm.infer_ancestral_states_discrete_mk(     data=traits,     nstates=3,     model='ER',     inplace=False, )  # With a fossil constraint on an internal node fossil_series = traits.copy().reindex(range(tree.nnodes)) fossil_series.loc[tree[-2]._idx] = 1 fossil = tree.pcm.infer_ancestral_states_discrete_mk(     data=fossil_series,     nstates=3,     model='ER',     inplace=False, )  # Plot a comparison of inferred states palette = ['#4c78a8', '#f58518', '#54a24b'] def plot_states(df, title):     states = df['state_anc']     node_colors = [palette[int(states[i])] if str(states[i]) != 'nan' else '#c7c7c7' for i in range(tree.nnodes)]     c, a, m = tree.draw(layout='r', node_colors=node_colors, node_sizes=12, tip_labels=True, scale_bar=True)     a.label.text = title     return c  c_base = plot_states(base['data'], 'no fossil constraint') c_fossil = plot_states(fossil['data'], 'with fossil constraint') c_base  In\u00a0[\u00a0]: Copied! <pre>c_fossil\n</pre> c_fossil"},{"location":"pcm-fit-discrete/#fitting-discrete-markov-models","title":"Fitting Discrete Markov Models\u00b6","text":"<p>This notebook demonstrates fitting discrete-state continuous-time Markov models and inferring ancestral states with <code>infer_ancestral_states_discrete_mk()</code>.</p>"},{"location":"pcm-fit-discrete/#simulate-tip-data-and-fit-a-model","title":"Simulate tip data and fit a model\u00b6","text":""},{"location":"pcm-fit-discrete/#inspect-inferred-states-and-probabilities","title":"Inspect inferred states and probabilities\u00b6","text":""},{"location":"pcm-fit-discrete/#plot-inferred-states-on-the-tree","title":"Plot inferred states on the tree\u00b6","text":""},{"location":"pcm-fit-discrete/#plot-posterior-probabilities-as-pie-markers","title":"Plot posterior probabilities as pie markers\u00b6","text":"<p>Use <code>add_node_pie_markers</code> with the posterior probabilities to visualize ancestral state uncertainty at each node.</p>"},{"location":"pcm-fit-discrete/#parameter-effects","title":"Parameter effects\u00b6","text":"<p>Below are short examples showing how key fitting parameters influence inference.</p>"},{"location":"pcm-fit-discrete/#fossil-constraints-with-vs-without","title":"Fossil constraints: with vs without\u00b6","text":"<p>Compare inference with and without internal-node observations.</p>"},{"location":"pcm-simulate-discrete/","title":"sim discrete traits","text":"<p>Full dataset (all nodes)</p> In\u00a0[\u00a0]: Copied! <pre># Plot full dataset (all nodes)\ncm = toyplot.color.brewer.map('Set2')\nvals = full_series.reindex(range(tree_full.nnodes)).astype(int).to_numpy()\nnode_colors = [cm.colors(v, 0, 2) for v in vals]\nc1, a1, m1 = tree_full.draw(layout='r', node_colors=node_colors, node_sizes=14, tip_labels=True, scale_bar=True)\nc1\n</pre> # Plot full dataset (all nodes) cm = toyplot.color.brewer.map('Set2') vals = full_series.reindex(range(tree_full.nnodes)).astype(int).to_numpy() node_colors = [cm.colors(v, 0, 2) for v in vals] c1, a1, m1 = tree_full.draw(layout='r', node_colors=node_colors, node_sizes=14, tip_labels=True, scale_bar=True) c1  <p>Tips-only dataset (internal nodes neutral)</p> In\u00a0[\u00a0]: Copied! <pre># Plot tips-only dataset (internal nodes neutral)\ncm = toyplot.color.brewer.map('Set2')\nneutral = '#c7c7c7'\ntip_vals = tips_series.to_dict()\ncolors2 = []\nfor node in tree_full:\n    if node.is_leaf():\n        colors2.append(cm.colors(int(tip_vals[node.name]), 0, 2))\n    else:\n        colors2.append(neutral)\nc2, a2, m2 = tree_full.draw(layout='r', node_colors=colors2, node_sizes=14, tip_labels=True, scale_bar=True)\nc2\n</pre> # Plot tips-only dataset (internal nodes neutral) cm = toyplot.color.brewer.map('Set2') neutral = '#c7c7c7' tip_vals = tips_series.to_dict() colors2 = [] for node in tree_full:     if node.is_leaf():         colors2.append(cm.colors(int(tip_vals[node.name]), 0, 2))     else:         colors2.append(neutral) c2, a2, m2 = tree_full.draw(layout='r', node_colors=colors2, node_sizes=14, tip_labels=True, scale_bar=True) c2  In\u00a0[\u00a0]: Copied! <pre>import toytree\n\ntree = toytree.rtree.unittree(12, seed=123)\n</pre> import toytree  tree = toytree.rtree.unittree(12, seed=123)  In\u00a0[\u00a0]: Copied! <pre>traits = toytree.pcm.simulate_discrete_data(\n    tree=tree,\n    nstates=3,\n    model='ER',\n    nreplicates=1,\n    trait_name='state',\n    tips_only=True,\n)\ntraits\n</pre> traits = toytree.pcm.simulate_discrete_data(     tree=tree,     nstates=3,     model='ER',     nreplicates=1,     trait_name='state',     tips_only=True, ) traits  <p>Plot the trait values by coloring tip labels.</p> In\u00a0[\u00a0]: Copied! <pre>color_map = {0: '#4c78a8', 1: '#f58518', 2: '#54a24b'}\ntip_colors = [color_map[traits[name]] for name in tree.get_tip_labels()]\nc, a, m = tree.draw(layout='r', tip_labels=True, tip_labels_colors=tip_colors, scale_bar=True)\nc\n</pre> color_map = {0: '#4c78a8', 1: '#f58518', 2: '#54a24b'} tip_colors = [color_map[traits[name]] for name in tree.get_tip_labels()] c, a, m = tree.draw(layout='r', tip_labels=True, tip_labels_colors=tip_colors, scale_bar=True) c  In\u00a0[\u00a0]: Copied! <pre>tree2 = toytree.rtree.unittree(8, seed=7)\ntoytree.pcm.simulate_discrete_data(\n    tree=tree2,\n    nstates=2,\n    model='ER',\n    nreplicates=1,\n    trait_name='state',\n    tips_only=True,\n    inplace=True,\n)\n# Access stored feature values\ntree2.get_node_data('state').head()\n</pre> tree2 = toytree.rtree.unittree(8, seed=7) toytree.pcm.simulate_discrete_data(     tree=tree2,     nstates=2,     model='ER',     nreplicates=1,     trait_name='state',     tips_only=True,     inplace=True, ) # Access stored feature values tree2.get_node_data('state').head()  In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\ntree_param = toytree.rtree.unittree(10, seed=999)\n\n# 1) relative_rates: favor transitions 0-&gt;1 over 1-&gt;0\nrates = np.array([[0, 3.0], [0.5, 0]])\ntraits_rates = toytree.pcm.simulate_discrete_data(\n    tree=tree_param,\n    nstates=2,\n    model='ARD',\n    relative_rates=rates,\n    nreplicates=1,\n    trait_name='rate_bias',\n    tips_only=True,\n)\n\n# 2) state_frequencies: favor state 0 at equilibrium\nfreqs = np.array([0.8, 0.2])\ntraits_freq = toytree.pcm.simulate_discrete_data(\n    tree=tree_param,\n    nstates=2,\n    model='ER',\n    state_frequencies=freqs,\n    nreplicates=1,\n    trait_name='freq_bias',\n    tips_only=True,\n)\n\n# 3) root_state: fix the root to state 1\ntraits_root = toytree.pcm.simulate_discrete_data(\n    tree=tree_param,\n    nstates=2,\n    model='ER',\n    root_state=1,\n    nreplicates=1,\n    trait_name='root_fixed',\n    tips_only=True,\n)\n\n# 4) rate_scalar: compare slow vs fast rates\ntraits_slow = toytree.pcm.simulate_discrete_data(\n    tree=tree_param,\n    nstates=2,\n    model='ER',\n    rate_scalar=0.2,\n    nreplicates=1,\n    trait_name='slow',\n    tips_only=True,\n)\ntraits_fast = toytree.pcm.simulate_discrete_data(\n    tree=tree_param,\n    nstates=2,\n    model='ER',\n    rate_scalar=3.0,\n    nreplicates=1,\n    trait_name='fast',\n    tips_only=True,\n)\n\ntraits_rates.head(), traits_freq.head(), traits_root.head(), traits_slow.head(), traits_fast.head()\n</pre> import numpy as np  tree_param = toytree.rtree.unittree(10, seed=999)  # 1) relative_rates: favor transitions 0-&gt;1 over 1-&gt;0 rates = np.array([[0, 3.0], [0.5, 0]]) traits_rates = toytree.pcm.simulate_discrete_data(     tree=tree_param,     nstates=2,     model='ARD',     relative_rates=rates,     nreplicates=1,     trait_name='rate_bias',     tips_only=True, )  # 2) state_frequencies: favor state 0 at equilibrium freqs = np.array([0.8, 0.2]) traits_freq = toytree.pcm.simulate_discrete_data(     tree=tree_param,     nstates=2,     model='ER',     state_frequencies=freqs,     nreplicates=1,     trait_name='freq_bias',     tips_only=True, )  # 3) root_state: fix the root to state 1 traits_root = toytree.pcm.simulate_discrete_data(     tree=tree_param,     nstates=2,     model='ER',     root_state=1,     nreplicates=1,     trait_name='root_fixed',     tips_only=True, )  # 4) rate_scalar: compare slow vs fast rates traits_slow = toytree.pcm.simulate_discrete_data(     tree=tree_param,     nstates=2,     model='ER',     rate_scalar=0.2,     nreplicates=1,     trait_name='slow',     tips_only=True, ) traits_fast = toytree.pcm.simulate_discrete_data(     tree=tree_param,     nstates=2,     model='ER',     rate_scalar=3.0,     nreplicates=1,     trait_name='fast',     tips_only=True, )  traits_rates.head(), traits_freq.head(), traits_root.head(), traits_slow.head(), traits_fast.head()  In\u00a0[\u00a0]: Copied! <pre>cm2 = toyplot.color.brewer.map('Set2')\n\ndef plot_tip_trait(trait_series, title):\n    colors = [cm2.colors(int(trait_series[name]), 0, 1) for name in tree_param.get_tip_labels()]\n    c, a, m = tree_param.draw(layout='r', tip_labels=True, tip_labels_colors=colors, scale_bar=True)\n    a.label.text = title\n    return c\n</pre> cm2 = toyplot.color.brewer.map('Set2')  def plot_tip_trait(trait_series, title):     colors = [cm2.colors(int(trait_series[name]), 0, 1) for name in tree_param.get_tip_labels()]     c, a, m = tree_param.draw(layout='r', tip_labels=True, tip_labels_colors=colors, scale_bar=True)     a.label.text = title     return c  In\u00a0[\u00a0]: Copied! <pre>c_rate = plot_tip_trait(traits_rates, 'relative_rates bias')\nc_rate\n</pre> c_rate = plot_tip_trait(traits_rates, 'relative_rates bias') c_rate  In\u00a0[\u00a0]: Copied! <pre>c_freq = plot_tip_trait(traits_freq, 'state_frequencies bias')\nc_freq\n</pre> c_freq = plot_tip_trait(traits_freq, 'state_frequencies bias') c_freq  In\u00a0[\u00a0]: Copied! <pre>c_root = plot_tip_trait(traits_root, 'root_state fixed')\nc_root\n</pre> c_root = plot_tip_trait(traits_root, 'root_state fixed') c_root  In\u00a0[\u00a0]: Copied! <pre>c_slow = plot_tip_trait(traits_slow, 'rate_scalar slow')\nc_slow\n</pre> c_slow = plot_tip_trait(traits_slow, 'rate_scalar slow') c_slow  In\u00a0[\u00a0]: Copied! <pre>c_fast = plot_tip_trait(traits_fast, 'rate_scalar fast')\nc_fast\n</pre> c_fast = plot_tip_trait(traits_fast, 'rate_scalar fast') c_fast  In\u00a0[\u00a0]: Copied! <pre>traits_multi = toytree.pcm.simulate_discrete_data(\n    tree=tree,\n    nstates=2,\n    model='SYM',\n    nreplicates=3,\n    trait_name='trait',\n    tips_only=True,\n)\ntraits_multi.head()\n</pre> traits_multi = toytree.pcm.simulate_discrete_data(     tree=tree,     nstates=2,     model='SYM',     nreplicates=3,     trait_name='trait',     tips_only=True, ) traits_multi.head()"},{"location":"pcm-simulate-discrete/#simulating-discrete-traits-markov-model","title":"Simulating Discrete Traits (Markov Model)\u00b6","text":"<p>This notebook demonstrates <code>toytree.pcm.simulate_discrete_data()</code> for single and multiple replicates, including trait naming and plotting the result on a tree.</p>"},{"location":"pcm-simulate-discrete/#continuous-time-markov-models","title":"Continuous-time Markov models\u00b6","text":"<p><code>simulate_discrete_data()</code> uses a continuous-time Markov chain (CTMC) to model transitions among a fixed number of discrete states along each branch. The model is defined by an instantaneous rate matrix Q where each off-diagonal entry <code>q_ij</code> is the rate of change from state i to state j. Diagonal entries are set so each row sums to zero, and transition probabilities over time t are computed as <code>P(t) = expm(Q * t)</code>.</p> <p>Supported model types differ in how Q is parameterized:</p> <ul> <li>ER (equal rates): all off-diagonal rates are the same value. This is the simplest model and assumes every state changes to every other state at the same rate.</li> <li>SYM (symmetric rates): rates are symmetric (<code>q_ij = q_ji</code>), but different state pairs can have different rates. This allows variation among pairs while keeping reversibility.</li> <li>ARD (all rates different): every off-diagonal rate can be different (<code>q_ij</code> and <code>q_ji</code> may differ). This is the most flexible model, allowing directional biases between states.</li> </ul> <p>In all cases, you can provide <code>relative_rates</code> and <code>state_frequencies</code> explicitly, or let <code>toytree</code> sample valid parameters for the chosen model. The <code>rate_scalar</code> multiplies the relative rates to set the overall tempo of change.</p>"},{"location":"pcm-simulate-discrete/#full-vs-tips-only-datasets","title":"Full vs tips-only datasets\u00b6","text":"<p>Empirical datasets typically include observations only at the tips (extant taxa), which corresponds to <code>tips_only=True</code>. Simulations can also return full datasets that include internal nodes, which is useful for validating methods.</p>"},{"location":"pcm-simulate-discrete/#plot-trait-values-on-nodes","title":"Plot trait values on nodes\u00b6","text":"<p>Below we color nodes by a discrete trait using a categorical colormap. For tips-only data, internal nodes are left in a neutral color.</p>"},{"location":"pcm-simulate-discrete/#single-trait-returns-series","title":"Single trait (returns Series)\u00b6","text":"<p>When <code>nreplicates</code> is 1 (or less), the function returns a <code>pd.Series</code>.</p>"},{"location":"pcm-simulate-discrete/#inplace-storage","title":"Inplace storage\u00b6","text":"<p>If <code>inplace=True</code>, the simulated trait(s) are stored on the tree as node features instead of being returned.</p>"},{"location":"pcm-simulate-discrete/#model-parameters-and-their-effects","title":"Model parameters and their effects\u00b6","text":"<p>The parameters below control the Markov model and simulation:</p> <ul> <li><code>relative_rates</code>: Off-diagonal entries of Q. Larger values increase transition frequency between specific state pairs.</li> <li><code>state_frequencies</code>: Stationary frequencies (equilibrium proportions) that influence long-run state occupancy and, for reversible models, how rates are scaled among states.</li> <li><code>root_state</code>: Fixes the starting state at the root. This biases the entire simulation toward descendants of that root state.</li> <li><code>rate_scalar</code>: Multiplies the relative rates, controlling the overall tempo of evolution (higher values -&gt; more changes).</li> </ul>"},{"location":"pcm-simulate-discrete/#visual-comparison","title":"Visual comparison\u00b6","text":"<p>Below we color tips for each scenario to visualize the effect of parameter changes.</p>"},{"location":"pcm-simulate-discrete/#multiple-replicates-returns-dataframe","title":"Multiple replicates (returns DataFrame)\u00b6","text":"<p>When <code>nreplicates</code> is greater than 1, the function returns a <code>pd.DataFrame</code> with one column per replicate.</p>"},{"location":"phylogenetic_signal/","title":"phylogenetic-signal","text":"In\u00a0[188]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np In\u00a0[189]: Copied! <pre># generate a random tree\ntree = toytree.rtree.unittree(ntips=60, treeheight=1.0, seed=123)\n\n# generate a trait value under BM model and store to tree\ntraits = tree.pcm.simulate_continuous_bm(rates={\"trait\": 1.0}, seed=123, tips_only=True)\n\n# generate a random uniform value as measurement error\ntraits[\"se\"] = np.random.default_rng(seed=123).uniform(0, 1e-1, size=tree.ntips)\n\n# show the first few values\ntraits.head(10)\n</pre> # generate a random tree tree = toytree.rtree.unittree(ntips=60, treeheight=1.0, seed=123)  # generate a trait value under BM model and store to tree traits = tree.pcm.simulate_continuous_bm(rates={\"trait\": 1.0}, seed=123, tips_only=True)  # generate a random uniform value as measurement error traits[\"se\"] = np.random.default_rng(seed=123).uniform(0, 1e-1, size=tree.ntips)  # show the first few values traits.head(10) Out[189]: trait se 0 -0.593520 0.068235 1 -0.736497 0.005382 2 0.737992 0.022036 3 -0.485426 0.018437 4 -1.606551 0.017591 5 -0.319333 0.081209 6 -1.023654 0.092334 7 0.905526 0.027657 8 0.714016 0.081975 9 0.110878 0.088989 <p>Let's visualize the trait and se.</p> In\u00a0[191]: Copied! <pre># draw tree with extra space reserved to the right \ncanvas, axes, mark = tree.draw(layout='d', height=350, label=\"Example tree w/ trait and se\");\n\n# draw traits color mapped\ncolors = toytree.style.get_color_mapped_values(traits[\"trait\"], \"Greys\")\ntree.annotate.add_tip_markers(axes, marker=\"s\", yshift=45, color=colors);\ncolors = toytree.style.get_color_mapped_values(traits[\"se\"], \"Greys\")\ntree.annotate.add_tip_markers(axes, marker=\"s\", yshift=60, color=colors);\n</pre> # draw tree with extra space reserved to the right  canvas, axes, mark = tree.draw(layout='d', height=350, label=\"Example tree w/ trait and se\");  # draw traits color mapped colors = toytree.style.get_color_mapped_values(traits[\"trait\"], \"Greys\") tree.annotate.add_tip_markers(axes, marker=\"s\", yshift=45, color=colors); colors = toytree.style.get_color_mapped_values(traits[\"se\"], \"Greys\") tree.annotate.add_tip_markers(axes, marker=\"s\", yshift=60, color=colors); r0r1r2r3r4r5r6r7r8r9r10r11r12r13r14r15r16r17r18r19r20r21r22r23r24r25r26r27r28r29r30r31r32r33r34r35r36r37r38r39r40r41r42r43r44r45r46r47r48r49r50r51r52r53r54r55r56r57r58r59Example tree w/ trait and se In\u00a0[193]: Copied! <pre># measure K for BM trait 't0'\ntoytree.pcm.phylogenetic_signal_k(tree, traits[\"trait\"], nsims=0)\n</pre> # measure K for BM trait 't0' toytree.pcm.phylogenetic_signal_k(tree, traits[\"trait\"], nsims=0) Out[193]: <pre>{'K': 0.813631398963683, 'P-value': nan, 'permutations': nan}</pre> In\u00a0[194]: Copied! <pre># measure K for non-BM trait 't2'\ntoytree.pcm.phylogenetic_signal_k(tree, traits[\"se\"], nsims=0)\n</pre> # measure K for non-BM trait 't2' toytree.pcm.phylogenetic_signal_k(tree, traits[\"se\"], nsims=0) Out[194]: <pre>{'K': 0.48043536702811224, 'P-value': nan, 'permutations': nan}</pre> In\u00a0[197]: Copied! <pre># measure K and perform significance test\ntoytree.pcm.phylogenetic_signal_k(tree, traits[\"trait\"], nsims=1000)\n</pre> # measure K and perform significance test toytree.pcm.phylogenetic_signal_k(tree, traits[\"trait\"], nsims=1000) Out[197]: <pre>{'K': 0.813631398963683, 'P-value': 0.001, 'permutations': 1000}</pre> In\u00a0[198]: Copied! <pre># measure K and perform significance test\ntoytree.pcm.phylogenetic_signal_k(tree, traits[\"se\"], nsims=1000)\n</pre> # measure K and perform significance test toytree.pcm.phylogenetic_signal_k(tree, traits[\"se\"], nsims=1000) Out[198]: <pre>{'K': 0.48043536702811224, 'P-value': 0.202, 'permutations': 1000}</pre> In\u00a0[199]: Copied! <pre># measure K for trait w/ standard error and perform significance test\ntoytree.pcm.phylogenetic_signal_k(tree, data=traits[\"trait\"], error=traits[\"se\"], nsims=1000)\n</pre> # measure K for trait w/ standard error and perform significance test toytree.pcm.phylogenetic_signal_k(tree, data=traits[\"trait\"], error=traits[\"se\"], nsims=1000) Out[199]: <pre>{'K': 0.8168893422998975,\n 'P-value': 0.0,\n 'permutations': 1000,\n 'log-likelihood': -30.497738879932697,\n 'sig2': 0.2952762091848135,\n 'convergence': True}</pre> In\u00a0[200]: Copied! <pre>toytree.pcm.phylogenetic_signal_lambda(tree, traits[\"trait\"], intervals=20)\n</pre> toytree.pcm.phylogenetic_signal_lambda(tree, traits[\"trait\"], intervals=20) Out[200]: <pre>{'lambda': 1.0819649326447975,\n 'P-value': 7.004273033171038e-07,\n 'LR_test': 24.613953274584404,\n 'log-likelihood_\u03bb': 26.40277320446915,\n 'log-likelihood_\u03bb0': 38.70974984176135}</pre> In\u00a0[187]: Copied! <pre>toytree.pcm.phylogenetic_signal_lambda(tree, traits[\"trait\"], error=traits[\"se\"])\n</pre> toytree.pcm.phylogenetic_signal_lambda(tree, traits[\"trait\"], error=traits[\"se\"]) Out[187]: <pre>{'lambda': 1.0833333333323334,\n 'P-value': 2.187112884895932e-06,\n 'LR_test': 22.42324190223958,\n 'log-likelihood_\u03bb': 27.61266023558629,\n 'log-likelihood_\u03bb0': 38.82428118670608,\n 'sig2': 0.3301921997179848}</pre> In\u00a0[\u00a0]: Copied! <pre># TODO...\n</pre> # TODO..."},{"location":"phylogenetic_signal/#phylogenetic-signal","title":"Phylogenetic signal\u00b6","text":"<p>Several metrics are available to measure \"phylogenetic signal\" in a trait value among the tips of a phylogeny. These metrics test the extent to which traits exhibit phylogenetic inertia, such that their values can be explained by a random walk (Brownian motion model of evolution) along the edges of a tree. A trait exhibiting low phylogenetic signal is poorly explained by the this model and the specified tree, whereas a trait exhibiting high phylogenetic signal fits well to this model of evolution on the tree.</p> <p>Here we show how to measure Blomberg's K and Pagel's lambda.</p>"},{"location":"phylogenetic_signal/#example-data","title":"Example data\u00b6","text":"<p>Let's simulate some test data. We generate a random tree with uniform internal edge lengths and then simulate one continuous trait (\"t0\") under the Brownian motion (BM) model. In addition, we generate an array to represent standard  error (\"se\") in the trait value, drawn as random uniform values. We expect \"t0\" to exhibit phylogenetic signal, while \"se\" will not. We will also test whether trait \"t0\" exhibits phylogenetic signal while taking into account the standard error within species.</p>"},{"location":"phylogenetic_signal/#blombergs-k","title":"Blomberg's K\u00b6","text":"<p>Blomberg's K (Blomberg et al. 2003) is used to quantify phylogenetic signal relative in trait evolution relative to a Brownian motion model. Values of K&gt;1 indicate samples are less similar than expected, whereas K&lt;1 indicates that they are more similar than expected. Permutations can be used to perform a significance test.</p>"},{"location":"phylogenetic_signal/#example","title":"Example\u00b6","text":"<p>As an example, when K is calculated for the trait \"t0\" that was simulated under a model of Brownian motion we recover a K statistic close to 1.0. By contrast, when K is calculated for \"se\" which is composed of uniform random values we get a much lower K. We can say that the phylogenetic signal in \"t0\" is greater than for \"se\". However, the K value alone does not yet tell us whether this is different from a random expectation given the data.</p>"},{"location":"phylogenetic_signal/#significance-test","title":"Significance test\u00b6","text":"<p>We can perform a permutation test to calculate the probability that the phylogenetic signal in a trait value is greater than expected by chance given the tree and variance in the trait data. This shuffles the trait values among the tips and recalculates K many times. The P-value represents the number of permutations that generate a K value with as much phylogenetic signal as the original trait data. A P-value &lt; 0.05 is typically considered significance evidence of phylogenetic signal. The default option is to perform 1000 permutations to calculate P.</p>"},{"location":"phylogenetic_signal/#measurement-error","title":"Measurement error\u00b6","text":"<p>If a trait is measured from many individuals then you can measure both its mean and standard error, and the latter can be taken into account when calculating phylogenetic signal (Ives et al. 2007). Here a model is fit to estimate the Brownian rate parameter ($\\sigma^2$), which is also returned along with the log-likelihood.</p>"},{"location":"phylogenetic_signal/#pagels","title":"Pagel's \u03bb\u00b6","text":"<p>TODO: Pagel's lambda ... TODO: Link to lambda transformation method.</p>"},{"location":"phylogenetic_signal/#example","title":"Example\u00b6","text":"<p>The method <code>phylogenetic_signal_lambda</code> estimates the optimal lambda transformation of the tree to fit the data.  A significance test is performed by comparing the log-likelihood of the fit model to the log-likelihood of a model with lambda=0. A likelihood ratio test...</p>"},{"location":"phylogenetic_signal/#measurement-error","title":"Measurement error\u00b6","text":"<p>If a trait is measured from many individuals then you can represent its value as both a mean and standard error, and the standard error can be taken into account when calculating lambda.</p>"},{"location":"phylogenetic_signal/#multivariate-k","title":"Multivariate K\u00b6","text":"<p>Adams...</p>"},{"location":"quadripartitions/","title":"quadripartition methods","text":"In\u00a0[24]: Copied! <pre>import toytree  \n\n#define tree with simple Newick string\nnewick = \"((a,b)X,((c,d)Y,e)Z)R;\" \ntree = toytree.tree(newick)  \n\ntree.draw('r'); #draw tree in R-style\n\n#iteratively return all quadripartitions in phylogenetic tree\nfor q in toytree.enum.iter_quadripartitions(tree):\n    print(q)\n</pre> import toytree    #define tree with simple Newick string newick = \"((a,b)X,((c,d)Y,e)Z)R;\"  tree = toytree.tree(newick)    tree.draw('r'); #draw tree in R-style  #iteratively return all quadripartitions in phylogenetic tree for q in toytree.enum.iter_quadripartitions(tree):     print(q) <pre>(({'a'}, {'b'}), ({'d', 'c'}, {'e'}))\n(({'c'}, {'d'}), ({'e'}, {'b', 'a'}))\n</pre> XYZRabcde <p>In this example, the only internal edges available to make quadripartitions from are the edges directly above <code>Y</code> and <code>Z</code> (or <code>X</code>, but it has the same result as <code>Z</code>). These two quadripartitions are given in tuples of tuples of sets to denotate the first (tuple) and second (sets) bipartitions that create the quadripartition.</p> In\u00a0[25]: Copied! <pre>#build tree from simple newick string and visualize it\ntree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\") \ntree.draw()\n\n#return quadripartitions as list, with each partition returned in a tuple (instead of a set), including the internal nodes of each partition\nunordered = list(tree.enum.iter_quadripartitions(type=tuple, \n                                                 include_internal_nodes=True, \n                                                 feature=\"idx\"))\nordered = list(tree.enum.iter_quadripartitions(type=tuple, \n                                               include_internal_nodes=True, \n                                               feature=\"idx\", \n                                               sort=True))\nprint(unordered)\nprint(ordered)\n</pre> #build tree from simple newick string and visualize it tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\")  tree.draw()  #return quadripartitions as list, with each partition returned in a tuple (instead of a set), including the internal nodes of each partition unordered = list(tree.enum.iter_quadripartitions(type=tuple,                                                   include_internal_nodes=True,                                                   feature=\"idx\")) ordered = list(tree.enum.iter_quadripartitions(type=tuple,                                                 include_internal_nodes=True,                                                 feature=\"idx\",                                                 sort=True)) print(unordered) print(ordered) <pre>[(((2,), (3,)), ((4, 5, 7), (0, 1))), (((4,), (5,)), ((2, 3, 6), (0, 1))), (((2, 3, 6), (4, 5, 7)), ((0,), (1,)))]\n[(((2,), (3,)), ((0, 1), (4, 5, 7))), (((4,), (5,)), ((0, 1), (2, 3, 6))), (((0,), (1,)), ((2, 3, 6), (4, 5, 7)))]\n</pre> abcdef <p>The user can also choose to return more or less information about each quadripartition, ranging from all tips and internal nodes using <code>include_internal_nodes=True</code>, to only the stems of each partition (<code>contract_partitions=True</code>). To specify what information is returned, use the <code>feature=</code> argument with any available Node feature.</p> In\u00a0[26]: Copied! <pre>import toytree  \n\n#define tree with simple Newick string\nnewick = \"((alfred,bob)Xiang,((cindy,david)Yasmin,ellis)Zoro)Randy;\" \ntree = toytree.tree(newick)  \n\ntree.draw('r'); #draw tree in R-style\n\n\nfor q in toytree.enum.iter_quadripartitions(tree, \n                                            include_internal_nodes=True, \n                                            feature=\"name\"):\n    print(q)\n</pre> import toytree    #define tree with simple Newick string newick = \"((alfred,bob)Xiang,((cindy,david)Yasmin,ellis)Zoro)Randy;\"  tree = toytree.tree(newick)    tree.draw('r'); #draw tree in R-style   for q in toytree.enum.iter_quadripartitions(tree,                                              include_internal_nodes=True,                                              feature=\"name\"):     print(q) <pre>(({'alfred'}, {'bob'}), ({'david', 'Yasmin', 'cindy'}, {'ellis'}))\n(({'cindy'}, {'david'}), ({'ellis'}, {'bob', 'Xiang', 'alfred'}))\n</pre> XiangYasminZoroRandyalfredbobcindydavidellis In\u00a0[27]: Copied! <pre>import toytree  \n\n#define tree with simple Newick string\nnewick = \"((alfred,bob)Xiang,((cindy,david)Yasmin,ellis)Zoro)Randy;\" \ntree = toytree.tree(newick)  \n\ntree.draw('r'); #draw tree in R-style\n\n\nfor q in toytree.enum.iter_quadripartitions(tree, \n                                            contract_partitions=True, \n                                            feature=\"idx\", \n                                            sort=True):\n    print(q)\n</pre> import toytree    #define tree with simple Newick string newick = \"((alfred,bob)Xiang,((cindy,david)Yasmin,ellis)Zoro)Randy;\"  tree = toytree.tree(newick)    tree.draw('r'); #draw tree in R-style   for q in toytree.enum.iter_quadripartitions(tree,                                              contract_partitions=True,                                              feature=\"idx\",                                              sort=True):     print(q) <pre>(({0}, {1}), ({6}, {4}))\n(({2}, {3}), ({7}, {4}))\n</pre> XiangYasminZoroRandyalfredbobcindydavidellis <p>Both of these quadripartition sets represent the same quadripartitions from the same tree, just expressed in different formats.</p>"},{"location":"quadripartitions/#quadripartition-methods","title":"Quadripartition methods\u00b6","text":"<p>The <code>iter_quadripartitions()</code> function in the <code>.enum</code> subpackage returns all possible quadripartitions of a tree. Quadripartitions are defined by an internal <code>focal edge</code>, from which the tree is split into four partitions. Each partition stems from the children of the 2 nodes on either side of the <code>focal edge</code>. The quadripartitions are yielded in Node idxorder traversal in a nested format: a tuple of two tuples of two sets, e.g. <code>(({e0},{e1}), ({e2},{e3}))</code>, with the contents representing the tip Nodes descending from each of the four partition stems. In this example, <code>e0</code> through <code>e3</code> are the partition stems and are each children of the nodes being split along the <code>focal edge</code>. The order in which the partitions of a particular quadripartition are ordered is (child-left, child-right, sister, up) in relation to the Node directly below the <code>focal edge</code>.</p> <p>Note: Sets are used by default, which means when there are multiple nodes in a partition, they will not be sorted. This can be modified by using an ordered datatype like <code>type=tuple</code> or <code>type=list</code>. This will sort the nodes in alphabetical or index order (depending on whether <code>feature=\"name\"</code> or <code>feature=\"idx\"</code>.)</p>"},{"location":"quadripartitions/#simple-example","title":"Simple example\u00b6","text":""},{"location":"quadripartitions/#sorting-and-formatting","title":"Sorting and formatting\u00b6","text":"<p>When <code>type=</code> is set to an ordered datatype (i.e. tuple, list), <code>iter_quadripartitions</code> will automatically sort the values within each partition. The user can choose to sort the quadripartition further, ordering each partition within its bipartitions and each bipartition within its quadripartition, by using <code>sort=True</code>. This first orders them in size order (small to large), and if the sizes are equal, then by the lowest value Node present.</p>"},{"location":"quadripartitions/#example","title":"Example\u00b6","text":""},{"location":"quadripartitions/#lots-of-information","title":"Lots of information\u00b6","text":""},{"location":"quadripartitions/#little-information","title":"Little information\u00b6","text":""},{"location":"quartets/","title":"quartet methods","text":"<p><code>Toytree</code> objects can yield quartets, which are 4-sample subtrees that are the minimal information unit in the context of comparative phylogenetics. Being the simplest format of informative unrooted tree, quartets are important for phylogenetic tree reconstruction and are often the main ingredient in optimization algorithms\u2020. The <code>iter_quartets</code> method provides a fast option to yield quartet subtrees from a larger tree. It includes options for sorting the output and allows the user to return the subtrees as <code>Node</code> objects, names, or any arvitrary feature of Nodes.</p> <p><code>Iter_quartets</code> yields all quartets (4-sample subtrees) that exist within a larger tree. The set of possible quartets is not affected by tree rooting, but is affected by collapsed edges (polytomies), which reduce the number of quartets. Quartets are returned as a tuple with sets representing the relation among samples: tuple( set{} , set{} ), Quartets can also be collapsed using <code>collapse=True</code>, which returns an ordered collection of the requested features of Nodes, where e.g. ('a', 'b', 'c', 'd') implies the quartet <code>ab|cd</code>.</p> <p>\u2020Alon, Noga, Sagi Snir, and Raphael Yuster. \u201cOn the Compatibility of Quartet Trees,\u201d n.d.</p> In\u00a0[36]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[37]: Copied! <pre>#build tree from simple newick string and visualize it\ntree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\") \ntree.draw()\n#iteratively return all quartets in phylogenetic tree\nfor quartet in tree.iter_quartets(): \n    print(quartet)\n</pre> #build tree from simple newick string and visualize it tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\")  tree.draw() #iteratively return all quartets in phylogenetic tree for quartet in tree.iter_quartets():      print(quartet) <pre>({'c', 'd'}, {'a', 'e'})\n({'c', 'd'}, {'b', 'e'})\n({'c', 'd'}, {'e', 'f'})\n({'c', 'd'}, {'b', 'a'})\n({'c', 'd'}, {'a', 'f'})\n({'c', 'd'}, {'b', 'f'})\n({'e', 'f'}, {'a', 'd'})\n({'e', 'f'}, {'b', 'a'})\n({'e', 'f'}, {'a', 'c'})\n({'e', 'f'}, {'b', 'd'})\n({'e', 'f'}, {'b', 'c'})\n({'c', 'e'}, {'b', 'a'})\n({'c', 'f'}, {'b', 'a'})\n({'e', 'd'}, {'b', 'a'})\n({'f', 'd'}, {'b', 'a'})\n</pre> abcdef In\u00a0[38]: Copied! <pre>tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\")\n#return quartets with nodes being represented by their indices\nfor quartet in tree.iter_quartets(feature = 'idx'):\n    print(quartet)\n</pre> tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\") #return quartets with nodes being represented by their indices for quartet in tree.iter_quartets(feature = 'idx'):     print(quartet) <pre>({2, 3}, {0, 4})\n({2, 3}, {1, 4})\n({2, 3}, {4, 5})\n({2, 3}, {0, 1})\n({2, 3}, {0, 5})\n({2, 3}, {1, 5})\n({4, 5}, {0, 3})\n({4, 5}, {0, 1})\n({4, 5}, {0, 2})\n({4, 5}, {1, 3})\n({4, 5}, {1, 2})\n({2, 4}, {0, 1})\n({2, 5}, {0, 1})\n({3, 4}, {0, 1})\n({3, 5}, {0, 1})\n</pre> In\u00a0[39]: Copied! <pre>tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\")\n#(attempt to) collapse the returned quartets\nfor quartet in tree.iter_quartets(collapse=True):\n    print(quartet)\n</pre> tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\") #(attempt to) collapse the returned quartets for quartet in tree.iter_quartets(collapse=True):     print(quartet) <pre>\u26a0\ufe0f toytree | quartets:iter_quartets | collapse argument cannot be used with type=set, using collapse=False\n</pre> <pre>({'c', 'd'}, {'a', 'e'})\n({'c', 'd'}, {'b', 'e'})\n({'c', 'd'}, {'e', 'f'})\n({'c', 'd'}, {'b', 'a'})\n({'c', 'd'}, {'a', 'f'})\n({'c', 'd'}, {'b', 'f'})\n({'e', 'f'}, {'a', 'd'})\n({'e', 'f'}, {'b', 'a'})\n({'e', 'f'}, {'a', 'c'})\n({'e', 'f'}, {'b', 'd'})\n({'e', 'f'}, {'b', 'c'})\n({'c', 'e'}, {'b', 'a'})\n({'c', 'f'}, {'b', 'a'})\n({'e', 'd'}, {'b', 'a'})\n({'f', 'd'}, {'b', 'a'})\n</pre> <p>Note: Since sets are unordered, collapse cannot be used if the quartets are returned as sets (default <code>type=set</code>) because the relationship information is lost.</p> In\u00a0[40]: Copied! <pre>tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\")\n#collapse the returned quartets to return each as single tuple (order determines split)\nfor quartet in tree.iter_quartets(type=tuple, collapse=True):\n    print(quartet)\n\n#(c,d|a,d)\n#(c,d|b,e)\n# etc.\n</pre> tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\") #collapse the returned quartets to return each as single tuple (order determines split) for quartet in tree.iter_quartets(type=tuple, collapse=True):     print(quartet)  #(c,d|a,d) #(c,d|b,e) # etc. <pre>('c', 'd', 'a', 'e')\n('c', 'd', 'b', 'e')\n('c', 'd', 'e', 'f')\n('c', 'd', 'a', 'b')\n('c', 'd', 'a', 'f')\n('c', 'd', 'b', 'f')\n('e', 'f', 'a', 'd')\n('e', 'f', 'a', 'b')\n('e', 'f', 'a', 'c')\n('e', 'f', 'b', 'd')\n('e', 'f', 'b', 'c')\n('c', 'e', 'a', 'b')\n('c', 'f', 'a', 'b')\n('d', 'e', 'a', 'b')\n('d', 'f', 'a', 'b')\n</pre> In\u00a0[41]: Copied! <pre>tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\")\n#return quartets iteratively as sorted tuples (sorts both within and between)\nfor quartet in tree.iter_quartets(type=tuple, sort=True):\n    print(quartet)\n</pre> tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\") #return quartets iteratively as sorted tuples (sorts both within and between) for quartet in tree.iter_quartets(type=tuple, sort=True):     print(quartet) <pre>(('a', 'e'), ('c', 'd'))\n(('b', 'e'), ('c', 'd'))\n(('c', 'd'), ('e', 'f'))\n(('a', 'b'), ('c', 'd'))\n(('a', 'f'), ('c', 'd'))\n(('b', 'f'), ('c', 'd'))\n(('a', 'd'), ('e', 'f'))\n(('a', 'b'), ('e', 'f'))\n(('a', 'c'), ('e', 'f'))\n(('b', 'd'), ('e', 'f'))\n(('b', 'c'), ('e', 'f'))\n(('a', 'b'), ('c', 'e'))\n(('a', 'b'), ('c', 'f'))\n(('a', 'b'), ('d', 'e'))\n(('a', 'b'), ('d', 'f'))\n</pre> In\u00a0[42]: Copied! <pre>tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\")\ntree.draw()\n#create a full, sorted list of quartets\nno_filter = list(tree.iter_quartets(type=list, sort=True))\n\n#and a sorted list of only quartets induced by quadripartite splits\nfilter = list(tree.iter_quartets(type=list, sort=True, quadripartitions=True))\n\nprint(no_filter)\nprint(\"\")\nprint(filter)\n</pre> tree = toytree.tree(\"(a,b,((c,d)CD,(e,f)EF)X)AB;\") tree.draw() #create a full, sorted list of quartets no_filter = list(tree.iter_quartets(type=list, sort=True))  #and a sorted list of only quartets induced by quadripartite splits filter = list(tree.iter_quartets(type=list, sort=True, quadripartitions=True))  print(no_filter) print(\"\") print(filter) <pre>[(['a', 'e'], ['c', 'd']), (['b', 'e'], ['c', 'd']), (['c', 'd'], ['e', 'f']), (['a', 'b'], ['c', 'd']), (['a', 'f'], ['c', 'd']), (['b', 'f'], ['c', 'd']), (['a', 'd'], ['e', 'f']), (['a', 'b'], ['e', 'f']), (['a', 'c'], ['e', 'f']), (['b', 'd'], ['e', 'f']), (['b', 'c'], ['e', 'f']), (['a', 'b'], ['c', 'e']), (['a', 'b'], ['c', 'f']), (['a', 'b'], ['d', 'e']), (['a', 'b'], ['d', 'f'])]\n\n[(['a', 'e'], ['c', 'd']), (['b', 'e'], ['c', 'd']), (['a', 'f'], ['c', 'd']), (['b', 'f'], ['c', 'd']), (['a', 'd'], ['e', 'f']), (['b', 'd'], ['e', 'f']), (['a', 'c'], ['e', 'f']), (['b', 'c'], ['e', 'f']), (['a', 'b'], ['d', 'e']), (['a', 'b'], ['d', 'f']), (['a', 'b'], ['c', 'e']), (['a', 'b'], ['c', 'f'])]\n</pre> abcdef"},{"location":"quartets/#quartet-methods","title":"Quartet methods\u00b6","text":""},{"location":"quartets/#quick-example","title":"Quick example\u00b6","text":""},{"location":"quartets/#sorting","title":"Sorting\u00b6","text":"<p>The order of the items within each partition of the quartet is not often of interest, but a sort option is included in case it is useful. The order in which the nodes and pairs of a quartet are returned depends on the topology and rooting, and is in <code>Node idx</code> traversal order, where the first two Nodes are below the edge, and the second two above. This can be changed to a consistent name sorted order for each split partition using <code>sort=True</code>. If <code>sort=True</code>, partitions are always sorted alphanumerically within and between partitions (the order in which the quartets themselves are yielded remains the same)</p>"},{"location":"quartets/#quadripartite-filter","title":"Quadripartite filter\u00b6","text":"<p>If <code>quadripatition=True</code>, then quartets are only returned that are induced by quadripartitite splits in a the tree. This is a subset of the vquartets induced by bipartitions, since the tip Nodes must comefrom four different clades from each edge/split.</p>"},{"location":"query/","title":"node query/selection","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># load a toytree from a newick string at a URL and root it\ntree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\").root(\"~prz\")\n</pre> # load a toytree from a newick string at a URL and root it tree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\").root(\"~prz\") In\u00a0[3]: Copied! <pre># draw tree showing the idx labels representing the cached idxorder traversal\ntree.draw('s');\n</pre> # draw tree showing the idx labels representing the cached idxorder traversal tree.draw('s'); 012345678910111213141516171819202122232432082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides <p>Nodes can selected from a <code>ToyTree</code> by indexing, slicing by idx label.</p> In\u00a0[4]: Copied! <pre># select a single node by idx\ntree[1]\n</pre> # select a single node by idx tree[1] Out[4]: <pre>&lt;Node(idx=1, name='33588_przewalskii')&gt;</pre> In\u00a0[5]: Copied! <pre># select a slice of nodes by idx\ntree[3:5]\n</pre> # select a slice of nodes by idx tree[3:5] Out[5]: <pre>[&lt;Node(idx=3, name='30556_thamno')&gt;, &lt;Node(idx=4, name='40578_rex')&gt;]</pre> In\u00a0[6]: Copied! <pre># select a list of nodes by idx\ntree[[3, 4, 8, 9]]\n</pre> # select a list of nodes by idx tree[[3, 4, 8, 9]] Out[6]: <pre>[&lt;Node(idx=3, name='30556_thamno')&gt;,\n &lt;Node(idx=4, name='40578_rex')&gt;,\n &lt;Node(idx=8, name='38362_rex')&gt;,\n &lt;Node(idx=9, name='29154_superba')&gt;]</pre> In\u00a0[7]: Copied! <pre># select all tip (leaf) nodes by slicing\ntree[:tree.ntips]\n</pre> # select all tip (leaf) nodes by slicing tree[:tree.ntips] Out[7]: <pre>[&lt;Node(idx=0, name='32082_przewalskii')&gt;,\n &lt;Node(idx=1, name='33588_przewalskii')&gt;,\n &lt;Node(idx=2, name='33413_thamno')&gt;,\n &lt;Node(idx=3, name='30556_thamno')&gt;,\n &lt;Node(idx=4, name='40578_rex')&gt;,\n &lt;Node(idx=5, name='35855_rex')&gt;,\n &lt;Node(idx=6, name='35236_rex')&gt;,\n &lt;Node(idx=7, name='39618_rex')&gt;,\n &lt;Node(idx=8, name='38362_rex')&gt;,\n &lt;Node(idx=9, name='29154_superba')&gt;,\n &lt;Node(idx=10, name='30686_cyathophylla')&gt;,\n &lt;Node(idx=11, name='41954_cyathophylloides')&gt;,\n &lt;Node(idx=12, name='41478_cyathophylloides')&gt;]</pre> In\u00a0[8]: Copied! <pre># select all internal nodes by slicing\ntree[tree.ntips:tree.nnodes]\n</pre> # select all internal nodes by slicing tree[tree.ntips:tree.nnodes] Out[8]: <pre>[&lt;Node(idx=13)&gt;,\n &lt;Node(idx=14)&gt;,\n &lt;Node(idx=15)&gt;,\n &lt;Node(idx=16)&gt;,\n &lt;Node(idx=17)&gt;,\n &lt;Node(idx=18)&gt;,\n &lt;Node(idx=19)&gt;,\n &lt;Node(idx=20)&gt;,\n &lt;Node(idx=21)&gt;,\n &lt;Node(idx=22)&gt;,\n &lt;Node(idx=23)&gt;,\n &lt;Node(idx=24, name='root')&gt;]</pre> In\u00a0[9]: Copied! <pre># select the root node\ntree[-1]\n</pre> # select the root node tree[-1] Out[9]: <pre>&lt;Node(idx=24, name='root')&gt;</pre> In\u00a0[10]: Copied! <pre># select one node by name\ntree.get_nodes(\"40578_rex\")\n</pre> # select one node by name tree.get_nodes(\"40578_rex\") Out[10]: <pre>[&lt;Node(idx=4, name='40578_rex')&gt;]</pre> In\u00a0[11]: Copied! <pre># select multiple nodes by name\ntree.get_nodes(\"40578_rex\", \"38362_rex\")\n</pre> # select multiple nodes by name tree.get_nodes(\"40578_rex\", \"38362_rex\") Out[11]: <pre>[&lt;Node(idx=4, name='40578_rex')&gt;, &lt;Node(idx=8, name='38362_rex')&gt;]</pre> In\u00a0[12]: Copied! <pre># match any node name containing 'prz'\ntree.get_nodes(\"~prz\")\n</pre> # match any node name containing 'prz' tree.get_nodes(\"~prz\") Out[12]: <pre>[&lt;Node(idx=1, name='33588_przewalskii')&gt;,\n &lt;Node(idx=0, name='32082_przewalskii')&gt;]</pre> In\u00a0[13]: Copied! <pre># match any node name containing 855\ntree.get_nodes(\"~855\")\n</pre> # match any node name containing 855 tree.get_nodes(\"~855\") Out[13]: <pre>[&lt;Node(idx=5, name='35855_rex')&gt;]</pre> In\u00a0[14]: Copied! <pre># match any node name starting with a 4\ntree.get_nodes(\"~^4\")\n</pre> # match any node name starting with a 4 tree.get_nodes(\"~^4\") Out[14]: <pre>[&lt;Node(idx=11, name='41954_cyathophylloides')&gt;,\n &lt;Node(idx=4, name='40578_rex')&gt;,\n &lt;Node(idx=12, name='41478_cyathophylloides')&gt;]</pre> In\u00a0[15]: Copied! <pre># match any node name ending with an 'a'\ntree.get_nodes(\"~a$\")\n</pre> # match any node name ending with an 'a' tree.get_nodes(\"~a$\") Out[15]: <pre>[&lt;Node(idx=9, name='29154_superba')&gt;,\n &lt;Node(idx=10, name='30686_cyathophylla')&gt;]</pre> In\u00a0[16]: Copied! <pre># match name containing a 3 followed by 8 or 9 then any chars followed by 'rex'\ntree.get_nodes(\"~3[8,9].+rex\")\n</pre> # match name containing a 3 followed by 8 or 9 then any chars followed by 'rex' tree.get_nodes(\"~3[8,9].+rex\") Out[16]: <pre>[&lt;Node(idx=7, name='39618_rex')&gt;, &lt;Node(idx=8, name='38362_rex')&gt;]</pre> In\u00a0[17]: Copied! <pre># select nodes by int idx labels, or by str names, or multiple by ~regex, or Node\ntree.get_nodes(0, 1, '40578_rex', tree[8])\n</pre> # select nodes by int idx labels, or by str names, or multiple by ~regex, or Node tree.get_nodes(0, 1, '40578_rex', tree[8]) Out[17]: <pre>[&lt;Node(idx=4, name='40578_rex')&gt;,\n &lt;Node(idx=1, name='33588_przewalskii')&gt;,\n &lt;Node(idx=8, name='38362_rex')&gt;,\n &lt;Node(idx=0, name='32082_przewalskii')&gt;]</pre> In\u00a0[18]: Copied! <pre># if you already know its idx (e.g., by tree visualization) you can index it\ntree[17]\n</pre> # if you already know its idx (e.g., by tree visualization) you can index it tree[17] Out[18]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[19]: Copied! <pre># or, you can find the mrca by knowing the tip node idxs\ntree.get_mrca_node(4, 5, 6, 7, 8)\n</pre> # or, you can find the mrca by knowing the tip node idxs tree.get_mrca_node(4, 5, 6, 7, 8) Out[19]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[20]: Copied! <pre># you actually only need to provide the minimal spanning nodes\ntree.get_mrca_node(4, 8)\n</pre> # you actually only need to provide the minimal spanning nodes tree.get_mrca_node(4, 8) Out[20]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[21]: Copied! <pre># safer, however, is to enter node names, since these never change\ntree.get_mrca_node(\"35855_rex\", \"40578_rex\", \"39618_rex\", \"35236_rex\", \"38362_rex\")\n</pre> # safer, however, is to enter node names, since these never change tree.get_mrca_node(\"35855_rex\", \"40578_rex\", \"39618_rex\", \"35236_rex\", \"38362_rex\") Out[21]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[22]: Copied! <pre># again, you only need to enter the minimal required\ntree.get_mrca_node(\"35855_rex\", \"38362_rex\")\n</pre> # again, you only need to enter the minimal required tree.get_mrca_node(\"35855_rex\", \"38362_rex\") Out[22]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[23]: Copied! <pre># simpler, use a regular expression to match all names with 'rex'\ntree.get_mrca_node(\"~rex\")\n</pre> # simpler, use a regular expression to match all names with 'rex' tree.get_mrca_node(\"~rex\") Out[23]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[24]: Copied! <pre>%%timeit\n# time to select a tip node by its idx (superfast)\ntree[7]\n</pre> %%timeit # time to select a tip node by its idx (superfast) tree[7] <pre>152 ns \u00b1 1.8 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n</pre> In\u00a0[25]: Copied! <pre>%%timeit\n# time to select a tip node by its name\ntree.get_nodes(\"39618_rex\")\n</pre> %%timeit # time to select a tip node by its name tree.get_nodes(\"39618_rex\") <pre>10.8 \u00b5s \u00b1 36.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</pre> In\u00a0[26]: Copied! <pre>%%timeit\n# time to select an internal node (17) by its known index\ntree[17]\n</pre> %%timeit # time to select an internal node (17) by its known index tree[17] <pre>156 ns \u00b1 0.887 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n</pre> In\u00a0[27]: Copied! <pre>%%timeit\n# time to find mrca (17) by mrca of idx labels\ntree.get_mrca_node(4, 8)\n</pre> %%timeit # time to find mrca (17) by mrca of idx labels tree.get_mrca_node(4, 8) <pre>27.6 \u00b5s \u00b1 338 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> In\u00a0[28]: Copied! <pre>%%timeit\n# time to find mrca (17) by mrca of name labels\ntree.get_mrca_node(\"~rex\")\n</pre> %%timeit # time to find mrca (17) by mrca of name labels tree.get_mrca_node(\"~rex\") <pre>63.4 \u00b5s \u00b1 267 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> In\u00a0[29]: Copied! <pre>tree.mod.root(\"~prz\").draw();\n</pre> tree.mod.root(\"~prz\").draw(); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[30]: Copied! <pre># drop all 'rex' samples\ntree.mod.drop_tips(\"~rex*\").draw();\n</pre> # drop all 'rex' samples tree.mod.drop_tips(\"~rex*\").draw(); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[31]: Copied! <pre># keep only the subtree connecting 'rex' samples\ntree.mod.prune(\"~rex*\").draw();\n</pre> # keep only the subtree connecting 'rex' samples tree.mod.prune(\"~rex*\").draw(); 40578_rex35855_rex35236_rex39618_rex38362_rex"},{"location":"query/#node-queryselection","title":"Node query/selection\u00b6","text":"<p>Many methods in <code>toytree</code> require selecting one or more nodes from a tree to operate on. This can often be challenging since most nodes in a tree usually do not have unique names assigned to them, and selecting nodes by a numeric indexing method can be error-prone if the indices change. We have tried to design the node query and selection methods in <code>toytree</code> to be maximally flexible to allow for ease-of-use when selecting nodes while also trying to prevent users from making simple and common mistakes.</p>"},{"location":"query/#select-nodes-by-index-idx","title":"Select Nodes by index (idx)\u00b6","text":"<p>The simplest and fastest approach to get <code>Node</code> objects from a ToyTree is to select them by their <code>idx</code> label. In fact, the storage of Nodes in a cached traversal order for fast recall is one of the main advantages of the ToyTree class. The tip nodes are intuitively labeled from left to right (or bottom to top, depending on the tree orientation) as idx labels from 0 to ntips - 1, and the root node is at idx label nnodes - 1.</p>"},{"location":"query/#select-nodes-by-name","title":"Select Nodes by name\u00b6","text":"<p>To select nodes by name you can use the <code>get_nodes</code> function. This is most useful for selecting tip nodes, since these are often the only nodes that have unique names, whereas internal nodes usually have empty name attributes. Internal nodes can be queried by using their idx labels, or, as demonstrated below, they can be selected based on tip names by using the function <code>get_mrca_node</code>.</p>"},{"location":"query/#using-regular-expressions","title":"Using regular expressions ~\u00b6","text":"<p>Regular expressions are a sequence of characters that match a pattern, and are often used in search algorithms. In <code>toytree</code> there are many functions which optionally accept regular expressions as an input to allow for easily selecting multiple nodes. This can be used because the operation is intended to operate on each of these nodes individually (e.g., <code>toytree.mod.drop_tips</code>) or because the operation will find the most recent common ancestor of the input nodes and operate on that edge or subtree (e.g., <code>toytree.mod.root</code>, or <code>toytree.mod.extract_subtree</code>; see below).</p> <p>All of these functions that accept name strings as input use the <code>get_nodes</code> function under the hood to find the matched nodes, and so our demonstrations below will use this function. In addition to accepting one or more individual name strings this function can also accept regular expressions as input.</p> <p>To indicate that an entry should be treated as a regular expression use the <code>~</code> prefix. It will then use the Python standard library regular expression function <code>re.search()</code> to find any nodes that match this query.</p>"},{"location":"query/#node-queries","title":"Node queries\u00b6","text":"<p>We define a query as a flexible type of input used to match one or more nodes. For functions which accept a query as input, an <code>int</code> will be treated as a Node idx label, whereas a <code>str</code> will be treated as a Node <code>name</code>, and a <code>str</code> starting with a <code>~</code> will be treated as a regular expression. These functions can also accept a <code>Node</code> object as an input. You can even mix these arguments to select multiple nodes.</p>"},{"location":"query/#get_nodes","title":"<code>get_nodes()</code>\u00b6","text":"<p>The function <code>get_nodes</code> is used widely both by users as well as internally by other functions. It takes <code>*query</code> as input meaning that it accepts any number of queries as input.</p>"},{"location":"query/#get_mrca_node","title":"<code>get_mrca_node()</code>\u00b6","text":"<p>Many tree operations require selecting an internal node to operate on. For example, rooting a tree on a clade. This is easiest done by selecting two tip nodes by name for which the internal node target is the most recent common ancestor (mrca), and providing these as entries to the <code>get_mrca_node</code> function. This function accepts query arguments the same way as <code>get_nodes</code>, accepting int, str, or <code>~</code>regex entries.</p> <p>Consider the example below where wish to find the internal node that is the mrca of the five tip nodes in the example tree forming the \"rex\" clade. We can select this node in several ways:</p>"},{"location":"query/#efficiencyspeed","title":"Efficiency/speed\u00b6","text":"<p>Because matching nodes by name requires traversing over all nodes in the tree to find matches it is much slower than selecting nodes by indexing with idx labels. All of the methods are still pretty fast, the time difference only matters when writing very time-intensive code. This is demonstrated simply below.</p>"},{"location":"query/#best-practices","title":"Best practices\u00b6","text":"<p>There are many situations in which you know the tree structure will not change, and thus indexing by node idx is faster and much preferred to slower name selection. Especially when you are selecting the tip or root nodes, which have obvious numeric labels. However, in other cases it is preferable to use names when selecting nodes, such as when adding traits or labels to internal nodes for tree drawings, since it makes your code more readable and explicit.</p>"},{"location":"query/#node-queries-are-everywhere","title":"Node Queries are everywhere\u00b6","text":"<p>You will find that many functions in <code>toytree</code> accept query type inputs that are used to match nodes following the node query methods described above. These are especially common in the <code>toytree.mod</code> subpackage.</p>"},{"location":"quick_guide/","title":"Quick Guide","text":"In\u00a0[1]: Copied! <pre>import toytree\ntoytree.__version__\n</pre> import toytree toytree.__version__ Out[1]: <pre>'3.0.7'</pre> In\u00a0[2]: Copied! <pre># load a toytree from a newick string at a URL\nutree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")\n\n# re-root on internal edge selected using a regex string\nrtree = utree.root(\"~prz\")\n\n# draw the rooted tree\nrtree.draw(node_hover=True, node_sizes=8, tip_labels_align=True);\n</pre> # load a toytree from a newick string at a URL utree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")  # re-root on internal edge selected using a regex string rtree = utree.root(\"~prz\")  # draw the rooted tree rtree.draw(node_hover=True, node_sizes=8, tip_labels_align=True); idx: 13 dist: 0.0179371130487 support: 100 height: 0.0152107514239 name: idx: 14 dist: 0.00222999650239 support: 100 height: 0.00577636172318 name: idx: 15 dist: 0.00617527349892 support: 100 height: 0.00109218434613 name: idx: 16 dist: 0.000738900380519 support: 96 height: 0.00726745784506 name: idx: 17 dist: 0.000783365499905 support: 99 height: 0.00800635822557 name: idx: 18 dist: 0.00103379657491 support: 100 height: 0.00878972372548 name: idx: 19 dist: 0.00538723112355 support: 100 height: 0.00982352030039 name: idx: 20 dist: 0.00237994755604 support: 100 height: 0.00985454237589 name: idx: 21 dist: 0.00941020878048 support: 100 height: 0.00282428115145 name: idx: 22 dist: 0.00297626149201 support: 100 height: 0.0122344899319 name: idx: 23 dist: 0.0179371130487 support: 100 height: 0.0152107514239 name: idx: 24 dist: 0 support: nan height: 0.0331478644727 name: root32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[3]: Copied! <pre># newick str with edge-lengths &amp; support values\nnewick = \"((a:1,b:1)90:3,(c:3,(d:1,e:1)100:2)100:1);\"\n\n# load as ToyTree\ntree = toytree.tree(newick)\n\n# show tree data parsed from Newick str\ntree.get_node_data()\n</pre> # newick str with edge-lengths &amp; support values newick = \"((a:1,b:1)90:3,(c:3,(d:1,e:1)100:2)100:1);\"  # load as ToyTree tree = toytree.tree(newick)  # show tree data parsed from Newick str tree.get_node_data() Out[3]: idx name height dist support 0 0 a 0.0 1.0 NaN 1 1 b 0.0 1.0 NaN 2 2 c 0.0 3.0 NaN 3 3 d 0.0 1.0 NaN 4 4 e 0.0 1.0 NaN 5 5 1.0 3.0 90.0 6 6 1.0 2.0 100.0 7 7 3.0 1.0 100.0 8 8 4.0 0.0 NaN <p>The data that make up a tree can be easily accessed in a number of ways, including during tree visualization. Here a number of options are provided to the <code>.draw()</code> function to style the drawing. The \"node_labels\" option is set to \"idx\", which matches one of the features in the tree data, and so the data (numeric labels) are mapped to the appropriate nodes in the tree. Similarly, the \"edge_colors\" option is set to \"dist\" which automatically applies a colormapping to values of the \"dist\" data in the tree. This approach of assigning data to Nodes of the tree and then mapping these values to a drawing is more secure than trying to correctly order and enter values as a list. See Data/Features for more details.</p> In\u00a0[4]: Copied! <pre># tree drawing showing Node idx labels and edges colored by dist\ntree.draw(\n    layout='d', \n    node_labels=\"idx\", node_sizes=15, node_mask=False, node_colors=\"lightgrey\",\n    edge_colors=\"dist\", edge_widths=3,\n    tip_labels_style={\"font-size\": 20, \"anchor-shift\": 20},\n    scale_bar=True,\n);\n</pre> # tree drawing showing Node idx labels and edges colored by dist tree.draw(     layout='d',      node_labels=\"idx\", node_sizes=15, node_mask=False, node_colors=\"lightgrey\",     edge_colors=\"dist\", edge_widths=3,     tip_labels_style={\"font-size\": 20, \"anchor-shift\": 20},     scale_bar=True, ); 012345678abcde01234 <p>Node: See the Node class documentation. Users primarily interact with Node objects by selecting them from a tree through indexing, slicing, or traversal methods. Nodes are used to store the basic data that makes up a tree, such as the connections between nodes and their distances. In addition, nodes can be used to store any additional arbitrary data. Each <code>Node</code> in a <code>ToyTree</code> has a unique ID assigned to it referred to as its <code>idx</code> label, and which represents its order in a tip-to-root traversal of the tree (see Traversal and Node selection).</p> In\u00a0[5]: Copied! <pre># you can create a Node object on its own\ntoytree.Node(name=\"X\")\n</pre> # you can create a Node object on its own toytree.Node(name=\"X\") Out[5]: <pre>&lt;Node(name='X')&gt;</pre> In\u00a0[6]: Copied! <pre># but more often you will select Nodes from a tree by slicing or indexing\ntree[0]\n</pre> # but more often you will select Nodes from a tree by slicing or indexing tree[0] Out[6]: <pre>&lt;Node(idx=0, name='a')&gt;</pre> In\u00a0[7]: Copied! <pre># a Node's parent is at .up\ntree[0].up\n</pre> # a Node's parent is at .up tree[0].up Out[7]: <pre>&lt;Node(idx=5)&gt;</pre> In\u00a0[8]: Copied! <pre># a Node's children are at .children\ntree[5].children\n</pre> # a Node's children are at .children tree[5].children Out[8]: <pre>(&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=1, name='b')&gt;)</pre> In\u00a0[9]: Copied! <pre># select one or more Nodes from a ToyTree by name\ntree.get_nodes(\"a\", \"c\")\n</pre> # select one or more Nodes from a ToyTree by name tree.get_nodes(\"a\", \"c\") Out[9]: <pre>[&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=2, name='c')&gt;]</pre> In\u00a0[10]: Copied! <pre># access data from attributes of a Node in a ToyTree\ntree[0].idx, tree[0].name, tree[0].dist\n</pre> # access data from attributes of a Node in a ToyTree tree[0].idx, tree[0].name, tree[0].dist Out[10]: <pre>(0, 'a', 1.0)</pre> <p>ToyTree: See the ToyTree class documentation. A <code>ToyTree</code> stores a cached representation of the connections among a set of <code>Node</code> objects in memory and contains numerous methods for operating on these data. As we saw above, <code>ToyTree</code> class objects are usually created by parsing tree data from newick strings. However, a <code>ToyTree</code> can also be created by passing a <code>Node</code> object as the root of a new tree, as shown below. This makes clear that a <code>ToyTree</code> is a container for <code>Node</code> objects. They also contain functions for modifying the connections and data of nodes such as rooting trees, pruning, grafting, modifying edge lengths or support values, and storing new data, to name a few. If an operation changes the tree structure the <code>ToyTree</code> will automatically store a new cached representation of the tree traversal, assigning new <code>idx</code> labels to nodes. This allows for very fast retrieval of information from nodes, and to store cached tree attributes that are emergent properties of the collection of tree, such as node heights, and the number of tips and nodes.</p> In\u00a0[11]: Copied! <pre># create a tree from a Node object to serve as its root Node\ntoytree.ToyTree(toytree.Node(\"root\"))\n</pre> # create a tree from a Node object to serve as its root Node toytree.ToyTree(toytree.Node(\"root\")) Out[11]: <pre>&lt;toytree.ToyTree at 0x7cba07714770&gt;</pre> In\u00a0[12]: Copied! <pre># parse a tree from newick data\ntoytree.tree(\"((a,b),c);\")\n</pre> # parse a tree from newick data toytree.tree(\"((a,b),c);\") Out[12]: <pre>&lt;toytree.ToyTree at 0x7cba07715b20&gt;</pre> In\u00a0[13]: Copied! <pre>tree.ntips\n</pre> tree.ntips Out[13]: <pre>5</pre> In\u00a0[14]: Copied! <pre>tree.nnodes\n</pre> tree.nnodes Out[14]: <pre>9</pre> In\u00a0[15]: Copied! <pre>tree[5].height\n</pre> tree[5].height Out[15]: <pre>1.0</pre> In\u00a0[16]: Copied! <pre># all nodes in the cached idx order (tips first then postorder traversal)\ntree[:]\n</pre> # all nodes in the cached idx order (tips first then postorder traversal) tree[:] Out[16]: <pre>[&lt;Node(idx=0, name='a')&gt;,\n &lt;Node(idx=1, name='b')&gt;,\n &lt;Node(idx=2, name='c')&gt;,\n &lt;Node(idx=3, name='d')&gt;,\n &lt;Node(idx=4, name='e')&gt;,\n &lt;Node(idx=5)&gt;,\n &lt;Node(idx=6)&gt;,\n &lt;Node(idx=7)&gt;,\n &lt;Node(idx=8)&gt;]</pre> In\u00a0[17]: Copied! <pre># or, use .traverse() to visit Nodes in other traversal orders\nlist(tree.traverse(\"postorder\"))\n</pre> # or, use .traverse() to visit Nodes in other traversal orders list(tree.traverse(\"postorder\")) Out[17]: <pre>[&lt;Node(idx=0, name='a')&gt;,\n &lt;Node(idx=1, name='b')&gt;,\n &lt;Node(idx=5)&gt;,\n &lt;Node(idx=2, name='c')&gt;,\n &lt;Node(idx=3, name='d')&gt;,\n &lt;Node(idx=4, name='e')&gt;,\n &lt;Node(idx=6)&gt;,\n &lt;Node(idx=7)&gt;,\n &lt;Node(idx=8)&gt;]</pre> <p>MultiTree: See the MultiTree documentation. A <code>MultiTree</code> object is a container type for multiple <code>ToyTree</code> objects. It has a number of attributes and methods specific to operating on and visualizing sets of trees. The <code>toytree.mtree()</code> function can be used to parse multiple input types similar to the <code>toytree.tree()</code> method for parsing trees from data for individual trees. Also, <code>toytree.MultiTree()</code> can accept a collection of <code>ToyTree</code> objects as input, demonstrating that multitrees are collections of trees.</p> In\u00a0[18]: Copied! <pre># create a MultiTree containing three copies of 'tree' rooted differently\nmtree = toytree.mtree([tree, tree.root('c'), tree.root('d', 'e')])\nmtree\n</pre> # create a MultiTree containing three copies of 'tree' rooted differently mtree = toytree.mtree([tree, tree.root('c'), tree.root('d', 'e')]) mtree Out[18]: <pre>&lt;toytree.MultiTree ntrees=3&gt;</pre> In\u00a0[19]: Copied! <pre># select individual ToyTrees by indexing or slicing\nmtree[0]\n</pre> # select individual ToyTrees by indexing or slicing mtree[0] Out[19]: <pre>&lt;toytree.ToyTree at 0x7cba109ee480&gt;</pre> In\u00a0[20]: Copied! <pre># visualization methods for multiple trees. Takes similar arguments as ToyTree.draw()\nmtree.draw(tip_labels_style={\"font-size\": 16});\n</pre> # visualization methods for multiple trees. Takes similar arguments as ToyTree.draw() mtree.draw(tip_labels_style={\"font-size\": 16}); abcdecdeabdecab In\u00a0[21]: Copied! <pre>tree.copy()\n</pre> tree.copy() Out[21]: <pre>&lt;toytree.ToyTree at 0x7cba07734530&gt;</pre> In\u00a0[22]: Copied! <pre>tree.is_rooted()\n</pre> tree.is_rooted() Out[22]: <pre>True</pre> In\u00a0[23]: Copied! <pre>tree.is_monophyletic(\"a\", \"b\")\n</pre> tree.is_monophyletic(\"a\", \"b\") Out[23]: <pre>True</pre> In\u00a0[24]: Copied! <pre>tree.get_ancestors(\"a\")\n</pre> tree.get_ancestors(\"a\") Out[24]: <pre>{&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=5)&gt;, &lt;Node(idx=8)&gt;}</pre> In\u00a0[25]: Copied! <pre>tree.get_mrca_node(\"d\", \"e\")\n</pre> tree.get_mrca_node(\"d\", \"e\") Out[25]: <pre>&lt;Node(idx=6)&gt;</pre> In\u00a0[26]: Copied! <pre>tree.get_tip_labels()\n</pre> tree.get_tip_labels() Out[26]: <pre>['a', 'b', 'c', 'd', 'e']</pre> In\u00a0[27]: Copied! <pre># select nodes by name\ntree.get_nodes(\"a\", \"b\")\n</pre> # select nodes by name tree.get_nodes(\"a\", \"b\") Out[27]: <pre>[&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=1, name='b')&gt;]</pre> In\u00a0[28]: Copied! <pre># select nodes by regular expression\ntree.get_nodes(\"~[a-c]\")\n</pre> # select nodes by regular expression tree.get_nodes(\"~[a-c]\") Out[28]: <pre>[&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=2, name='c')&gt;, &lt;Node(idx=1, name='b')&gt;]</pre> In\u00a0[29]: Copied! <pre># select internal node by mrca of tip names\ntree.get_mrca_node(\"a\", \"b\")\n</pre> # select internal node by mrca of tip names tree.get_mrca_node(\"a\", \"b\") Out[29]: <pre>&lt;Node(idx=5)&gt;</pre> In\u00a0[30]: Copied! <pre># or, select a node directly by its idx label\ntree[5]\n</pre> # or, select a node directly by its idx label tree[5] Out[30]: <pre>&lt;Node(idx=5)&gt;</pre> <p>rtree: Random tree generation functions. The <code>rtree</code> subpackage provides a variety of algorithms for generating random trees that can be used for learning, testing, or analyses. For example, random, balanced, imbalanced, birth-death, coalescent, and other forms of trees can be generated with a variety of options for setting data on the trees.</p> In\u00a0[31]: Copied! <pre># generate a birth-death tree\nbtree = toytree.rtree.bdtree(ntips=8, b=1, d=0.1, seed=123, random_names=True)\nbtree.draw(scale_bar=True);\n</pre> # generate a birth-death tree btree = toytree.rtree.bdtree(ntips=8, b=1, d=0.1, seed=123, random_names=True) btree.draw(scale_bar=True); r6r1r3r0r2r5r4r721.510.50 <p>enum: enumeration of tree data. Many algorithms for working with trees involve analyzing and comparing subsets of trees, such as bipartitions or quartets created by edges, or require knowing the number of possible trees of a given size. The <code>enum</code> subpackage provides a number of exact calculations, or generator functions, for accessing these data efficiently with a variety of formatting options. These methods are particularly useful for implementing or testing tree analysis methods.</p> In\u00a0[32]: Copied! <pre># expand a generator over all quartets in a tree\nlist(toytree.enum.iter_quartets(tree))\n</pre> # expand a generator over all quartets in a tree list(toytree.enum.iter_quartets(tree)) Out[32]: <pre>[({'a', 'b'}, {'d', 'e'}),\n ({'a', 'b'}, {'c', 'e'}),\n ({'a', 'b'}, {'c', 'd'}),\n ({'d', 'e'}, {'a', 'c'}),\n ({'d', 'e'}, {'b', 'c'})]</pre> <p>distance: node and tree distance metrics. Distances are a common type of measurement associated with trees, either in the form of measuring distances between nodes in a single tree, or comparing two or more trees using metrics of their (dis)similarity. A variety of methods for measuring node and tree distances are available in the <code>distance</code> subpackage.</p> In\u00a0[33]: Copied! <pre># return a matrix of distances between tips in a tree\ntoytree.distance.get_tip_distance_matrix(tree, df=True)\n</pre> # return a matrix of distances between tips in a tree toytree.distance.get_tip_distance_matrix(tree, df=True) Out[33]: a b c d e a 0.0 2.0 8.0 8.0 8.0 b 2.0 0.0 8.0 8.0 8.0 c 8.0 8.0 0.0 6.0 6.0 d 8.0 8.0 6.0 0.0 2.0 e 8.0 8.0 6.0 2.0 0.0 In\u00a0[34]: Copied! <pre># return the Robinson-Foulds tree distance between two random 10-tip trees\nrtree1 = toytree.rtree.rtree(10, seed=123)\nrtree2 = toytree.rtree.rtree(10, seed=321)\ntoytree.distance.get_treedist_rf(rtree1, rtree2, normalize=True)\n</pre> # return the Robinson-Foulds tree distance between two random 10-tip trees rtree1 = toytree.rtree.rtree(10, seed=123) rtree2 = toytree.rtree.rtree(10, seed=321) toytree.distance.get_treedist_rf(rtree1, rtree2, normalize=True) Out[34]: <pre>0.8571428571428571</pre> <p>mod: Tree modifications. Methods for manipulating and modifying tree data can be used to generate new trees, change the structure or data contained in a tree, and to store new data in trees. This is currently the largest subpackage with many common tree manipulation algorithms implemented.</p> In\u00a0[35]: Copied! <pre># return a tree with edges scaled so root is at height=100\nmodified = toytree.mod.edges_scale_to_root_height(tree, 100)\n\n# show the original and modified trees side by side\ntoytree.mtree([tree, modified]).draw(scale_bar=True);\n</pre> # return a tree with edges scaled so root is at height=100 modified = toytree.mod.edges_scale_to_root_height(tree, 100)  # show the original and modified trees side by side toytree.mtree([tree, modified]).draw(scale_bar=True); abcde43210abcde100500 In\u00a0[36]: Copied! <pre># return a tree with a new split (internal node and child) added\nmodified = toytree.mod.add_internal_node_and_child(tree, \"d\", name=\"x\")\n\n# show the original and modified trees side by side\ntoytree.mtree([tree, modified]).draw();\n</pre> # return a tree with a new split (internal node and child) added modified = toytree.mod.add_internal_node_and_child(tree, \"d\", name=\"x\")  # show the original and modified trees side by side toytree.mtree([tree, modified]).draw(); abcdeabcedx <p>annotate: add annotations to tree drawings. The <code>ToyTree.draw()</code> function accepts a large number of arguments that allow it to style tree drawings in variety of ways. However, it is difficult to make all options available within one function without causing confusion. Therefore, we have developed the <code>annotate</code> subpackage to house many additional methods for adding annotations to tree drawings after they are initially created. Some may prefer the use of this module to create tree drawing code that is more readable and atomized.</p> In\u00a0[37]: Copied! <pre># draw a tree and store returned objects\ncanvas, axes, mark = tree.draw()\n\n# annotate method to add node markers\ntoytree.annotate.add_tip_markers(tree, axes, color=\"salmon\", size=12);\n\n# annotate method to add to edge labels\ntoytree.annotate.add_edge_labels(tree, axes, labels=\"idx\", font_size=15, yshift=-12, mask=False);\n</pre> # draw a tree and store returned objects canvas, axes, mark = tree.draw()  # annotate method to add node markers toytree.annotate.add_tip_markers(tree, axes, color=\"salmon\", size=12);  # annotate method to add to edge labels toytree.annotate.add_edge_labels(tree, axes, labels=\"idx\", font_size=15, yshift=-12, mask=False); abcde0123456 <p>pcm: phylogenetic comparative methods. This module has a long way to go towards offering many of the numerous comparative methods that have been developed over decades for studying evolution on trees. Currently, a number of simulation and model fitting approaches are available for discrete and continuous traits. (This is a great place to contribute to toytree!)</p> In\u00a0[38]: Copied! <pre># get variance-covariance matrix from tree\ntoytree.pcm.get_vcv_matrix_from_tree(tree, df=True)\n</pre> # get variance-covariance matrix from tree toytree.pcm.get_vcv_matrix_from_tree(tree, df=True) Out[38]: a b c d e a 4.0 3.0 0.0 0.0 0.0 b 3.0 4.0 0.0 0.0 0.0 c 0.0 0.0 4.0 1.0 1.0 d 0.0 0.0 1.0 4.0 3.0 e 0.0 0.0 1.0 3.0 4.0 In\u00a0[39]: Copied! <pre># simulate a discrete trait under a Markov transition model\ntoytree.pcm.simulate_discrete_data(tree, nstates=3, model=\"ER\", nreplicates=5)\n</pre> # simulate a discrete trait under a Markov transition model toytree.pcm.simulate_discrete_data(tree, nstates=3, model=\"ER\", nreplicates=5) Out[39]: t0 t1 t2 t3 t4 0 1 2 0 1 1 1 1 0 1 0 0 2 1 1 2 0 2 3 2 2 2 1 1 4 1 2 0 1 2 5 1 0 1 2 1 6 1 2 0 1 1 7 1 1 0 1 2 8 2 2 1 0 0 In\u00a0[40]: Copied! <pre># make a copy of tree on which we will add a bunch of data\ndtree = tree.copy()\n\n# add a feature and set all Nodes to a default value\ndtree = dtree.set_node_data(\"trait1\", default=10)\n\n# or set some to specific values and others to a default\ndtree = dtree.set_node_data(\"trait2\", {i: 5 for i in range(dtree.ntips)}, default=1)\n\n# or add some to specific values and leave others as NaN\ndtree = dtree.set_node_data(\"trait3\", {0: \"X\", 1: \"Y\"})\n\n# or, add a feature by assigning as an attribute to one or more Nodes\ndtree[6].trait4 = \"special\"\n\n# show the data\ndtree.get_node_data()\n</pre> # make a copy of tree on which we will add a bunch of data dtree = tree.copy()  # add a feature and set all Nodes to a default value dtree = dtree.set_node_data(\"trait1\", default=10)  # or set some to specific values and others to a default dtree = dtree.set_node_data(\"trait2\", {i: 5 for i in range(dtree.ntips)}, default=1)  # or add some to specific values and leave others as NaN dtree = dtree.set_node_data(\"trait3\", {0: \"X\", 1: \"Y\"})  # or, add a feature by assigning as an attribute to one or more Nodes dtree[6].trait4 = \"special\"  # show the data dtree.get_node_data() Out[40]: idx name height dist support trait1 trait2 trait3 trait4 0 0 a 0.0 1.0 NaN 10 5 X NaN 1 1 b 0.0 1.0 NaN 10 5 Y NaN 2 2 c 0.0 3.0 NaN 10 5 NaN NaN 3 3 d 0.0 1.0 NaN 10 5 NaN NaN 4 4 e 0.0 1.0 NaN 10 5 NaN NaN 5 5 1.0 3.0 90.0 10 1 NaN NaN 6 6 1.0 2.0 100.0 10 1 NaN special 7 7 3.0 1.0 100.0 10 1 NaN NaN 8 8 4.0 0.0 NaN 10 1 NaN NaN In\u00a0[41]: Copied! <pre># the draw function returns three objects\ntree.draw()\n</pre> # the draw function returns three objects tree.draw() Out[41]: <pre>(&lt;toyplot.canvas.Canvas at 0x7cba1097f140&gt;,\n &lt;toyplot.coordinates.Cartesian at 0x7cba07772e70&gt;,\n &lt;toytree.drawing.src.mark_toytree.ToyTreeMark at 0x7cba07755670&gt;)</pre> abcde <p>As you may have noticed, I end many drawing commands with a semicolon which simply hides the return values when we don't intend to save them to variables. In a notebook the Canvas will automatically render in the cell below the plot even if you do not save it as a variable. If you save the notebook the rendered figure is saved to the output.</p> In\u00a0[42]: Copied! <pre># the semicolon hides the returned text of the Canvas and Cartesian objects\ntree.draw();\n</pre> # the semicolon hides the returned text of the Canvas and Cartesian objects tree.draw(); abcde <p>Finally, you can store the three returned objects, in which case you can add additional styling and/or save to a file. In this example I add additional styling to the Cartesian axes.</p> In\u00a0[43]: Copied! <pre># or, we can store them as variables\ncanvas, axes, mark = tree.draw(scale_bar=True)\n\n# and then optionally add additional styling\naxes.x.label.text = \"Time (Mya)\"\naxes.x.label.style[\"font-size\"] = 14\naxes.x.label.offset = 20\n</pre> # or, we can store them as variables canvas, axes, mark = tree.draw(scale_bar=True)  # and then optionally add additional styling axes.x.label.text = \"Time (Mya)\" axes.x.label.style[\"font-size\"] = 14 axes.x.label.offset = 20 abcde43210Time (Mya) In\u00a0[44]: Copied! <pre># drawing with pre-built tree_styles\ntree.draw(tree_style='c');  # coalescent-style\ntree.draw(tree_style='d');  # dark-style\n\n# 'ts' is also a shortcut for tree_style\ntree.draw(ts='o');          # umlaut-style\n</pre> # drawing with pre-built tree_styles tree.draw(tree_style='c');  # coalescent-style tree.draw(tree_style='d');  # dark-style  # 'ts' is also a shortcut for tree_style tree.draw(ts='o');          # umlaut-style abcde01234 abcde abcde In\u00a0[45]: Copied! <pre># define a style dictionary\nmystyle = {\n    \"layout\": 'd',\n    \"edge_type\": 'p',\n    \"edge_style\": {\n        \"stroke\": \"darkcyan\",\n        \"stroke-width\": 2.5,\n    },\n    \"tip_labels_colors\": \"black\",\n    \"tip_labels_style\": {\n        \"font-size\": \"16px\"\n    },\n    \"node_sizes\": 8,\n    \"node_colors\": \"dist\",\n    \"node_labels\": \"support\",\n    \"node_labels_style\": {\"baseline-shift\": 12, \"anchor-shift\": 15, \"font-size\": 12},\n    \"node_mask\": (0, 1, 0),\n}\n\n# use your custom style dictionary in one or more tree drawings\ntree.draw(height=300, **mystyle);\n</pre> # define a style dictionary mystyle = {     \"layout\": 'd',     \"edge_type\": 'p',     \"edge_style\": {         \"stroke\": \"darkcyan\",         \"stroke-width\": 2.5,     },     \"tip_labels_colors\": \"black\",     \"tip_labels_style\": {         \"font-size\": \"16px\"     },     \"node_sizes\": 8,     \"node_colors\": \"dist\",     \"node_labels\": \"support\",     \"node_labels_style\": {\"baseline-shift\": 12, \"anchor-shift\": 15, \"font-size\": 12},     \"node_mask\": (0, 1, 0), }  # use your custom style dictionary in one or more tree drawings tree.draw(height=300, **mystyle); 90100100abcde In\u00a0[46]: Copied! <pre># draw a plot and store the Canvas object to a variable\ncanvas, axes, mark = tree.draw(ts='p');\n</pre> # draw a plot and store the Canvas object to a variable canvas, axes, mark = tree.draw(ts='p'); 012345678abcde01234 <p>HTML rendering is the default format. This will save the figure as a vector graphic (SVG) wrapped in HTML with optional javascript wrapping that enables interactive features. You can share the file with others and anyone can open it in a browser. You can embed it on your website, or even display it in emails.</p> In\u00a0[47]: Copied! <pre># HTML allows for interactivity and embedding in web sites\ntoytree.save(canvas, \"/tmp/tree-plot.html\")\n</pre> # HTML allows for interactivity and embedding in web sites toytree.save(canvas, \"/tmp/tree-plot.html\") In\u00a0[48]: Copied! <pre># SVG for figures you will further edit in Illustrator/Inkscape\ntoytree.save(canvas, \"/tmp/tree-plot.svg\")\n</pre> # SVG for figures you will further edit in Illustrator/Inkscape toytree.save(canvas, \"/tmp/tree-plot.svg\") In\u00a0[49]: Copied! <pre># PDF for final shareable figures\ntoytree.save(canvas, \"/tmp/tree-plot.pdf\")\n</pre> # PDF for final shareable figures toytree.save(canvas, \"/tmp/tree-plot.pdf\") In\u00a0[50]: Copied! <pre># PNG for small and easy to share figures \ntoytree.save(canvas, \"/tmp/tree-plot.png\")\n</pre> # PNG for small and easy to share figures  toytree.save(canvas, \"/tmp/tree-plot.png\") <p>The toyplot library also has options for saving canvases. See the toyplot documentation. The <code>toytree.save()</code> function above is simply a convenient wrapper around these functions.</p> In\u00a0[51]: Copied! <pre>import toyplot\ntoyplot.html.render(canvas, \"/tmp/tree-plot.html\")\n</pre> import toyplot toyplot.html.render(canvas, \"/tmp/tree-plot.html\") In\u00a0[52]: Copied! <pre>import toyplot.svg\ntoyplot.svg.render(canvas, \"/tmp/tree-plot.svg\")\n</pre> import toyplot.svg toyplot.svg.render(canvas, \"/tmp/tree-plot.svg\") In\u00a0[53]: Copied! <pre>import toyplot.pdf\ntoyplot.pdf.render(canvas, \"/tmp/tree-plot.pdf\")\n</pre> import toyplot.pdf toyplot.pdf.render(canvas, \"/tmp/tree-plot.pdf\") In\u00a0[54]: Copied! <pre>import toyplot.png\ntoyplot.png.render(canvas, \"/tmp/tree-plot.png\")\n</pre> import toyplot.png toyplot.png.render(canvas, \"/tmp/tree-plot.png\")"},{"location":"quick_guide/#quick-guide","title":"Quick Guide\u00b6","text":"<p>This tutorial introduces several key concepts and applications of the <code>toytree</code> package to provide a general overview. Please follow links throughout this guide, and explore the broader documentation, to find more detailed instructions of each topic.</p>"},{"location":"quick_guide/#the-toytree-package","title":"The <code>toytree</code> package\u00b6","text":"<p><code>toytree</code> is a Python library for working with tree data. It provides a custom class for storing and representing tree data alongside an extensive library of methods for performing numerical and evolutionary analyses on trees. In addition, <code>toytree</code> provides interactive features that make it particularly well suited for use inside jupyter notebooks, such as interactive tree plotting methods and a well organized, modular, and documented code base.</p> <p>This tutorial was created as a jupyter notebook, and you can follow along in a notebook of your own by executing code from the top to the bottom of the document. To begin, let's import the <code>toytree</code> package.</p>"},{"location":"quick_guide/#a-simple-example","title":"A simple example\u00b6","text":"<p>The code block below contains three lines of code to parse a tree object from data, modify it, and generate a tree drawing, respectively. This simple operation demonstrates several key features of <code>toytree</code> functionality and design. The first line uses the method <code>toytree.tree</code> (see Tree Parsing (i/o)) to parse tree data (in this case from a public URL) into a <code>ToyTree</code> class object, and store it to the variable name tree.</p> <p>The next line of code calls a method of the <code>ToyTree</code> object to root the tree on a specified edge. The <code>ToyTree</code> class object is the main class for representing trees in <code>toytree</code> and has many methods associated with it. In this case, we enter \"~prz\" as an argument to <code>.root()</code>, which is interpreted as a regular expression to match any names on the tree containing \"prz\" (See Node/Name Query), as a convenient method to select an internal edge on which to root the tree.</p> <p>Finally, the last code line calls the <code>.draw()</code> method of the <code>ToyTree</code> to generate a tree drawing (See Tree Drawing). The drawing is automatically displayed in the notebook output cell, and can be optionally stored as a variable and further modified, or saved to disk in a variety of formats. We provide arguments to align the tip names and show markers at the nodes with interactive tooltip information (try it by hovering your cursor over the nodes).</p>"},{"location":"quick_guide/#parsing-tree-data","title":"Parsing tree data\u00b6","text":"<p><code>ToyTree</code> objects can be flexibly loaded from a range of input types using the <code>toytree.tree()</code> function. Tree data can be loaded from a string, file path, or public URL. The data can be formatted as Newick, NHX, or NEXUS format. Complex metadata can be parsed from extended Newick strings, and/or added to trees and saved to extended Newick formatted strings. Here we parse a newick string into a <code>ToyTree</code> object and call the <code>get_node_data()</code> function of the tree, which returns a summary table of the data in the tree. Viewing this table we can see how it has assigned the \"name\", \"dist\", and \"support\" values from the Newick data to the Nodes of the tree.</p>"},{"location":"quick_guide/#class-objects","title":"Class objects\u00b6","text":"<p>The main Class objects in <code>toytree</code> are structured as a nested hierarchy. At the lowest level are <code>toytree.Node</code> class objects. A collection of connected <code>Nodes</code> form the data for a <code>toytree.ToyTree</code> class object. This is the primary class in <code>toytree</code>. In addition, a collection of trees can form the data of a higher-level class object, called a <code>toytree.MultiTree</code>. Each object type contains attributes and methods that are designed for its specific place in the hierarchy. For example, nodes contain attributes and methods for extracting information about a specific <code>Node</code> and its connections (edges) to other nodes. A <code>ToyTree</code> contains attributes and methods for extracting information about an entire tree of connected nodes, including emergent properties of these collections, and methods for operating on them. Finally, a <code>MultiTree</code> contains attributes and methods for operating on collections of trees, such as consensus tree inference and methods for drawing multiple trees together.</p>"},{"location":"quick_guide/#learning-to-use-toytree","title":"Learning to use <code>toytree</code>\u00b6","text":"<p>When first learning <code>toytree</code> it is hugely beneficial to play around in an interactive environment such as a jupyter notebook or IDE that provides tab-completion/auto-complete features that make it possible to see all available methods and attributes of an object. In this way, you can easily explore the many possibilities associated with a <code>ToyTree</code> object without having to study the entire documentation. To try this feature in a notebook type the name of a <code>ToyTree</code> variable (e.g., tree below) followed by a dot and then press tab. A few of the many methods that will pop-up are shown below.</p>"},{"location":"quick_guide/#selecting-nodes","title":"Selecting nodes\u00b6","text":"<p>Many methods in <code>toytree</code> require selecting one or more nodes from a tree to operate on. This can often be challenging since most nodes in a tree usually do not have unique names assigned to them, and selecting nodes by a numeric indexing method can be error-prone if the indices change. We have tried to design the node query and selection methods in toytree to be maximally flexible to allow for ease-of-use when selecting nodes while also trying to prevent users from making simple and common mistakes.</p> <p>The <code>get_nodes</code> and <code>get_mrca_node</code> methods of <code>ToyTree</code> objects provide a flexible approach to selecting one or more nodes either by name or by their unique integer indices. See the Node Query/Selection documentation section for details.</p>"},{"location":"quick_guide/#subpackages","title":"Subpackages\u00b6","text":"<p>There are many possible operations, algorithms, statistics, and metrics that can be implemented or computed on tree data, and if we simply added every method as an additional function of a <code>ToyTree</code> object it would become crowded and difficult to find its more common attributes and functions. Therefore, we have instead organized many of these additional methods into subpackages where functions with similar themes are organized together. For example, the <code>rtree</code> subpackage is used to generate random trees under a variety of algorithms, and the <code>mod</code> subpackage is used to group together many functions for modifying tree data. The methods in each of these subpackages is explained in much greater detail in their specific section of the documentation. Here we provide just a brief introduction to each.</p>"},{"location":"quick_guide/#storing-data-to-trees","title":"Storing data to trees\u00b6","text":"<p>Any arbitrary data can be stored to trees by assigning it to the <code>Node</code> objects in the tree. This can be done in the most simple way by iterating over nodes in a tree and assigning values to nodes, or, it can be done by using a tree's <code>.set_node_data()</code> function, which has options for making it easy to assign values to some nodes but not others. The <code>get_node_data()</code> function is especially useful here in that it collects data from all Nodes and can provide NaN, or a custom value, for nodes that either have no value for a feature, or lack the feature all together, depending on how it was assigned. Several examples for setting data to nodes are shown:</p>"},{"location":"quick_guide/#tree-drawings","title":"Tree drawings\u00b6","text":"<p>When you call <code>.draw()</code> on a tree it returns three objects, a Canvas, Cartesian, and Mark. This follows the design principle of the toyplot plotting library that <code>toytree</code> uses as its default plotting backend. The Canvas describes the dimensions of the plot space, the Cartesian coordinates define how to project points onto that space, and a Mark represents plotted data. One Canvas can have multiple Cartesian coordinates, and each Cartesian object can have multiple Marks. After a plot is generated, each of these objects can be interacted with to set additional styling to axes, ticks, font sizes, etc. The three returned objects can be seen in the output field of the cell below.</p>"},{"location":"quick_guide/#styling-tree-drawings","title":"Styling tree drawings\u00b6","text":"<p>There are innumerous ways in which to style tree drawings. In addition to individual options that change a style component one-by-one, we also provide a number of built-in \"tree-style\" arguments, which change the default style on top of which additional changes can be made. Users can also create their own tree-style dictionaries easily. You can view the <code>draw</code> function docstring for more details on available arguments, or you can see which styles are available by accessing the <code>.style</code> dict-like object of a <code>ToyTree</code>. See the <code>Styling</code> documentation for more details.</p>"},{"location":"quick_guide/#saving-tree-drawings","title":"Saving tree drawings\u00b6","text":"<p>Tree drawings can be saved to disk in a variety of formats, including HTML, SVG, PDF, or PNG. The simplest way to save a canvas drawing is using the <code>toytree.save()</code> function, where the file format will be inferred from the filename suffix. As demonstrated below, you can also save a canvas using options from the <code>toyplot</code> library.</p>"},{"location":"random-trees/","title":"<i>.rtree</i> - random trees","text":"In\u00a0[56]: Copied! <pre>import toytree\n\nrandom_tree = toytree.rtree.rtree(ntips=10)\nrandom_tree.draw('s');\n</pre> import toytree  random_tree = toytree.rtree.rtree(ntips=10) random_tree.draw('s'); 0123456789101112131415161718r0r1r2r3r4r5r6r7r8r9 <p>Note: by default, the tips are ordered by name value as seen above. This can be changed using the setting <code>random_names=True</code></p> In\u00a0[57]: Copied! <pre>toytree.rtree.rtree(ntips=10, random_names=True).draw('s');\n</pre> toytree.rtree.rtree(ntips=10, random_names=True).draw('s'); 0123456789101112131415161718r0r3r5r4r6r2r9r7r1r8 <p>Additionally, reproduceable results can be attained using an rng seed as shown below.</p> In\u00a0[58]: Copied! <pre>toytree.rtree.rtree(ntips=10, seed=123).draw('s');\ntoytree.rtree.rtree(ntips=10, seed=123).draw('s');\n</pre> toytree.rtree.rtree(ntips=10, seed=123).draw('s'); toytree.rtree.rtree(ntips=10, seed=123).draw('s'); 0123456789101112131415161718r0r1r2r3r4r5r6r7r8r9 0123456789101112131415161718r0r1r2r3r4r5r6r7r8r9 In\u00a0[59]: Copied! <pre>unit_tree = toytree.rtree.unittree(10)\nunit_tree.draw(scale_bar=True, ts='s', node_hover=True);\n</pre> unit_tree = toytree.rtree.unittree(10) unit_tree.draw(scale_bar=True, ts='s', node_hover=True);  idx: 0 dist: 0.6 support: nan height: 0 name: r00idx: 1 dist: 0.2 support: nan height: 0 name: r11idx: 2 dist: 0.2 support: nan height: 0 name: r22idx: 3 dist: 0.2 support: nan height: 0 name: r33idx: 4 dist: 0.2 support: nan height: 0 name: r44idx: 5 dist: 0.8 support: nan height: 0 name: r55idx: 6 dist: 0.4 support: nan height: 0 name: r66idx: 7 dist: 0.4 support: nan height: 0 name: r77idx: 8 dist: 0.6 support: nan height: 0 name: r88idx: 9 dist: 0.8 support: nan height: 0 name: r99idx: 10 dist: 0.2 support: nan height: 0.2 name: 10idx: 11 dist: 0.2 support: nan height: 0.2 name: 11idx: 12 dist: 0.2 support: nan height: 0.4 name: 12idx: 13 dist: 0.2 support: nan height: 0.6 name: 13idx: 14 dist: 0.2 support: nan height: 0.8 name: 14idx: 15 dist: 0.2 support: nan height: 0.4 name: 15idx: 16 dist: 0.2 support: nan height: 0.6 name: 16idx: 17 dist: 0.2 support: nan height: 0.8 name: 17idx: 18 dist: 0 support: nan height: 1 name: 18r0r1r2r3r4r5r6r7r8r9543210 In\u00a0[60]: Copied! <pre>unit_tree = toytree.rtree.imbtree(10)\nunit_tree.draw(scale_bar=True, ts='s', node_hover=True);\n</pre> unit_tree = toytree.rtree.imbtree(10) unit_tree.draw(scale_bar=True, ts='s', node_hover=True);  idx: 0 dist: 0.111111111111 support: nan height: 0 name: r00idx: 1 dist: 0.111111111111 support: nan height: 0 name: r11idx: 2 dist: 0.222222222222 support: nan height: 0 name: r22idx: 3 dist: 0.333333333333 support: nan height: 0 name: r33idx: 4 dist: 0.444444444444 support: nan height: 0 name: r44idx: 5 dist: 0.555555555556 support: nan height: 0 name: r55idx: 6 dist: 0.666666666667 support: nan height: 0 name: r66idx: 7 dist: 0.777777777778 support: nan height: 0 name: r77idx: 8 dist: 0.888888888889 support: nan height: 0 name: r88idx: 9 dist: 1 support: nan height: 0 name: r99idx: 10 dist: 0.111111111111 support: nan height: 0.111111111111 name: 10idx: 11 dist: 0.111111111111 support: nan height: 0.222222222222 name: 11idx: 12 dist: 0.111111111111 support: nan height: 0.333333333333 name: 12idx: 13 dist: 0.111111111111 support: nan height: 0.444444444444 name: 13idx: 14 dist: 0.111111111111 support: nan height: 0.555555555556 name: 14idx: 15 dist: 0.111111111111 support: nan height: 0.666666666667 name: 15idx: 16 dist: 0.111111111111 support: nan height: 0.777777777778 name: 16idx: 17 dist: 0.111111111111 support: nan height: 0.888888888889 name: 17idx: 18 dist: 0 support: nan height: 1 name: 18r0r1r2r3r4r5r6r7r8r99630 In\u00a0[61]: Copied! <pre>unit_tree = toytree.rtree.baltree(20, random_names=True)\nunit_tree.draw(scale_bar=True, ts='s', node_hover=True);\n</pre> unit_tree = toytree.rtree.baltree(20, random_names=True) unit_tree.draw(scale_bar=True, ts='s', node_hover=True); idx: 0 dist: 0.4 support: nan height: 0 name: r130idx: 1 dist: 0.4 support: nan height: 0 name: r31idx: 2 dist: 0.4 support: nan height: 0 name: r72idx: 3 dist: 0.2 support: nan height: 0 name: r93idx: 4 dist: 0.2 support: nan height: 0 name: r194idx: 5 dist: 0.4 support: nan height: 0 name: r115idx: 6 dist: 0.4 support: nan height: 0 name: r66idx: 7 dist: 0.4 support: nan height: 0 name: r187idx: 8 dist: 0.2 support: nan height: 0 name: r28idx: 9 dist: 0.2 support: nan height: 0 name: r179idx: 10 dist: 0.4 support: nan height: 0 name: r810idx: 11 dist: 0.4 support: nan height: 0 name: r511idx: 12 dist: 0.4 support: nan height: 0 name: r112idx: 13 dist: 0.2 support: nan height: 0 name: r1513idx: 14 dist: 0.2 support: nan height: 0 name: r1614idx: 15 dist: 0.4 support: nan height: 0 name: r1215idx: 16 dist: 0.4 support: nan height: 0 name: r1016idx: 17 dist: 0.4 support: nan height: 0 name: r1417idx: 18 dist: 0.2 support: nan height: 0 name: r018idx: 19 dist: 0.2 support: nan height: 0 name: r419idx: 20 dist: 0.2 support: nan height: 0.4 name: 20idx: 21 dist: 0.2 support: nan height: 0.2 name: 21idx: 22 dist: 0.2 support: nan height: 0.4 name: 22idx: 23 dist: 0.2 support: nan height: 0.6 name: 23idx: 24 dist: 0.2 support: nan height: 0.4 name: 24idx: 25 dist: 0.2 support: nan height: 0.2 name: 25idx: 26 dist: 0.2 support: nan height: 0.4 name: 26idx: 27 dist: 0.2 support: nan height: 0.6 name: 27idx: 28 dist: 0.2 support: nan height: 0.8 name: 28idx: 29 dist: 0.2 support: nan height: 0.4 name: 29idx: 30 dist: 0.2 support: nan height: 0.2 name: 30idx: 31 dist: 0.2 support: nan height: 0.4 name: 31idx: 32 dist: 0.2 support: nan height: 0.6 name: 32idx: 33 dist: 0.2 support: nan height: 0.4 name: 33idx: 34 dist: 0.2 support: nan height: 0.2 name: 34idx: 35 dist: 0.2 support: nan height: 0.4 name: 35idx: 36 dist: 0.2 support: nan height: 0.6 name: 36idx: 37 dist: 0.2 support: nan height: 0.8 name: 37idx: 38 dist: 0 support: nan height: 1 name: 38r13r3r7r9r19r11r6r18r2r17r8r5r1r15r16r12r10r14r0r4543210 In\u00a0[62]: Copied! <pre>tree = toytree.rtree.bdtree(ntips=40, b=1.0, d=0.5, verbose=True)\ntree.draw('c');\n</pre> tree = toytree.rtree.bdtree(ntips=40, b=1.0, d=0.5, verbose=True) tree.draw('c'); <pre>time       7.863758\nntips     40.000000\nb         74.000000\nd         35.000000\nb/d        1.472973\nresets     0.000000\ndtype: float64\n</pre> r0r1r2r3r4r5r6r7r8r9r10r11r12r13r14r15r16r17r18r19r20r21r22r23r24r25r26r27r28r29r30r31r32r33r34r35r36r37r38r390246 In\u00a0[63]: Copied! <pre>tree = toytree.rtree.coaltree(k=40, N=10)\ntree.draw('c');\n</pre> tree = toytree.rtree.coaltree(k=40, N=10) tree.draw('c'); r0r1r2r3r4r5r6r7r8r9r10r11r12r13r14r15r16r17r18r19r20r21r22r23r24r25r26r27r28r29r30r31r32r33r34r35r36r37r38r3901020"},{"location":"random-trees/#random-tree-generators","title":"Random Tree Generators\u00b6","text":"<p>The .rtree subpackage allows the user to quickly generate random topologies in a variety of methods.</p>"},{"location":"random-trees/#simple-rtree","title":"Simple rtree\u00b6","text":"<p>The function <code>rtree.rtree()</code> is the fastest method provided to generate a random topology, and works by iteratively bifurcating a random tip (starting from a single root) until there are the desired number of tips provided by the <code>ntips=</code> argument.</p>"},{"location":"random-trees/#unit-rtree","title":"Unit rtree\u00b6","text":"<p>This variation, <code>rtree.unittree()</code>, generates an ultrametric tree where all internal edges are of equal distance. External edges are extended to make the tree ultrametric. The total tree height can be scaled to any arbitrary height, and other Nodes are scaled proportionately.</p>"},{"location":"random-trees/#imbalanced-rtree","title":"Imbalanced rtree\u00b6","text":"<p>One extreme possibility for a topography is a fully imbalanced tree, generated using <code>rtree.imbtree()</code>, in which each internal node has one child bifurcating and one child that is a tip. This creates a ladder-like shape as seen below.</p>"},{"location":"random-trees/#balanced-rtree","title":"Balanced rtree\u00b6","text":"<p>Conversely, the other extreme topographical possibility is that of a completely balanced tree. <code>rtree.baltree()</code> generates a balanced tree, so the only real random part of this generator is the tip names if <code>random_names = True</code>. The number of tips must be even to generate a fully balanced tree.</p>"},{"location":"random-trees/#birthdeath-rtree","title":"Birth/death rtree\u00b6","text":"<p>The function <code>rtree.bdtree()</code> generates a parametric birth/death tree. This means that birth or death events are randomly sampled beginning with a single ancestor until a stopping criterion is reached (either <code>stop='taxa'</code> or <code>stop='time'</code>). If the tree goes extinct, it is restarted. The waiting time to the next speciation event is exponential with rate equal to the parameter <code>b=</code>, and the same goes for extinction events with parameter <code>d=</code>. The events do not happen in parallel, so the waiting type for the next event regardless of type is exponential with rate $b+d$, and the probability that it is a speciation event is $\\frac{b}{b+d}$ and the probability that it is an extinction event is $\\frac{d}{b+d}$</p>"},{"location":"random-trees/#coalescent-rtree","title":"Coalescent rtree\u00b6","text":"<p>Finally, the function <code>rtree.coaltree()</code> generates a random ToyTree under the n-coalescent model. Waiting times between coalescent events under this model follow the distribution: $$ \\frac{4N}{k*(k-1)} $$ Where $k$ is the number of samples at present time and $N$ is the diploid effective population size $N_e$</p> <p>A tree is constructed by randomly sampling waiting times from an exponential distribution at each value of k from k to 1, and randomly joining Nodes at each coalescent interval. Note that the expected root height is $4N$.</p> <p>The number of tips (usually ntips) is given by <code>k=</code>, which represents the number of samples at present time, and the diploid effective population size is given by <code>N=</code>.</p>"},{"location":"range-mapping/","title":"feature range-mapping","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np <p>Take Home</p> <p>       Range mapping allows you to easily project data values into an appropriate range of pixel sizes to enter as arguments to drawing functions. This is done by entering the data feature to be range-mapped as a tuple in the format: (feature, min_value, max_value, nan_value).   </p> In\u00a0[2]: Copied! <pre># example: map node sizes to node idx values in range (12-25) px\ntree = toytree.rtree.bdtree(10, seed=123)\ntree.draw(ts='s', node_sizes=(\"idx\", 12, 25));\n</pre> # example: map node sizes to node idx values in range (12-25) px tree = toytree.rtree.bdtree(10, seed=123) tree.draw(ts='s', node_sizes=(\"idx\", 12, 25)); 0123456789101112131415161718r0r1r2r3r4r5r6r7r8r9 In\u00a0[3]: Copied! <pre>tree = toytree.rtree.bdtree(10, seed=123)\nrng = np.random.default_rng(seed=123)\ntree.set_node_data(\"X\", rng.uniform(0, 1, tree.nnodes), inplace=True);\ntree.set_node_data(\"Y\", rng.uniform(1e2, 1e3, tree.nnodes), inplace=True);\ntree.set_node_data(\"Z\", {i: i.X for i in tree[12:]}, inplace=True);\n</pre> tree = toytree.rtree.bdtree(10, seed=123) rng = np.random.default_rng(seed=123) tree.set_node_data(\"X\", rng.uniform(0, 1, tree.nnodes), inplace=True); tree.set_node_data(\"Y\", rng.uniform(1e2, 1e3, tree.nnodes), inplace=True); tree.set_node_data(\"Z\", {i: i.X for i in tree[12:]}, inplace=True); In\u00a0[4]: Copied! <pre>tree.get_node_data([\"X\", \"Y\", \"Z\"])\n</pre> tree.get_node_data([\"X\", \"Y\", \"Z\"]) Out[4]: X Y Z 0 0.682352 566.348533 NaN 1 0.053821 308.400062 NaN 2 0.220360 249.313594 NaN 3 0.184372 548.010072 NaN 4 0.175906 624.452177 NaN 5 0.812095 265.904189 NaN 6 0.923345 113.405425 NaN 7 0.276574 524.019906 NaN 8 0.819755 755.418995 NaN 9 0.889893 926.740443 NaN 10 0.512970 662.980605 NaN 11 0.244965 925.410315 NaN 12 0.824242 878.221226 0.824242 13 0.213763 296.328586 0.213763 14 0.741467 879.514688 0.741467 15 0.629940 757.676743 0.629940 16 0.927407 350.078761 0.927407 17 0.231908 817.339198 0.231908 18 0.799125 878.699542 0.799125 In\u00a0[5]: Copied! <pre># raw \"X\" data values are too small to use for node_sizes\ntree.draw(node_sizes=\"X\");\n</pre> # raw \"X\" data values are too small to use for node_sizes tree.draw(node_sizes=\"X\"); r0r1r2r3r4r5r6r7r8r9 In\u00a0[6]: Copied! <pre># raw \"Y\" data values are too large to use for node_sizes\ntree.draw(node_sizes=\"Y\", height=350, width=350);\n</pre> # raw \"Y\" data values are too large to use for node_sizes tree.draw(node_sizes=\"Y\", height=350, width=350); r0r1r2r3r4r5r6r7r8r9 In\u00a0[7]: Copied! <pre># project \"X\" values to pixel range using auto args for min,max,nan\ntree.draw(node_sizes=(\"X\",));\n</pre> # project \"X\" values to pixel range using auto args for min,max,nan tree.draw(node_sizes=(\"X\",)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[8]: Copied! <pre># project very small \"X\" values to pixel range 5-15\ntree.draw(node_sizes=(\"X\", 5, 15));\n</pre> # project very small \"X\" values to pixel range 5-15 tree.draw(node_sizes=(\"X\", 5, 15)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[9]: Copied! <pre># project very large \"Y\" values to pixel range 5-15\ntree.draw(node_sizes=(\"Y\", 5, 15));\n</pre> # project very large \"Y\" values to pixel range 5-15 tree.draw(node_sizes=(\"Y\", 5, 15)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[10]: Copied! <pre># project very small \"Z\" values to pixel range 5-15, with NaN values set to 0\ntree.draw(node_sizes=(\"Z\", 5, 15, 0));\n</pre> # project very small \"Z\" values to pixel range 5-15, with NaN values set to 0 tree.draw(node_sizes=(\"Z\", 5, 15, 0)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[11]: Copied! <pre>tree.draw(node_sizes=(\"Z\", 5, 15, 10));\n</pre> tree.draw(node_sizes=(\"Z\", 5, 15, 10)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[12]: Copied! <pre>toytree.style.get_range_mapped_feature(tree, \"X\", min_value=2, max_value=15, nan_value=0)\n</pre> toytree.style.get_range_mapped_feature(tree, \"X\", min_value=2, max_value=15, nan_value=0) Out[12]: <pre>array([11.35328489,  2.        ,  4.47829579,  3.94275072,  3.81676794,\n       13.2840094 , 14.93954874,  5.31483464, 13.39800011, 14.44173875,\n        8.83268852,  4.84444335, 13.46477251,  4.38012595, 12.23298906,\n       10.57333721, 15.        ,  4.65014844, 13.09100966])</pre>"},{"location":"range-mapping/#range-mapping","title":"Range-mapping\u00b6","text":"<p>Range mapping is a convenient method and syntax that allows for transforming/projecting raw data values, which may be composed of very small or very large values, into a range of values that is more appropriate for visualization, such as pixel size units. This is especially useful when wanting to visualize a range of data values on a tree as a distribution of node sizes or edge widths. (See Color-Mapping for a similar implementation to project discrete or continuous data values to a color map.)</p>"},{"location":"range-mapping/#example-data","title":"Example Data\u00b6","text":"<p>To demonstrate range-mapping we will use a 10 tip birth-death tree with three data features assigned to Nodes of the tree. The first feature \"X\" contains small float values randomly drawn from the interval (0-1). The second feature contains large float values randly drawn from the interval (100-1000). And the third feature contains the same data as feature \"X\", but with missing values for many nodes.</p>"},{"location":"range-mapping/#visualizing-raw-data","title":"Visualizing Raw Data\u00b6","text":"<p>As we can see in the examples below, the features \"X\", \"Y\" and \"Z\" do not serve well as arguments to the draw function to designate size of node markers. Either the markers are too small to see or too large such that they obscure the entire plot. One solution to this problem would be to call <code>get_node_data</code> on the feature to extract the data and then either multiply or divide the values by a constant to transform them into a more reasonable pixel size range. While this can be done, range-mapping provides a more convenient solution, explained below.</p>"},{"location":"range-mapping/#using-range-mapping","title":"Using Range Mapping\u00b6","text":"<p>Range mapping allows you to project a set of values into a new range while still preserving the relative differences among values. For example, the data in feature \"X\" ranges from about 0.05 to 0.95, all of which is too small for visualization. Using range mapping we can project these values so that the smallest values is 5, the largest value is 15, and all intermediate values are projected to the appropriate relative position between these min and max values.</p>"},{"location":"range-mapping/#tuple-syntax","title":"Tuple syntax\u00b6","text":"<p>Range mapping is designated by using the tuple syntax <code>(feature name, min_value, max_value, nan_value)</code>. The feature name is the only required argument, if the others are left empty then default values are assigned for the min, max, and nan values of (5, 20, 0).</p>"},{"location":"range-mapping/#missing-data-values","title":"Missing Data Values\u00b6","text":"<p>When one or more Nodes do not contain a feature they are assigned a value of <code>np.nan</code> by default. When range-mapping is performed it can be instructed how to treat these values. The default treatment is to convert these values to 0, but, you can alternatively set any value you want.</p>"},{"location":"range-mapping/#discrete-data-values","title":"Discrete Data Values\u00b6","text":"<p>Note that range-mapping can only be applied to continuous data, not discrete/categorical data. A more appropriate way to treat discrete data may be to use Color-Mapping instead.</p>"},{"location":"range-mapping/#get-range-mapped-data","title":"Get Range Mapped Data\u00b6","text":"<p>When you use the tuple format to instruct <code>toytree</code> to perform range mapping on a data feature it performs a simple operation under the hood to project the data into its new value range. This function is available to users in <code>toytree.style.get_range_mapped_feature</code> in case users wish to use it externally.</p>"},{"location":"rendering/","title":"save/export canvas","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport toyplot\n</pre> import toytree import toyplot <p>To save a tree drawing you must store the <code>Canvas</code> object to a named variable.</p> In\u00a0[3]: Copied! <pre># Draw an example tree and save the Canvas, axes, and mark\nrtre = toytree.rtree.unittree(ntips = 8)\ncanvas, axes, mark = rtre.draw();\n</pre> # Draw an example tree and save the Canvas, axes, and mark rtre = toytree.rtree.unittree(ntips = 8) canvas, axes, mark = rtre.draw(); r0r1r2r3r4r5r6r7 In\u00a0[5]: Copied! <pre>toytree.save(canvas, \"/tmp/drawing.html\")\ntoytree.save(canvas, \"/tmp/drawing.svg\")\ntoytree.save(canvas, \"/tmp/drawing.pdf\")\ntoytree.save(canvas, \"/tmp/drawing.png\")\n</pre> toytree.save(canvas, \"/tmp/drawing.html\") toytree.save(canvas, \"/tmp/drawing.svg\") toytree.save(canvas, \"/tmp/drawing.pdf\") toytree.save(canvas, \"/tmp/drawing.png\") In\u00a0[7]: Copied! <pre># the default option\ntoyplot.html.render(canvas, \"tmp/tree-plot.html\")\n\n# to save to SVG\nimport toyplot.svg\ntoyplot.svg.render(canvas, \"tmp/tree-plot.svg\")\n\n# to save to PDF\nimport toyplot.pdf\ntoyplot.pdf.render(canvas, \"tmp/tree-plot.pdf\")\n\n# to save to PNG\nimport toyplot.png\ntoyplot.png.render(canvas, \"tmp/tree-plot.png\")\n</pre> # the default option toyplot.html.render(canvas, \"tmp/tree-plot.html\")  # to save to SVG import toyplot.svg toyplot.svg.render(canvas, \"tmp/tree-plot.svg\")  # to save to PDF import toyplot.pdf toyplot.pdf.render(canvas, \"tmp/tree-plot.pdf\")  # to save to PNG import toyplot.png toyplot.png.render(canvas, \"tmp/tree-plot.png\")"},{"location":"rendering/#saveexport-canvas","title":"Save/Export Canvas\u00b6","text":"<p>Toytree drawings can be saved to disk using the <code>render</code> functions of toyplot. You can save toyplot figures in a variety of formats, including HTML, SVG, PDF, and PNG.</p>"},{"location":"rendering/#toytreesave","title":"toytree.save\u00b6","text":"<p>The method <code>toytree.save</code> provides the easiest way to save a canvas. Just provide the Canvas and output path name, and it will save it in the requested format based on the suffix at the end of the output path.</p>"},{"location":"rendering/#toyplotrender","title":"toyplot.render\u00b6","text":"<p>Under the hood, the <code>toytree.save</code> function calls the <code>toyplot.render</code> function. If you want a more verbose option you can use this approach intead, which requires importing the render function.</p>"},{"location":"rendering/#formats","title":"Formats\u00b6","text":""},{"location":"rendering/#html","title":"HTML\u00b6","text":"<p>HTML rendering is the default format. This will save the figure as a vector graphic (SVG) wrapped in HTML with additional optional javascript wrapping for interactive features. This is the only format that will retain the interactive hover features. It can be opened in a browser, and can be convenient for viewing very large trees.</p>"},{"location":"rendering/#svg","title":"SVG\u00b6","text":"<p>SVG is a vector format that is best for saving and creating publication quality figures. You can further edit the figure in Illustrator or InkScape (recommended).</p>"},{"location":"rendering/#pdf","title":"PDF\u00b6","text":"<p>The SVG figure can be embedded in a PDF for easier sharing with people who do not know how to view an SVG file.</p>"},{"location":"rendering/#png","title":"PNG\u00b6","text":"<p>PNG is a raster format. Instead of saving the instructions for the drawing it reduces it to pixels. This can be convenient for reducing the size of a drawing, especially if it contains tons of data (millions of points).</p>"},{"location":"ridge-plot/","title":"Ridge plot","text":"In\u00a0[3]: Copied! <pre>import toytree\nimport toyplot\nimport numpy as np\n# we'll use scipy.stats to get prob. density func. of normal dist\nimport scipy.stats as sc\n\n# generate a random tree with N tips\nntips = 40\ntre = toytree.rtree.baltree(ntips)\n\n# generate a distribution between -10 and 10 for each tip in the tree\npoints = np.linspace(-10, 10, 50)\ndists = {}\nfor tip in tre.get_tip_labels():\n    dists[tip] = sc.norm.pdf(points, loc=np.random.randint(-5, 5, 1), scale=2)\n</pre> import toytree import toyplot import numpy as np # we'll use scipy.stats to get prob. density func. of normal dist import scipy.stats as sc  # generate a random tree with N tips ntips = 40 tre = toytree.rtree.baltree(ntips)  # generate a distribution between -10 and 10 for each tip in the tree points = np.linspace(-10, 10, 50) dists = {} for tip in tre.get_tip_labels():     dists[tip] = sc.norm.pdf(points, loc=np.random.randint(-5, 5, 1), scale=2) In\u00a0[4]: Copied! <pre># set up canvas for two panel plot\ncanvas = toyplot.Canvas(width=300, height=400)\n\n# add tree to canvas\nax0 = canvas.cartesian(bounds=(50, 180, 50, 350), ymin=0, ymax=ntips, padding=15)\ntre.draw(axes=ax0, tip_labels=False)\nax0.show = False\n\n# add histograms to canvas\nax1 = canvas.cartesian(bounds=(200, 275, 50, 350), ymin=0, ymax=ntips, padding=15)\n\n# iterate from top to bottom (ntips to 0)\nfor tip in range(tre.ntips)[::-1]:\n    \n    # select a color for hist\n    color = \"skyblue\"\n    \n    # get tip name and get hist from dict\n    tipname = tre.get_tip_labels()[tip]\n    probs = dists[tipname]\n    \n    # fill histogram with slightly overlapping histograms\n    ax1.fill(\n        points, probs / probs.max() * 1.25,\n        baseline=[tip] * len(points), \n        style={\"fill\": color, \"stroke\": \"white\", \"stroke-width\": 0.5},\n        title=tipname,\n    )\n    \n    # add horizontal line at base\n    ax1.hlines(tip, opacity=0.5, color=\"grey\", style={\"stroke-width\": 0.5})\n\n# hide y axis, show x \nax1.y.show = False\nax1.x.label.text = \"Trait value\"\nax1.x.ticks.show = True\n</pre> # set up canvas for two panel plot canvas = toyplot.Canvas(width=300, height=400)  # add tree to canvas ax0 = canvas.cartesian(bounds=(50, 180, 50, 350), ymin=0, ymax=ntips, padding=15) tre.draw(axes=ax0, tip_labels=False) ax0.show = False  # add histograms to canvas ax1 = canvas.cartesian(bounds=(200, 275, 50, 350), ymin=0, ymax=ntips, padding=15)  # iterate from top to bottom (ntips to 0) for tip in range(tre.ntips)[::-1]:          # select a color for hist     color = \"skyblue\"          # get tip name and get hist from dict     tipname = tre.get_tip_labels()[tip]     probs = dists[tipname]          # fill histogram with slightly overlapping histograms     ax1.fill(         points, probs / probs.max() * 1.25,         baseline=[tip] * len(points),          style={\"fill\": color, \"stroke\": \"white\", \"stroke-width\": 0.5},         title=tipname,     )          # add horizontal line at base     ax1.hlines(tip, opacity=0.5, color=\"grey\", style={\"stroke-width\": 0.5})  # hide y axis, show x  ax1.y.show = False ax1.x.label.text = \"Trait value\" ax1.x.ticks.show = True r39r38r37r36r35r34r33r32r31r30r29r28r27r26r25r24r23r22r21r20r19r18r17r16r15r14r13r12r11r10r9r8r7r6r5r4r3r2r1r0-10-50510Trait value"},{"location":"ridge-plot/#plot-histograms-associated-with-tip-trait-values-ridge-plot","title":"Plot histograms associated with tip trait values (ridge plot)\u00b6","text":"<p>You can use the <code>.hist()</code> or <code>.fill()</code> functions of toytree to plot histograms. Here we will generate and plot a distribution of a data in order from top to bottom so that the histograms overlap in a \"ridge plot\" fashion. An analagous function in <code>ggtree</code> seems to have merited an entire publication: https://academic.oup.com/mbe/article/35/12/3041/5142656.</p>"},{"location":"rooting/","title":"rooting trees","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree <p>Take Home</p> <p>       A tree can be manually rooted on an outgroup using tree.root(...), or using one of several       algorithms to estimate the root placement. A tree can be unrooted using tree.unroot().   </p> <p>A simple example of rooting or unrooting is demonstrated below.</p> In\u00a0[2]: Copied! <pre># an example tree with outgroup (r3,r4)\ntree = toytree.rtree.unittree(ntips=5, seed=123)\n\n# modify to make an unrooted tree \nutree = tree.unroot()\n\n# root the tree on its original outgroup\nrtree = utree.root(\"r3\", \"r4\")\n\n# or, root the tree on an alternative outgroup\natree = rtree.root(\"r2\")\n</pre> # an example tree with outgroup (r3,r4) tree = toytree.rtree.unittree(ntips=5, seed=123)  # modify to make an unrooted tree  utree = tree.unroot()  # root the tree on its original outgroup rtree = utree.root(\"r3\", \"r4\")  # or, root the tree on an alternative outgroup atree = rtree.root(\"r2\") In\u00a0[3]: Copied! <pre># the .treenode is the top-level node\ntree.treenode\n</pre> # the .treenode is the top-level node tree.treenode Out[3]: <pre>&lt;Node(idx=8)&gt;</pre> In\u00a0[4]: Copied! <pre># it is also accessible as the last indexed node\ntree[-1]\n</pre> # it is also accessible as the last indexed node tree[-1] Out[4]: <pre>&lt;Node(idx=8)&gt;</pre> In\u00a0[5]: Copied! <pre># draw the trees rooted\nc, a, m = toytree.mtree([tree, utree, atree]).draw(ts='p', layout='d');\na[0].label.text = \"rooted tree\"\na[1].label.text = \"unrooted tree\"\na[2].label.text = \"alt rooted tree\"\n</pre> # draw the trees rooted c, a, m = toytree.mtree([tree, utree, atree]).draw(ts='p', layout='d'); a[0].label.text = \"rooted tree\" a[1].label.text = \"unrooted tree\" a[2].label.text = \"alt rooted tree\" 012345678r0r1r2r3r4rooted tree01234567r0r1r2r3r4unrooted tree012345678r2r0r1r3r4alt rooted tree <p>The drawings below show the same trees but using the unrooted/undirected ('un') layout. This places the treenode near the center and projects edges away from it in a way that minimizes overlaps. You can more clearly see by comparing the three trees in this layout that the structure (topology) of the tree does not change during rooting. The only difference between the middle and two outer drawings is the addition of an extra node (node 8) that is inserted either between nodes 6 and 7 on the left tree, or between nodes 0 and 7 on the right tree (note: node idx labels change between trees with different rootings). An undirected  layout would typically be used to visualize an unrooted tree (middle) but is not the most informative for rooted trees, since it is harder to interpret the distances of nodes from the root.</p> In\u00a0[6]: Copied! <pre># draw the trees unrooted\nc, a, m = toytree.mtree([tree, utree, atree]).draw(ts='p', layout='un');\na[0].label.text = \"rooted tree\"\na[1].label.text = \"unrooted tree\"\na[2].label.text = \"alt rooted tree\"\n</pre> # draw the trees unrooted c, a, m = toytree.mtree([tree, utree, atree]).draw(ts='p', layout='un'); a[0].label.text = \"rooted tree\" a[1].label.text = \"unrooted tree\" a[2].label.text = \"alt rooted tree\" 012345678r0r1r2r3r4rooted tree01234567r0r1r2r3r4unrooted tree012345678r2r0r1r3r4alt rooted tree <p>Tip</p> <p>       A key point is to recognize the difference between whether a tree is rooted or not, and whether a tree is drawn using an unrooted/undirected layout or not. These are two distinct things.   </p> In\u00a0[7]: Copied! <pre># root the tree using clade (r3,r4) as outgroup\nnew_tree = utree.root(\"r3\", \"r4\")\n\n# show the unrooted and newly rooted trees\ntoytree.mtree([utree, new_tree]).draw(ts='p');\n</pre> # root the tree using clade (r3,r4) as outgroup new_tree = utree.root(\"r3\", \"r4\")  # show the unrooted and newly rooted trees toytree.mtree([utree, new_tree]).draw(ts='p'); 01234567r0r1r2r3r4012345678r3r4r0r1r2 In\u00a0[8]: Copied! <pre># root the tree on the global midpoint and draw it\nutree.mod.root_on_midpoint().draw(ts='p');\n</pre> # root the tree on the global midpoint and draw it utree.mod.root_on_midpoint().draw(ts='p'); 012345678r3r4r0r1r200.51 In\u00a0[9]: Copied! <pre># root the tree on the balanced midpoint\nutree.mod.root_on_balanced_midpoint().draw(ts='p');\n</pre> # root the tree on the balanced midpoint utree.mod.root_on_balanced_midpoint().draw(ts='p'); 012345678r3r4r0r1r200.51 In\u00a0[10]: Copied! <pre># get a rooted tree with MAD scores stored as features\ntree.mod.root_on_minimal_ancestor_deviation().draw(ts='p');\n</pre> # get a rooted tree with MAD scores stored as features tree.mod.root_on_minimal_ancestor_deviation().draw(ts='p'); 012345678r3r4r0r1r200.51 In\u00a0[11]: Copied! <pre># manual set rooting position 0.1 height units above clade (r3,r4)\nutree.root(\"r3\", \"r4\", root_dist=0.1).draw(ts='p');\n</pre> # manual set rooting position 0.1 height units above clade (r3,r4) utree.root(\"r3\", \"r4\", root_dist=0.1).draw(ts='p'); 012345678r3r4r0r1r200.40.81.2 In\u00a0[12]: Copied! <pre># manual set rooting position 0.6 height units above clade (r3,r4)\nutree.root(\"r3\", \"r4\", root_dist=0.6).draw(ts='p');\n</pre> # manual set rooting position 0.6 height units above clade (r3,r4) utree.root(\"r3\", \"r4\", root_dist=0.6).draw(ts='p'); 012345678r3r4r0r1r200.40.81.2 In\u00a0[13]: Copied! <pre>tree, stats = tree.mod.root_on_minimal_ancestor_deviation(return_stats=True)\nstats\n</pre> tree, stats = tree.mod.root_on_minimal_ancestor_deviation(return_stats=True) stats Out[13]: <pre>{'minimal_ancestor_deviation': 0.0,\n 'root_ambiguity_index': 0.0,\n 'root_clock_coefficient_of_variation': 1.922962686383564e-14}</pre> <p>Whereas in this example non-ultrametric tree the MAD, ambiguity, and clock variation are all very high.</p> In\u00a0[14]: Copied! <pre># create a non-ultrametric tree and draw it\nnon_ultrametric_tree = toytree.rtree.rtree(10)\nnon_ultrametric_tree.draw(layout='d');\n\n# calculate and return the global MAD stats\n_, stats = non_ultrametric_tree.mod.root_on_minimal_ancestor_deviation(return_stats=True)\nstats\n</pre> # create a non-ultrametric tree and draw it non_ultrametric_tree = toytree.rtree.rtree(10) non_ultrametric_tree.draw(layout='d');  # calculate and return the global MAD stats _, stats = non_ultrametric_tree.mod.root_on_minimal_ancestor_deviation(return_stats=True) stats Out[14]: <pre>{'minimal_ancestor_deviation': 0.2567240422048876,\n 'root_ambiguity_index': 0.9951447617191235,\n 'root_clock_coefficient_of_variation': 28.79169780067905}</pre> r0r1r2r3r4r5r6r7r8r9 In\u00a0[15]: Copied! <pre># get a rooted tree with MAD scores stored as features\nmad_tree = tree.mod.root_on_minimal_ancestor_deviation()\n\n# examine all features stored to the ToyTree (which now include MAD info)\nmad_tree.get_node_data()\n</pre> # get a rooted tree with MAD scores stored as features mad_tree = tree.mod.root_on_minimal_ancestor_deviation()  # examine all features stored to the ToyTree (which now include MAD info) mad_tree.get_node_data() Out[15]: idx name height dist support MAD MAD_root_prob 0 0 r0 0.000000e+00 0.333333 NaN 0.500000 0.10066 1 1 r1 0.000000e+00 0.333333 NaN 0.500000 0.10066 2 2 r2 0.000000e+00 0.666667 NaN 0.258199 0.14934 3 3 r3 2.220446e-16 0.666667 NaN 0.258199 0.14934 4 4 r4 2.220446e-16 0.666667 NaN 0.258199 0.14934 5 5 3.333333e-01 0.333333 NaN 0.258199 0.14934 6 6 6.666667e-01 0.333333 NaN 0.000000 0.20132 7 7 6.666667e-01 0.333333 NaN 0.000000 0.20132 8 8 root 1.000000e+00 0.000000 NaN NaN NaN <p>Finally, we could plot the MAD or MAD_root_prob scores on the edges of a tree easily, since they are stored as features to the returned rooted tree.</p> In\u00a0[16]: Copied! <pre># plot and show the MAD rooting probability for other edges\nc, a, m = mad_tree.draw('p', width=450);\nmad_tree.annotate.add_edge_markers(a, \"r3x1\", size=14, color=\"lightgrey\", mask=False, xshift=0)\nmad_tree.annotate.add_edge_labels(a, \"MAD_root_prob\", mask=False, font_size=11);\n</pre> # plot and show the MAD rooting probability for other edges c, a, m = mad_tree.draw('p', width=450); mad_tree.annotate.add_edge_markers(a, \"r3x1\", size=14, color=\"lightgrey\", mask=False, xshift=0) mad_tree.annotate.add_edge_labels(a, \"MAD_root_prob\", mask=False, font_size=11); 012345678r0r1r2r3r40.10070.10070.14930.14930.14930.14930.201300.51 In\u00a0[17]: Copied! <pre># returns True if root node has &gt;2 children\ntree.is_rooted()\n</pre> # returns True if root node has &gt;2 children tree.is_rooted() Out[17]: <pre>True</pre> In\u00a0[18]: Copied! <pre># get an unrooted copy of the tree\ntree.unroot()\n</pre> # get an unrooted copy of the tree tree.unroot() Out[18]: <pre>&lt;toytree.ToyTree at 0x7da2b3c7f170&gt;</pre> In\u00a0[19]: Copied! <pre># create a copy of the tree\nexample = tree.copy()\n\n# assign hypothetical support values to internal splits\nexample = example.set_node_data(\"support\", {5: 100, 6: 90}, default=\"nan\")\n</pre> # create a copy of the tree example = tree.copy()  # assign hypothetical support values to internal splits example = example.set_node_data(\"support\", {5: 100, 6: 90}, default=\"nan\") <p>Here is an example of how we can explicitly draw the support values using annotations to add edge markers and labels. This function recognized that the edge above nodes 5 and 7 represents the same split in the tree, and thus only one data marker is shown for the support (i.e., the support for the edge to the left of node 7 is also 100).</p> In\u00a0[20]: Copied! <pre># draw the tree and store the drawing objects\nc, a, m = example.draw();\n\n# add node and edge annotations\nexample.annotate.add_node_markers(a, \"o\", size=16, color=\"lightgrey\");\nexample.annotate.add_node_labels(a, \"idx\", font_size=10);\nexample.annotate.add_edge_markers(a, \"r2x1\", size=16, color=\"pink\");\nexample.annotate.add_edge_labels(a, \"support\", font_size=10);\n</pre> # draw the tree and store the drawing objects c, a, m = example.draw();  # add node and edge annotations example.annotate.add_node_markers(a, \"o\", size=16, color=\"lightgrey\"); example.annotate.add_node_labels(a, \"idx\", font_size=10); example.annotate.add_edge_markers(a, \"r2x1\", size=16, color=\"pink\"); example.annotate.add_edge_labels(a, \"support\", font_size=10); r3r4r0r1r2567810090 <p>Note that it is possible to assign support values to both edges, and to force a visualization of them. However, this is incorrect for the case of support values. On the other hand, given the rooting position on this tree, each of these edges does have a different dist value, and if you wanted to visualize these you can do so using node marker annotations like below.</p> In\u00a0[21]: Copied! <pre># draw the tree and store the drawing objects\nc, a, m = example.draw();\n\n# add node and edge annotations\nexample.annotate.add_node_markers(a, \"o\", size=16, color=\"lightgrey\");\nexample.annotate.add_node_labels(a, \"idx\", font_size=10);\nexample.annotate.add_node_markers(a, \"r2x1\", size=17, xshift=-25, mask=(0, 1, 0), color=\"lightgrey\");\nexample.annotate.add_node_labels(a, \"dist\", xshift=-25, font_size=10, mask=(0, 1, 0));\n</pre> # draw the tree and store the drawing objects c, a, m = example.draw();  # add node and edge annotations example.annotate.add_node_markers(a, \"o\", size=16, color=\"lightgrey\"); example.annotate.add_node_labels(a, \"idx\", font_size=10); example.annotate.add_node_markers(a, \"r2x1\", size=17, xshift=-25, mask=(0, 1, 0), color=\"lightgrey\"); example.annotate.add_node_labels(a, \"dist\", xshift=-25, font_size=10, mask=(0, 1, 0)); r3r4r0r1r256780.33330.33330.3333 In\u00a0[22]: Copied! <pre># unroot and re-root several times\ntree.unroot().root('r2').unroot().root('r3', 'r4').draw('p');\n</pre> # unroot and re-root several times tree.unroot().root('r2').unroot().root('r3', 'r4').draw('p'); 012345678r3r4r0r1r200.51 In\u00a0[23]: Copied! <pre># unrooted tree from Czech et al... \nczech = \"((C,D)1,(A,(B,X)3)2,E)R;\"\nctree = toytree.tree(czech, internal_labels=\"name\")\n\n# set data features to color nodes and edges of the unrooted tree\ncolors = {'1': 'red', '2': 'green', '3': 'orange'}\nctree.set_node_data(\"ecolor\", colors, default=\"black\", inplace=True)\nctree.set_node_data(\"ncolor\", colors, default=\"black\", inplace=True);\n</pre> # unrooted tree from Czech et al...  czech = \"((C,D)1,(A,(B,X)3)2,E)R;\" ctree = toytree.tree(czech, internal_labels=\"name\")  # set data features to color nodes and edges of the unrooted tree colors = {'1': 'red', '2': 'green', '3': 'orange'} ctree.set_node_data(\"ecolor\", colors, default=\"black\", inplace=True) ctree.set_node_data(\"ncolor\", colors, default=\"black\", inplace=True); In\u00a0[24]: Copied! <pre># create a reusable dict for other style options for visualization\nkwargs = {\n    'layout': 'd',\n    'use_edge_lengths': False,\n    'node_sizes': 10,\n    'node_labels': 'name',\n    'node_labels_style': {\n        'font-size': 20,\n        'baseline-shift': 10,\n        'anchor-shift': 10,\n    }}\n</pre> # create a reusable dict for other style options for visualization kwargs = {     'layout': 'd',     'use_edge_lengths': False,     'node_sizes': 10,     'node_labels': 'name',     'node_labels_style': {         'font-size': 20,         'baseline-shift': 10,         'anchor-shift': 10,     }} In\u00a0[25]: Copied! <pre># draw original unrooted tree\nctree.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs);\n</pre> # draw original unrooted tree ctree.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs); 132RCDABXE <p>When we root the tree on the edge above \"X\" this changes the orientation of several nodes on the tree, such that some which were parents of another before now appear as children of that node. This has the important consequence for how the edge between these nodes is interpreted. For example, the yellow edge which previously represented information about the split separating (B,X) from every other node (e.g., see tree drawing above) now instead represents the split between X and every other node (e.g., see re-rooted tree below). Similarly, the green edge which previously represented the split between (A,B,X) versus (C,D,E) now represents the split between (B,X) versus (A,C,D,E). Although this was a correct re-orientation of Nodes during rooting, this is actually an incorrect polarization of the edge information. This is something we can fix by designating which additional features stored to the ToyTree represent edge versus node data.</p> In\u00a0[26]: Copied! <pre># root the tree w/o indicating edge_features, error!\nrtree1 = ctree.root(\"X\")\nrtree1.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs);\n</pre> # root the tree w/o indicating edge_features, error! rtree1 = ctree.root(\"X\") rtree1.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs); 1R23rootXBACDE <p>Here to correct for the fact the \"ecolor\" (edge colors) is a data feature of edges, we can specify this is the list of <code>edge_features</code>, which will change how they are polarized during the rooting. Now the yellow edge points down from node 3 rather than up, retaining that this edge feature represents information about the split between nodes 2 and 3. Note: the distance and support features were already automatically handled in this way.</p> In\u00a0[27]: Copied! <pre># re-root, treating 'ecolor' but not 'ncolor' as an edge feature.\nrtree2 = ctree.root(\"X\", edge_features=[\"ecolor\"])\nrtree2.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs);\n</pre> # re-root, treating 'ecolor' but not 'ncolor' as an edge feature. rtree2 = ctree.root(\"X\", edge_features=[\"ecolor\"]) rtree2.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs); 1R23rootXBACDE <p>Edge Features</p> <p>     Note that designating data features as being an _edge_feature_ is automatically handled by toytree for \"edge\" and \"dist\" features,     since these are always known to apply to edges. Similarly, we know that \"name\" and \"idx\" are always features of nodes. Any other      features that are added by you represent your own data, and thus it is up to you to speficy their data type during rooting. This     includes features such as \"MAD\" if you re-root a tree after    </p> In\u00a0[28]: Copied! <pre>tree.edge_features\n</pre> tree.edge_features Out[28]: <pre>{'MAD', 'MAD_root_prob', 'dist', 'support'}</pre> <p>You can see in this example that you can assign \"ecolor\" to the <code>edge_features</code> attribute of the tree, rather than indicating it during the <code>root</code> call, and <code>root</code> will know that this feature is of edges without having to indicate it each time.</p> In\u00a0[29]: Copied! <pre># create a copy of the czech tree that has ecolors and ncolors\netree = ctree.copy()\n\n# you can assign 'ecolors' to the tree's edge_features set\netree.edge_features.add(\"ecolor\")\n\n# root the tree (ecolors will be treated as an edge feature automatically\nrtree2 = etree.root(\"X\")\n\n# visualize that it is correct\nrtree2.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs);\n</pre> # create a copy of the czech tree that has ecolors and ncolors etree = ctree.copy()  # you can assign 'ecolors' to the tree's edge_features set etree.edge_features.add(\"ecolor\")  # root the tree (ecolors will be treated as an edge feature automatically rtree2 = etree.root(\"X\")  # visualize that it is correct rtree2.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs); 1R23rootXBACDE"},{"location":"rooting/#rooting-trees","title":"Rooting trees\u00b6","text":"<p>Rooting or re-rooting trees orients the direction of ancestor-descendant relationships and thus provides \"polarization\" for the direction of evolution. Most tree inference algorithms return an unrooted tree as a result, and it is up to the researcher to select the placement of the root based on external information (e.g., outgroup designation) or analytical methods (e.g., based on edge lengths; embedding into a species tree; or gene duplication patterns).</p> <p>This tutorial section provides background on how rooting or re-rooting affects a tree data structure and how to choose the edge and position on which to root a tree. It also clarifies several common misconceptions and sources of error during tree rooting.</p>"},{"location":"rooting/#the-treenode","title":"The treenode\u00b6","text":"<p>All ToyTree objects contain a node that is designated the treenode, and which represents the top level <code>Node</code> object in the collection of nodes that make up the tree hierarchy. This node exists in a tree whether it is rooted or unrooted. We use the term treenode rather than root node to refer to this top level node, since it is not always a true root node, as in the case of an unrooted tree. This can be a confusing point, but understanding it will help to make clear what the process of tree rooting actually represents. It is a little more complex than simply moving or relabeling a node, as described for the three operations below.</p>"},{"location":"rooting/#rooting","title":"Rooting\u00b6","text":"<p>When rooting an unrooted tree, a new node is inserted on an edge, splitting it into two (it helps me to think of it visually as pinching the edge and pulling it back to insert the node). The new node serves as the treenode. The number of nodes in the tree increases by 1.</p>"},{"location":"rooting/#unrooting","title":"Unrooting\u00b6","text":"<p>When unrooting a rooted tree, the current treenode is removed, and an existing node in the tree (the previous treenode's left child) is designated as the treenode. The number of nodes in the tree decreases by 1.</p>"},{"location":"rooting/#re-rooting","title":"Re-rooting\u00b6","text":"<p>When re-rooting a rooted tree, the current treenode is removed and a new node is inserted on a different edge of the tree. The new node is assigned as the treenode. The number of nodes in the tree does not change.</p>"},{"location":"rooting/#accessing-the-treenode","title":"Accessing the treenode\u00b6","text":"<p>The treenode can be accessed from a ToyTree from its <code>.treenode</code> attribute, or by indexing. Because it is always the last Node in idx order it can be indexed by -1.</p>"},{"location":"rooting/#rooting-visualized","title":"Rooting visualized\u00b6","text":"<p>You cannot verify that a tree is unrooted based simply on a visualization, since an unrooted tree can look the same as a rooted tree that contains a polytomy at its root. Thus, it is best practice to mention in a figure legend whether and how a tree is rooted. Another way of hinting that a tree is rooted versus unrooted is by using different tree layouts for visualization. This is demonstrated below.</p> <p>This first set of drawing uses the default linear down ('d') layout. This places the treenode at the top of the drawing, which makes it easy to interpret how far each other node is from the treenode. This style makes sense for interpreting rooted trees (left and right), but is misleading for the unrooted tree (middle), since it gives the impression visually that the tree is rooted at node 7.</p>"},{"location":"rooting/#rooting-methods","title":"Rooting methods\u00b6","text":"<p><code>toytree</code> currently supports three methods for rooting a tree: (1) manually; (2) by the midpoint (Farris 1972); and (3) by the minimal ancestor deviation (Tria et al. 2017). The first requires the user to designate the outgroup and optionally specify the length along the edge at which to insert the new root node. The second method automatically places the root node on an edge that is average distance from all terminal nodes. The last method calculates a set of statistics that can be used to either automatically place the root node, or to provide a score for an alternative manual placement. The first two approaches are instantaneously fast, while the last one can take a few seconds for large trees.</p> <p>The most common methods, <code>.root()</code> and <code>.unroot</code>, are available from a <code>ToyTree</code> object. These are also available in the <code>toytree.mod</code> subpackage, where the other optional rooting functions are also located. Each is demonstrated with further explanation below.</p>"},{"location":"rooting/#manually-set-outgroup","title":"Manually set outgroup\u00b6","text":"<p>The <code>.root()</code> function requires manually designating an outgroup. Specifically, you are designating the node for which the edge above it will be bisected by the new treenode. The clade composed of the selected node and its descendants is designated the outgroup, and the clade of everything else on the other side of the root is the ingroup. To select the edge on which to root the tree, you must designate arguments to select the node that is below it given the current directed layout of the tree. You can enter the index or name of a single Node, or, if you provide multiple Node selectors then it will find the MRCA of the selected Nodes and root on that Node's edge. In the example below I select two named tip Nodes by their str names, \"r3\" and \"r4\", which selects their mrca ancestor to root on.</p>"},{"location":"rooting/#midpoint-deviation","title":"Midpoint deviation\u00b6","text":"<p>Rooting on the \"midpoint\" assumes a clock-like evolutionary rate (i.e., branch lengths are equal to time) and may yield odd results when this assumption is violated. This algorithm finds the root position by calculating the pairwise path length between all tips in an unrooted tree, and places the treenode on an edge representing the midpoint of the longest path.</p>"},{"location":"rooting/#balanced-midpoint-deviation","title":"Balanced Midpoint deviation\u00b6","text":"<p>Rooting on the \"balanced midpoint\" also assumes a clock-like evolutionary rate. This algorithm finds the root position by minimizing the max length from the root to all tips. It runs at similar speed to midpoint deviation but should be less sensitive to the presence of outlier branches.</p>"},{"location":"rooting/#minimal-ancestor-deviation","title":"Minimal-ancestor-deviation\u00b6","text":"<p>The minimal ancestor deviation (MAD) rooting method is intended to accommodate rate heterogeneity among edges of a tree when inferring the root state of an unrooted tree. It assumes that branch lengths are additive and that the true tree is ultrametric (i.e., tip height variation results from rate heterogeneity). This method finds the point on every edge that minimizes the deviations from all pairwise midpoint rooting positions. The optimal rooting position is on the edge with the lowest MAD score, but the user can also manually select a suboptimal edge and assess its relative score compared to alternative root placements (See Inferring the root below.)</p>"},{"location":"rooting/#root-dist","title":"Root dist\u00b6","text":"<p>When rooting a tree it is important not only to select the correct edge on which to place the treenode, but also the correct position on that edge. For example, the edge could be split at its midpoint, or closer to one child node than the other. The true rooting position is not known, and so this is a place where a model-based inference can be useful. One common assumption is that the tree should be as close to ultrametric as possible, and thus a position should be selected on the edge that best aligns the tip nodes. This is approach taken by the midpoint and minimal-ancestor-deviation methods. In addition, the user can set a position manually using the manual rooting method. If the <code>root_dist</code> arg is left at its <code>default=None</code> setting in the <code>root</code> function then the edge midpoint will be used. Below I show two manual assignments of the root dist selecting either 0.1 units or 0.6 units up from the selected Node.</p>"},{"location":"rooting/#infer-root-w-mad","title":"Infer root w/ MAD\u00b6","text":"<p>It is always best practice to include an outgroup in phylogenetic analyses, but in some cases the outgroup may be unknown or unavailable. In such cases it can be useful to apply methods for inferring the most likely root state based on edge length information. The best method for this currently implemented in <code>toytree</code> is using the minimal ancestor deviation score.</p> <p>The <code>root_on_minimal_ancestor_deviation</code> function in <code>toytree.mod</code> calculates the MAD score and the root probabilities for each edge in the tree. By default these scores are stored as edge features on the returned tree. In addition, global score info can be returned by using <code>return_stats=True</code> argument. This includes the <code>minimal_ancestor_deviation</code> score for the rooting edge (lower is better); the <code>root_ambiguity_index</code> (whether another edge is as good as the selected one. Lower is better); and the <code>root_clock_coefficient_of_variation</code> (how variable rates are, i.e., how non-ultrametric the tree is.) This is demonstrated below for an example where the rooted tree is ultrametric, and a case where it is very much not.</p>"},{"location":"rooting/#mad-statistics","title":"MAD statistics\u00b6","text":"<p>When using <code>return_stats=True</code> this function returns two objects, the tree and a dictionary. In this example tree (shown above) the values of each statistic are very low. A low value for the deviation, ambiguity, and variation indicates that the data do not deviate much from a molecular clock, i.e., there is high confidence in this rooting under our assumed model.</p>"},{"location":"rooting/#compare-mad-rootings","title":"Compare MAD rootings\u00b6","text":"<p>Whether or not you use the argument <code>return_stats=True</code>, statistics of the MAD analysis will be stored to Node's of the return ToyTree. This is one of the real strengths of the MAD approach: it not only finds the best edge on which to root a tree, but it also reports scores for all alternative rootings, and how much better one is than another. You can examine this data stored inside the returned ToyTree object. This is returned for each edge on the tree as a \"MAD\" and \"MAD_root_prob\" score feature. For example, in the tree below, the MAD score for the correct root position is 0.0, indicating that the tree is perfectly ultrametric when rooted at this position. The MAD rooting function correctly infers that this is the best root position, and assigns it as the root. The MAD_root_prob for this edge is 0.20 (the same probability is assigned to nodes 5 and 7, since they share edge on which the root node is placed. As we saw above, the global `root_ambiguity_index' for this rooting was 0.0, meaning that the 0.201 probability for this placement is significantly better than the 0.15 root probability for the next highest scoring edge.</p>"},{"location":"rooting/#check-root-status","title":"Check root status\u00b6","text":"<p>A method to check whether a tree is rooted based on resolution of the treenode. Note: this does not distinguish between a tree actually being rooted versus whether the treenode is a polytomy. This method simply returns a boolean for whether the root node has &gt;2 children. It is nevertheless still quite useful.</p>"},{"location":"rooting/#unrooting","title":"Unrooting\u00b6","text":"<p>The <code>unroot</code> function can be called to unroot a rooted tree. In an unrooted tree the treenode is always a polytomy. A rooted bifurcating tree has <code>nnodes = (ntips * 2) - 1</code>, whereas an unrooted bifurcating tree has nnodes = <code>(ntips * 2) - 2</code>. In other words, converting from a rooted to unrooted state removes one node (the former treenode) from the tree, and assigns an existing node as the new treenode.</p>"},{"location":"rooting/#featuresdata-and-rooting","title":"Features/Data and Rooting\u00b6","text":"<p>The processes of rooting, unrooting, or re-rooting trees should be reversible, meaning that the operations can be performed in any order without the loss of information about the topology, branch lengths, or any associated meta-data/features. This is the goal in <code>toytree</code> and it is always achieved for the case of the topology and branch lengths, but requires some user knowledge when dealing with arbitrary additional data features assigned to the tree. This is because data can be stored to a tree as either a feature of nodes, or of edges. Some data stored to a tree are intended to represent information about the edges (splits) in a tree, rather than information about the nodes. This is important as these types of data must be treated differently when doing things like re-rooting a tree, and in some cases, for visualization.</p>"},{"location":"rooting/#support-values","title":"Support values\u00b6","text":"<p>The way in which support values are displayed on trees is often a source of confusion. This is because support values are often plotted on the nodes of a tree, despite the fact that they are actually features of the edges of a tree. One consequence of this is that the edge which spans the treenode in a tree drawing actually may appear as if it has two separate support values, when in fact this edge only has one support value. There are a few options for how you can change this in a tree drawing to make it more clear. In the example below</p>"},{"location":"rooting/#information-loss","title":"Information loss\u00b6","text":"<p>Is information lost when a tree is unrooted and then re-rooted? The answer is no, as long as the proper <code>root_dist</code> and <code>edge_features</code> information is provided.</p>"},{"location":"rooting/#example-from-paper","title":"Example from paper\u00b6","text":"<p>This problem was well described in the \"A critical review on the use of support values in tree viewers and   bioinformatics toolkits\" by Czech et al. (2017). In the cell below I parse the newick string of the example problem, which involves a tree with names assigned to both tip and internal nodes. The problem is that when the tree is rooted on a new edge the internal edge information is sometimes not propertly polarized, e.g., one or more support values are assigned to the wrong edges. Here to demonstrate that <code>toytree</code> handles this case correctly I show the example and use visualizations that assign colors separately to the nodes and edges to make it easy to follow.</p>"},{"location":"rooting/#assign-a-feature-to-edges","title":"Assign a feature to edges\u00b6","text":"<p>If want to set a feature to be treated as an <code>edge_feature</code> just once, and then forget it, you can set it to the <code>edge_features</code> attribute of a ToyTree object. You can also check this attribute to see which features are currently being treated as edge features automatically. As we said, 'dist' and 'support' are in here. Also, when you root a tree using the <code>minimal_ancestor_deviation</code> method the MAD stats are automatically added to this set. You can assign additional features here as well.</p>"},{"location":"scratch/","title":"Scratch","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np In\u00a0[2]: Copied! <pre># an example tree\ntree = toytree.rtree.unittree(ntips=5, seed=123)\n</pre> # an example tree tree = toytree.rtree.unittree(ntips=5, seed=123) In\u00a0[46]: Copied! <pre>import toyplot\n\npalette = toyplot.color.Palette(['red', 'green', 'blue'])\ncmap = toyplot.color.LinearMap(palette, domain_min=0, domain_max=1)\ncmap\n</pre> import toyplot  palette = toyplot.color.Palette(['red', 'green', 'blue']) cmap = toyplot.color.LinearMap(palette, domain_min=0, domain_max=1) cmap Out[46]: In\u00a0[50]: Copied! <pre>cmap.colors([0, 0.25, 0.5, 0.75, 1.0])\n</pre> cmap.colors([0, 0.25, 0.5, 0.75, 1.0]) Out[50]: In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[3]: Copied! <pre># set a color name as 'red' or 'blue' to all nodes for feature \"C\"\ntree.set_node_data(\"C\", {6: \"red\"}, inherit=True, default=\"blue\", inplace=True);\ntree.get_node_data(\"C\")\n</pre> # set a color name as 'red' or 'blue' to all nodes for feature \"C\" tree.set_node_data(\"C\", {6: \"red\"}, inherit=True, default=\"blue\", inplace=True); tree.get_node_data(\"C\") Out[3]: <pre>0     red\n1     red\n2     red\n3    blue\n4    blue\n5     red\n6     red\n7    blue\n8    blue\ndtype: object</pre> In\u00a0[4]: Copied! <pre># set a color name as 'red' or 'blue' to all nodes for feature \"C\"\ntree.set_node_data(\"A\", {6: \"A\"}, inherit=True, default=\"B\", inplace=True);\ntree.get_node_data(\"A\")\n</pre> # set a color name as 'red' or 'blue' to all nodes for feature \"C\" tree.set_node_data(\"A\", {6: \"A\"}, inherit=True, default=\"B\", inplace=True); tree.get_node_data(\"A\") Out[4]: <pre>0    A\n1    A\n2    A\n3    B\n4    B\n5    A\n6    A\n7    B\n8    B\ndtype: object</pre> In\u00a0[5]: Copied! <pre># set random float values in (0-1) to all nodes for feature \"D\"\ntree.set_node_data(\"D\", np.random.random(tree.nnodes), inplace=True);\ntree.get_node_data(\"D\")\n</pre> # set random float values in (0-1) to all nodes for feature \"D\" tree.set_node_data(\"D\", np.random.random(tree.nnodes), inplace=True); tree.get_node_data(\"D\") Out[5]: <pre>0    0.252134\n1    0.473288\n2    0.125519\n3    0.207844\n4    0.180335\n5    0.496407\n6    0.729994\n7    0.126836\n8    0.012640\ndtype: float64</pre> In\u00a0[6]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors='red');\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors='red'); r0r1r2r3r4 In\u00a0[7]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=(0, 1, 1, 0.5));\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=(0, 1, 1, 0.5)); r0r1r2r3r4 In\u00a0[8]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=tree.get_node_data(\"C\"));\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=tree.get_node_data(\"C\")); r0r1r2r3r4 In\u00a0[9]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=\"C\");\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=\"C\"); r0r1r2r3r4 In\u00a0[10]: Copied! <pre>cvalues = tree.get_node_data(\"A\").values\ncvalues = [str(i) for i in cvalues]\ncvalues = [\"~~\" + i if i == \"nan\" else i for i in cvalues]\n\nnp.unique(cvalues, return_inverse=True)\n</pre> cvalues = tree.get_node_data(\"A\").values cvalues = [str(i) for i in cvalues] cvalues = [\"~~\" + i if i == \"nan\" else i for i in cvalues]  np.unique(cvalues, return_inverse=True) Out[10]: <pre>(array(['A', 'B'], dtype='&lt;U1'), array([0, 0, 0, 1, 1, 0, 0, 1, 1]))</pre> In\u00a0[11]: Copied! <pre>import toyplot\ncmap = toyplot.color.brewer.map(\"Spectral\")\n</pre> import toyplot cmap = toyplot.color.brewer.map(\"Spectral\") In\u00a0[12]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=\"D\");\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=\"D\"); r0r1r2r3r4 In\u00a0[14]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=(\"D\", \"Spectral\"));\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=(\"D\", \"Spectral\")); r0r1r2r3r4 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"sim_continuous_bm/","title":"sim cont. traits BM","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># tree used in examples\ntree = toytree.rtree.unittree(ntips=6, treeheight=1.0, seed=123)\n</pre> # tree used in examples tree = toytree.rtree.unittree(ntips=6, treeheight=1.0, seed=123) In\u00a0[3]: Copied! <pre># call from the module-level API\ntrait = toytree.pcm.simulate_continuous_bm(tree, rates=1.0)\n\n# call from the tree-level API (equivalent to above)\ntrait = tree.pcm.simulate_continuous_bm(rates=1.0);\n</pre> # call from the module-level API trait = toytree.pcm.simulate_continuous_bm(tree, rates=1.0)  # call from the tree-level API (equivalent to above) trait = tree.pcm.simulate_continuous_bm(rates=1.0); In\u00a0[4]: Copied! <pre># simulate one trait on the tree\ntoytree.pcm.simulate_continuous_bm(tree, rates=1.0)\n</pre> # simulate one trait on the tree toytree.pcm.simulate_continuous_bm(tree, rates=1.0) Out[4]: t0 0 -0.123130 1 -0.367562 2 0.037406 3 0.361301 4 -1.829936 5 1.160787 6 -0.230188 7 0.453950 8 -0.152855 9 -0.488458 10 0.000000 In\u00a0[5]: Copied! <pre># simulate three traits with different sigma2 params\ntoytree.pcm.simulate_continuous_bm(tree, rates=[1.0, 2.0, 3.0])\n</pre> # simulate three traits with different sigma2 params toytree.pcm.simulate_continuous_bm(tree, rates=[1.0, 2.0, 3.0]) Out[5]: t0 t1 t2 0 0.327413 0.201442 -1.901418 1 -0.311619 -0.558166 -0.000391 2 0.008609 0.706444 1.415715 3 -0.359562 0.846861 0.846022 4 -0.169758 1.168309 2.318473 5 -1.912181 1.103331 1.432499 6 -0.029991 -0.339502 -0.845061 7 -0.165949 0.614321 0.461416 8 -0.266276 -0.009451 -0.513884 9 -0.905512 0.444233 0.939258 10 0.000000 0.000000 0.000000 In\u00a0[6]: Copied! <pre># use a dict to assign custom names to traits\ntoytree.pcm.simulate_continuous_bm(tree, rates={\"size\": 1.0, \"speed\": 5.0})\n</pre> # use a dict to assign custom names to traits toytree.pcm.simulate_continuous_bm(tree, rates={\"size\": 1.0, \"speed\": 5.0}) Out[6]: size speed 0 0.191103 -4.119331 1 0.273508 -1.693085 2 -0.397871 -4.093221 3 -0.500289 -1.497661 4 -1.056051 2.326184 5 -1.093082 0.777344 6 0.370993 -1.802604 7 -0.691834 -4.372475 8 0.032350 -2.116944 9 -0.668472 1.512406 10 0.000000 0.000000 In\u00a0[7]: Copied! <pre># simulate traits and store only for the tips\ntoytree.pcm.simulate_continuous_bm(tree, rates=[1.0], tips_only=True)\n</pre> # simulate traits and store only for the tips toytree.pcm.simulate_continuous_bm(tree, rates=[1.0], tips_only=True) Out[7]: t0 0 1.437384 1 1.015807 2 0.019017 3 0.255915 4 0.701643 5 0.239817 In\u00a0[8]: Copied! <pre># simulate three traits with different sigma2 params\ntoytree.pcm.simulate_continuous_bm(tree, rates=[1.0, 2.0, 3.0], root_states=[10, 12, 50])\n</pre> # simulate three traits with different sigma2 params toytree.pcm.simulate_continuous_bm(tree, rates=[1.0, 2.0, 3.0], root_states=[10, 12, 50]) Out[8]: t0 t1 t2 0 9.234072 13.078664 53.680268 1 9.809092 12.646147 53.121963 2 9.489151 12.000104 53.999656 3 9.893895 11.322589 51.947425 4 11.145741 13.803036 53.737769 5 9.708878 12.179884 50.373467 6 9.940027 12.584615 52.620478 7 9.271315 11.285911 52.907048 8 9.511940 12.815645 51.751943 9 10.059270 12.185471 51.298720 10 10.000000 12.000000 50.000000 In\u00a0[9]: Copied! <pre># save simulated traits to the ToyTree\ntoytree.pcm.simulate_continuous_bm(tree, rates=[1.0, 2.0], inplace=True)\n\n# fetch simulated trait feature data from the tree\ntree.get_node_data([\"t0\", \"t1\"])\n</pre> # save simulated traits to the ToyTree toytree.pcm.simulate_continuous_bm(tree, rates=[1.0, 2.0], inplace=True)  # fetch simulated trait feature data from the tree tree.get_node_data([\"t0\", \"t1\"]) Out[9]: t0 t1 0 -0.130727 -1.141893 1 0.301832 -0.302874 2 -0.624571 -1.659822 3 -0.820687 -1.623450 4 -0.367290 0.166104 5 -0.136680 1.225382 6 0.002804 -0.984722 7 -0.576153 -1.148334 8 -0.495188 -0.721662 9 -0.593774 -0.603338 10 0.000000 0.000000 <p>One motivation for this option is that it makes it very easy to visualize the traits on a tree drawing, where you can select the traits by name rather than entering in the trait variable. Here we use color mapping to draw node colors scaled to the Greys colormap.</p> In\u00a0[10]: Copied! <pre># draw the tree and show trait t0 values \ntree.draw(node_sizes=10, node_colors=(\"t0\", \"Greys\"), node_mask=False, label=\"trait 't0'\");\n</pre> # draw the tree and show trait t0 values  tree.draw(node_sizes=10, node_colors=(\"t0\", \"Greys\"), node_mask=False, label=\"trait 't0'\"); r0r1r2r3r4r5trait 't0' In\u00a0[11]: Copied! <pre># TODO\n</pre> # TODO In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"sim_continuous_bm/#simulate-continuous-traits","title":"Simulate continuous traits\u00b6","text":"<p>Simulate one or more continuous traits under one or more models of trait evolution.</p>"},{"location":"sim_continuous_bm/#brownian-motion","title":"Brownian motion\u00b6","text":"<p>The amount of change in a continuous trait over a given time interval can be modeled under Brownian motion as the result of a random walk. At each time step the value changes by an amount randomly sampled from a normal distribution with mean=0 and variance described by an evolutionary rate parameter, $\\sigma^2$. To model the change over an interval of time (e.g. a branch length) a random value is sampled from a normal distribution with mean=0 and variance as the product of the branch length and rate parameter ($\\sigma^2 t$).</p>"},{"location":"sim_continuous_bm/#simulate_continuous_bm","title":"simulate_continuous_bm\u00b6","text":"<p>Simulated traits are labeled t0-tN for N traits, unless the <code>rates</code> arg is entered as a mapping (e.g., dict) in which case traits can be given custom names. By default, simulated data are returned as a pandas DataFrame, however, you can alternatively use the argument <code>inplace=True</code> to store simulated traits to Node objects of the input tree. These options and others are demonstrated below. The <code>simulate_continuous_bm</code> function is available from both the module-level and object-level APIs.</p>"},{"location":"sim_continuous_bm/#rates","title":"rates\u00b6","text":"<p>The rates takes one or more $\\sigma^2$ evolutionary rate parameters. Note that the variance in a trait over the length of a branch is a product of the rate parameter and branch length, and thus you should take into account the branch length units of your tree when selecting rate parameters.</p>"},{"location":"sim_continuous_bm/#tips_only","title":"tips_only\u00b6","text":"<p>The data simulated above includes a trait value for every node in the tree, including internal nodes. However, in many cases we may be only interested in the traits at the tips of the tree. The argument <code>tips_only</code> will return on the simulated values for the tip nodes. (Note that the simulation process requires generating values for internal nodes, so you are effectively discarding that information when using this option, but it can be useful to keep things tidy).</p>"},{"location":"sim_continuous_bm/#root_states","title":"root_states\u00b6","text":"<p>You can set the root state for one or more simulated traits using the option <code>root_states</code>. The default root_state is 0. You can see this in the first few simulations above where the root node (node 10) has a value of 0.0 for each trait. Below we simulate the same tree traits but with different starting (root) values.</p>"},{"location":"sim_continuous_bm/#inplace","title":"inplace\u00b6","text":"<p>By default the simulate data are returned in a pandas DataFrame where the index corresponds to the numeric idx labels of Nodes in the tree. Alternatively, you can use <code>inplace=True</code> to store the simulated traits as one or more features saved to Nodes of the tree.</p>"},{"location":"sim_continuous_bm/#multivariate-brownian-motion","title":"Multivariate Brownian motion\u00b6","text":"<p>To simulate traits with correlated evolution you can enter a variance-covariance matrix for the <code>rates</code> option. This can be be a list of lists, numpy array, or pandas DataFrame.</p>"},{"location":"spacing/","title":"Spacing tree vs. tip names","text":"In\u00a0[16]: Copied! <pre>import numpy as np\nimport toytree\nimport toyplot\n\n# generate a random tree and data\nntips = 20\nrseed = 123456\nrtre = toytree.rtree.unittree(ntips=ntips, seed=rseed)\n\n# names of different lengths\nnames = [\"\".join(np.random.choice(list(\"abcd\"), i + 1)) for i in range(ntips)]\n\n# make a canvas and coords for two plots\ncanvas = toyplot.Canvas(width=600, height=350)\nax0 = canvas.cartesian(grid=(1, 2, 0), yshow=False)\nax1 = canvas.cartesian(grid=(1, 2, 1), yshow=False)\n\n# plot the tree with its default spacing for tree and names\nrtre.draw(tip_labels=names, axes=ax0);\n\n# plot the tree on the second axis\nrtre.draw(tip_labels=names, axes=ax1, shrink=500);\n</pre> import numpy as np import toytree import toyplot  # generate a random tree and data ntips = 20 rseed = 123456 rtre = toytree.rtree.unittree(ntips=ntips, seed=rseed)  # names of different lengths names = [\"\".join(np.random.choice(list(\"abcd\"), i + 1)) for i in range(ntips)]  # make a canvas and coords for two plots canvas = toyplot.Canvas(width=600, height=350) ax0 = canvas.cartesian(grid=(1, 2, 0), yshow=False) ax1 = canvas.cartesian(grid=(1, 2, 1), yshow=False)  # plot the tree with its default spacing for tree and names rtre.draw(tip_labels=names, axes=ax0);  # plot the tree on the second axis rtre.draw(tip_labels=names, axes=ax1, shrink=500); ddcdcccaccacdcbacbaabbbbcdcdacbbbdccbdabcdddbcddcacaabcddcbaaccbdcdbaababbcaacaaaacaadcabcababdbdcdadacbacaddddabcdcbcbbcabddbbccdabcbdcbabacdbacccdadcbdaaacdccbdabbcddbbbdbccdcabcaadbadcbddcabdbbcaddbacccccdcd-1.0-0.50.00.51.01.5ddcdcccaccacdcbacbaabbbbcdcdacbbbdccbdabcdddbcddcacaabcddcbaaccbdcdbaababbcaacaaaacaadcabcababdbdcdadacbacaddddabcdcbcbbcabddbbccdabcbdcbabacdbacccdadcbdaaacdccbdabbcddbbbdbccdcabcaadbadcbddcabdbbcaddbacccccdcd-101234"},{"location":"spacing/#spacing-tree-vs-tip-names","title":"Spacing tree vs. tip names\u00b6","text":"<p>The ratio of tree to tipnames on a plot is automatically adjusted to try to fit the tip names depending on their font and size, but only to an extent before the tipnames are eventually cutoff. If you want to manually adjust this ratio by squeezing the tree to take up less space this can be done by using the <code>shrink</code> parameter, as demonstrated below.</p> <p>In the plot below I show the x-axis tick marks to highlight where the data are located on the x, and where the domain is by default and when extended. You can see that in both cases the treeheight is between 0 and -1 on the x-axis. But in the latter we extend the max domain from 1.5 to 4 which better accomodates the really long tipnames. Of course you can also increase the <code>width</code> of the entire canvas as well to increase spacing.</p>"},{"location":"test/","title":"Tree I/O","text":"<p>Tree data in its simplest form is very simple. Metadata can be very rich. Formats for storing trees has evolved over time. tldr; the <code>toytree.tree</code> function can flexibly parse most formats. newick, nexus, and NHX format.</p> <pre><code>import toytree\n</code></pre>"},{"location":"test/#parsing-tldr","title":"Parsing tldr;","text":"<pre><code># a simple newick string\nNEWICK = \"(((a,b),c),d);\"\n\n# load newick as a ToyTree object\ntree = toytree.tree(NEWICK)\nprint(tree)\n</code></pre> <pre><code>...\n</code></pre>"},{"location":"test/#from-a-string","title":"From a string","text":""},{"location":"test/#from-a-file","title":"From a file","text":""},{"location":"test/#from-a-url","title":"From a URL","text":""},{"location":"toytree/","title":"ToyTree","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># generate a random uniform tree\ntree = toytree.rtree.unittree(8, seed=123)\n</pre> # generate a random uniform tree tree = toytree.rtree.unittree(8, seed=123) In\u00a0[3]: Copied! <pre>tree[0]\n</pre> tree[0] Out[3]: <pre>&lt;Node(idx=0, name='r0')&gt;</pre> In\u00a0[4]: Copied! <pre>tree[1:3]\n</pre> tree[1:3] Out[4]: <pre>[&lt;Node(idx=1, name='r1')&gt;, &lt;Node(idx=2, name='r2')&gt;]</pre> In\u00a0[5]: Copied! <pre>for node in tree:\n    print(node)\n</pre> for node in tree:     print(node) <pre>&lt;Node(idx=0, name='r0')&gt;\n&lt;Node(idx=1, name='r1')&gt;\n&lt;Node(idx=2, name='r2')&gt;\n&lt;Node(idx=3, name='r3')&gt;\n&lt;Node(idx=4, name='r4')&gt;\n&lt;Node(idx=5, name='r5')&gt;\n&lt;Node(idx=6, name='r6')&gt;\n&lt;Node(idx=7, name='r7')&gt;\n&lt;Node(idx=8)&gt;\n&lt;Node(idx=9)&gt;\n&lt;Node(idx=10)&gt;\n&lt;Node(idx=11)&gt;\n&lt;Node(idx=12)&gt;\n&lt;Node(idx=13)&gt;\n&lt;Node(idx=14)&gt;\n</pre> In\u00a0[6]: Copied! <pre># show node idx labels of cached idxorder traversal\ntree.draw('p');\n</pre> # show node idx labels of cached idxorder traversal tree.draw('p'); 01234567891011121314r0r1r2r3r4r5r6r700.51 In\u00a0[7]: Copied! <pre># the root node\ntree.treenode\n</pre> # the root node tree.treenode Out[7]: <pre>&lt;Node(idx=14)&gt;</pre> In\u00a0[8]: Copied! <pre># also the root node\ntree[-1]\n</pre> # also the root node tree[-1] Out[8]: <pre>&lt;Node(idx=14)&gt;</pre> In\u00a0[9]: Copied! <pre># the root has no parent Node (.up returns None)\ntree.treenode.up\n</pre> # the root has no parent Node (.up returns None) tree.treenode.up <p>A rooted bifurcating tree has <code>nnodes = (ntips * 2) - 1</code>, whereas an unrooted bifurcating tree has <code>nnodes = (ntips * 2) - 2</code>. In other words converting from rooted to unrooted, or vice-versa, involves adding or removing a node from the tree. In an unrooted tree the root node is always a polytomy. (See the Tree rooting tutorial for further details.) This can be seen more clearly by plotting trees in an unrooted layout. The splits in the tree are the same regardless of the root node's placement. In the rooted tree (left) it is on a branch, and has two connected edges (a degree of 2). On the unrooted tree (right) it is on a node of the tree and connected to three edges (of degree 3).</p> In\u00a0[10]: Copied! <pre>toytree.mtree([tree, tree.unroot()]).draw(\n    layout='unr',\n    node_sizes=16, \n    node_labels=\"idx\",\n    node_mask=(0,0,1),\n);\n</pre> toytree.mtree([tree, tree.unroot()]).draw(     layout='unr',     node_sizes=16,      node_labels=\"idx\",     node_mask=(0,0,1), ); 14r0r1r2r3r4r5r6r713r0r1r2r3r4r5r6r7 In\u00a0[11]: Copied! <pre>tree.ntips\n</pre> tree.ntips Out[11]: <pre>8</pre> In\u00a0[12]: Copied! <pre>tree.nnodes\n</pre> tree.nnodes Out[12]: <pre>15</pre> In\u00a0[13]: Copied! <pre>tree.treenode\n</pre> tree.treenode Out[13]: <pre>&lt;Node(idx=14)&gt;</pre> In\u00a0[14]: Copied! <pre>tree.features\n</pre> tree.features Out[14]: <pre>('idx', 'name', 'height', 'dist', 'support')</pre> In\u00a0[15]: Copied! <pre>tree.edge_features\n</pre> tree.edge_features Out[15]: <pre>{'dist', 'support'}</pre> In\u00a0[16]: Copied! <pre># does the tree not contain any polytomies\ntree.is_bifurcating()\n</pre> # does the tree not contain any polytomies tree.is_bifurcating() Out[16]: <pre>True</pre> In\u00a0[17]: Copied! <pre># is the tree rooted\ntree.is_rooted()\n</pre> # is the tree rooted tree.is_rooted() Out[17]: <pre>True</pre> In\u00a0[18]: Copied! <pre># query if set of tip nodes is monophyletic\ntree.is_monophyletic(\"r3\", \"r2\", \"r1\"), tree.is_monophyletic(\"r3\", \"r2\", \"r1\", \"r0\")\n</pre> # query if set of tip nodes is monophyletic tree.is_monophyletic(\"r3\", \"r2\", \"r1\"), tree.is_monophyletic(\"r3\", \"r2\", \"r1\", \"r0\") Out[18]: <pre>(False, True)</pre> In\u00a0[19]: Copied! <pre># return a copy of the tree\ntree.copy()\n</pre> # return a copy of the tree tree.copy() Out[19]: <pre>&lt;toytree.ToyTree at 0x7ff02f48f520&gt;</pre> In\u00a0[20]: Copied! <pre># return a tree drawing as a (Canvas, Cartesian, Mark)\ntree.draw(ts='c')\n</pre> # return a tree drawing as a (Canvas, Cartesian, Mark) tree.draw(ts='c') Out[20]: <pre>(&lt;toyplot.canvas.Canvas at 0x7ff02f4cb550&gt;,\n &lt;toyplot.coordinates.Cartesian at 0x7ff02f37feb0&gt;,\n &lt;toytree.drawing.src.mark_toytree.ToyTreeMark at 0x7ff02f37df30&gt;)</pre> r0r1r2r3r4r5r6r700.51 In\u00a0[21]: Copied! <pre># return all ancestors of query nodes\ntree.get_ancestors(\"r4\", \"r5\")\n</pre> # return all ancestors of query nodes tree.get_ancestors(\"r4\", \"r5\") Out[21]: <pre>{&lt;Node(idx=4, name='r4')&gt;,\n &lt;Node(idx=5, name='r5')&gt;,\n &lt;Node(idx=11)&gt;,\n &lt;Node(idx=12)&gt;,\n &lt;Node(idx=14)&gt;}</pre> In\u00a0[22]: Copied! <pre># get dict mapping one feature to another\ntree.get_feature_dict('idx', 'name')\n</pre> # get dict mapping one feature to another tree.get_feature_dict('idx', 'name') Out[22]: <pre>{0: 'r0',\n 1: 'r1',\n 2: 'r2',\n 3: 'r3',\n 4: 'r4',\n 5: 'r5',\n 6: 'r6',\n 7: 'r7',\n 8: '',\n 9: '',\n 10: '',\n 11: '',\n 12: '',\n 13: '',\n 14: ''}</pre> In\u00a0[23]: Copied! <pre># get edges as a table\ntree.get_edges(feature=\"idx\", df=True)\n</pre> # get edges as a table tree.get_edges(feature=\"idx\", df=True) Out[23]: child parent 0 0 8 1 1 8 2 2 9 3 3 9 4 4 11 5 5 11 6 6 13 7 7 13 8 8 10 9 9 10 10 10 12 11 11 12 12 12 14 13 13 14 In\u00a0[24]: Copied! <pre># get mrca of a queried set of nodes\ntree.get_mrca_node(\"r4\", \"r5\")\n</pre> # get mrca of a queried set of nodes tree.get_mrca_node(\"r4\", \"r5\") Out[24]: <pre>&lt;Node(idx=11)&gt;</pre> In\u00a0[25]: Copied! <pre># get a DataFrame or Series of data from all nodes w/ formatting options\ntree.get_node_data()\n</pre> # get a DataFrame or Series of data from all nodes w/ formatting options tree.get_node_data() Out[25]: idx name height dist support 0 0 r0 0.00 0.25 NaN 1 1 r1 0.00 0.25 NaN 2 2 r2 0.00 0.25 NaN 3 3 r3 0.00 0.25 NaN 4 4 r4 0.00 0.50 NaN 5 5 r5 0.00 0.50 NaN 6 6 r6 0.00 0.75 NaN 7 7 r7 0.00 0.75 NaN 8 8 0.25 0.25 NaN 9 9 0.25 0.25 NaN 10 10 0.50 0.25 NaN 11 11 0.50 0.25 NaN 12 12 0.75 0.25 NaN 13 13 0.75 0.25 NaN 14 14 1.00 0.00 NaN In\u00a0[26]: Copied! <pre># get mask that is True for selected nodes and False for others\ntree.get_node_mask(0, 1, 2)\n</pre> # get mask that is True for selected nodes and False for others tree.get_node_mask(0, 1, 2) Out[26]: <pre>array([ True,  True,  True, False, False, False, False, False, False,\n       False, False, False, False, False, False])</pre> In\u00a0[27]: Copied! <pre># get nodes matching a query\ntree.get_nodes(\"~r[0-3]$\")\n</pre> # get nodes matching a query tree.get_nodes(\"~r[0-3]$\") Out[27]: <pre>[&lt;Node(idx=2, name='r2')&gt;,\n &lt;Node(idx=3, name='r3')&gt;,\n &lt;Node(idx=0, name='r0')&gt;,\n &lt;Node(idx=1, name='r1')&gt;]</pre> In\u00a0[28]: Copied! <pre># like get_node_data but only for tip (leaf) nodes\ntree.get_tip_data()\n</pre> # like get_node_data but only for tip (leaf) nodes tree.get_tip_data() Out[28]: idx name height dist support 0 0 r0 0.0 0.25 NaN 1 1 r1 0.0 0.25 NaN 2 2 r2 0.0 0.25 NaN 3 3 r3 0.0 0.25 NaN 4 4 r4 0.0 0.50 NaN 5 5 r5 0.0 0.50 NaN 6 6 r6 0.0 0.75 NaN 7 7 r7 0.0 0.75 NaN In\u00a0[29]: Copied! <pre># return the names for nodes idx 0-ntips in order\ntree.get_tip_labels()\n</pre> # return the names for nodes idx 0-ntips in order tree.get_tip_labels() Out[29]: <pre>['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7']</pre> In\u00a0[30]: Copied! <pre># return a hash str unique to this topology\ntree.get_topology_id()\n</pre> # return a hash str unique to this topology tree.get_topology_id() Out[30]: <pre>'535ff2bd575ed1f753d5b5f6340e8389'</pre> In\u00a0[31]: Copied! <pre># extract a subtree connecting tips r0, r1, r2, r3 and draw it\ntoytree.mod.extract_subtree(tree, \"~r[0-3]\").draw();\n</pre> # extract a subtree connecting tips r0, r1, r2, r3 and draw it toytree.mod.extract_subtree(tree, \"~r[0-3]\").draw(); r0r1r2r3 In\u00a0[32]: Copied! <pre># example of complex chained function calls\ncanvas, axes, mark = (tree\n    .root(\"r6\")\n    .mod.edges_scale_to_root_height(10)\n    .ladderize(True)\n    .set_node_data(\"name\", {-1: 'root'})\n    .draw(\n        node_labels=\"name\", node_mask=(0, 0, 1), node_sizes=18,\n        node_markers=\"r2x1\", node_colors=\"lightgrey\",\n        scale_bar=True, tip_labels_align=True,\n    )\n);\n</pre> # example of complex chained function calls canvas, axes, mark = (tree     .root(\"r6\")     .mod.edges_scale_to_root_height(10)     .ladderize(True)     .set_node_data(\"name\", {-1: 'root'})     .draw(         node_labels=\"name\", node_mask=(0, 0, 1), node_sizes=18,         node_markers=\"r2x1\", node_colors=\"lightgrey\",         scale_bar=True, tip_labels_align=True,     ) ); rootr0r1r2r3r4r5r7r61050 In\u00a0[33]: Copied! <pre># call drop_tips from the module-level\ntoytree.mod.drop_tips(tree, \"~r[4-6]\").draw();\n</pre> # call drop_tips from the module-level toytree.mod.drop_tips(tree, \"~r[4-6]\").draw(); r0r1r2r3r7 In\u00a0[34]: Copied! <pre># call drop_tips from the object-level\ntree.mod.drop_tips(\"~r[4-6]\").draw();\n</pre> # call drop_tips from the object-level tree.mod.drop_tips(\"~r[4-6]\").draw(); r0r1r2r3r7 In\u00a0[35]: Copied! <pre>tree.write()\n</pre> tree.write() Out[35]: <pre>'((((r0:0.25,r1:0.25):0.25,(r2:0.25,r3:0.25):0.25):0.25,(r4:0.5,r5:0.5):0.25):0.25,(r6:0.75,r7:0.75):0.25);'</pre> In\u00a0[36]: Copied! <pre># create a copy that we will modify the .style of\ntre = tree.copy()\n\n# set several style options on the tree\ntre.style.node_style.fill = \"black\"\ntre.style.node_style.stroke = \"white\"\ntre.style.node_style.stroke_width = 3\ntre.style.node_sizes = 12\ntre.style.node_mask = False\ntre.style.node_markers = \"v\"\ntre.style.edge_style.stroke = \"darkcyan\"\ntre.style.edge_style.stroke_width = 3\ntre.style.layout = 'd'\n\n# call draw and the .style will form the default tree style\ntre.draw(tree_style=None);\n</pre> # create a copy that we will modify the .style of tre = tree.copy()  # set several style options on the tree tre.style.node_style.fill = \"black\" tre.style.node_style.stroke = \"white\" tre.style.node_style.stroke_width = 3 tre.style.node_sizes = 12 tre.style.node_mask = False tre.style.node_markers = \"v\" tre.style.edge_style.stroke = \"darkcyan\" tre.style.edge_style.stroke_width = 3 tre.style.layout = 'd'  # call draw and the .style will form the default tree style tre.draw(tree_style=None); r0r1r2r3r4r5r6r7"},{"location":"toytree/#toytree","title":"ToyTree\u00b6","text":"<p>The <code>toytree.ToyTree</code> object is the main class in the <code>toytree</code> package. It contains a number of useful functions for interacting with the underlying <code>Node</code> structure (e.g., rooting, dropping tips), for storing and retrieving data (e.g., trait or support values), performing comparative or statistical analyses (e.g., tree distance metrics), and creating visualizations.</p> <p>Note: this section of the documentation is relatively short since many of the other sections of the documentation are about properties or methods of <code>ToyTree</code> objects.</p>"},{"location":"toytree/#generating-toytrees","title":"Generating ToyTrees\u00b6","text":"<p>A <code>ToyTree</code> is loaded in one of three ways: (1) by parsing tree data using <code>toytree.tree()</code> (see tree/io); (2) by generating a fixed or random tree with <code>toytree.rtree</code> (see rtree); or (3) by wrapping one or more <code>toytree.Node</code> objects in a <code>ToyTree</code> (see Building-trees-from-nodes). Follow the links for more details on each. We will use the random birth 8-tip unit tree generated below for this tutorial.</p>"},{"location":"toytree/#trees-are-indexable-and-iterable","title":"Trees are indexable and iterable\u00b6","text":"<p><code>Node</code> objects can be selected from <code>ToyTrees</code> in a variety of ways. See Node Query/selection for details.</p>"},{"location":"toytree/#cached-traversal","title":"Cached Traversal\u00b6","text":"<p>A <code>ToyTree</code> stores a cached traversal of all Nodes in the tree in idxorder (see Traversal order/methods). Briefly, a traversal involves visiting each node in a tree exactly once. This is used to assign a unique integer label to every node. The idx labels <code>0-ntips</code> are the tips, and from <code>ntips-nnodes-1</code> are the internal nodes. The <code>nnodes-1</code> idx label corresponds to the root.</p>"},{"location":"toytree/#the-tree-root-treenode","title":"The tree root (treenode)\u00b6","text":"<p>A <code>ToyTree</code> acts as a wrapper around a collection of connected <code>Node</code> objects. Of these nodes, one has a special designation as the root of the tree, whether or not the tree structure is rooted or unrooted. This node merely represents the top of the hierarchical structure of stored nodes. This node can be accessed like any other node by indexing or by name, and can also be accessed as the <code>.treenode</code> attribute of a <code>ToyTree</code>.</p>"},{"location":"toytree/#attributes","title":"Attributes\u00b6","text":"<p><code>ToyTree</code> attributes store information about the size of the tree, and are automatically updated by the <code>mod</code> functions when a tree structure is modified. The <code>features</code> and <code>edge_features</code> describe data stored to nodes of a tree and are further described in Data/Features.</p>"},{"location":"toytree/#methods","title":"Methods\u00b6","text":"<p>The <code>ToyTree</code> object has a number of methods available directly from object, as well as many additional methods organized into subpackages that are also accessible from a tree.</p>"},{"location":"toytree/#modifying-trees","title":"Modifying trees\u00b6","text":"<p>See the <code>mod</code> documentation section for details on tree modification methods. Many methods are available for modifying the topology, branch lengths, or other data on trees. These include common options like <code>.ladderize</code>, <code>.prune</code>, <code>.root</code>, <code>.collapse_nodes</code>, <code>edges_set_node_heights</code>, and many more. These functions are written to be very efficient, requiring the minimum number of tree traversals or modifications, and ensure the returned tree has proper node idx, height, and other node features updated.</p>"},{"location":"toytree/#chaining-methods","title":"Chaining methods\u00b6","text":"<p>Many methods of a <code>ToyTree</code> return a copy of the tree which are intended to make it easy to chain together multiple function calls to accomplish complex operations. For example, below the tree is re-rooted, scaled to a new crown height, ladderized, adds an internal node name, and then calls draw with many styling options including showing the new node name.</p>"},{"location":"toytree/#subpackage-api","title":"Subpackage API\u00b6","text":"<p>Many functions for working with trees are organized in subpackages. See their documentation sections for more details. Any of these methods which accept a toytree as their first argument are also accessible from a <code>ToyTree</code> object as a convenience. For example, <code>toytree.mod.func(tree)</code> is equivalent to <code>tree.mod.func()</code>. We refer to this as using the module-level API versus the object-level API.</p>"},{"location":"toytree/#writing-trees","title":"Writing trees\u00b6","text":"<p>See the Writing tree data documentation section. The function <code>write()</code> is used to write a tree to a newick or other format of serialized tree data, and to return it as a string or write to a file from a <code>ToyTree</code>, with options to also include metadata.</p>"},{"location":"toytree/#drawing-toytrees","title":"Drawing ToyTrees\u00b6","text":"<p>See the Tree Drawing documentation section for a detailed description of drawing options using the <code>.draw()</code> function.</p>"},{"location":"toytree/#style-dict","title":"Style dict\u00b6","text":"<p><code>ToyTree</code> objects have a <code>.style</code> dict-like object that can be used to view all options for styling tree drawings, and to modify their default drawing style. This is an optional convenience, it is often simpler to provide arguments directly to the <code>.draw()</code> function.</p>"},{"location":"traversal/","title":"traversal order/methods","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># an example tree\ntree = toytree.rtree.unittree(8, seed=123)\n</pre> # an example tree tree = toytree.rtree.unittree(8, seed=123) In\u00a0[3]: Copied! <pre># traverse() is a generator function\ntree.traverse(strategy=\"levelorder\")\n</pre> # traverse() is a generator function tree.traverse(strategy=\"levelorder\") Out[3]: <pre>&lt;generator object ToyTree.traverse at 0x7f13e4c1e1f0&gt;</pre> In\u00a0[4]: Copied! <pre># unpacking the generator returns every Node visited once\nlist(tree.traverse(\"levelorder\"))\n</pre> # unpacking the generator returns every Node visited once list(tree.traverse(\"levelorder\")) Out[4]: <pre>[&lt;Node(idx=14)&gt;,\n &lt;Node(idx=12)&gt;,\n &lt;Node(idx=13)&gt;,\n &lt;Node(idx=10)&gt;,\n &lt;Node(idx=11)&gt;,\n &lt;Node(idx=6, name='r6')&gt;,\n &lt;Node(idx=7, name='r7')&gt;,\n &lt;Node(idx=8)&gt;,\n &lt;Node(idx=9)&gt;,\n &lt;Node(idx=4, name='r4')&gt;,\n &lt;Node(idx=5, name='r5')&gt;,\n &lt;Node(idx=0, name='r0')&gt;,\n &lt;Node(idx=1, name='r1')&gt;,\n &lt;Node(idx=2, name='r2')&gt;,\n &lt;Node(idx=3, name='r3')&gt;]</pre> In\u00a0[5]: Copied! <pre>def get_traversal_drawing(tree: toytree.ToyTree, strategy: str) -&gt; toytree.core.Canvas:\n    \"\"\"Return a tree drawing canvas showing a traversal strategy\"\"\"\n    \n    # create map of {node: int} in levelorder traversal\n    order = {j: i for (i, j) in enumerate(tree.traverse(strategy))}\n    \n    # set as data to the tree\n    tree.set_node_data(feature=strategy, data=order, inplace=True)\n    \n    # draw the tree showing the 'levelorder' feature on nodes\n    c, a, m = tree.draw(layout='d', node_sizes=18, node_labels=strategy, node_mask=False);\n    \n    # add label\n    a.label.text = f'\"{strategy}\" traversal'\n    return c\n</pre> def get_traversal_drawing(tree: toytree.ToyTree, strategy: str) -&gt; toytree.core.Canvas:     \"\"\"Return a tree drawing canvas showing a traversal strategy\"\"\"          # create map of {node: int} in levelorder traversal     order = {j: i for (i, j) in enumerate(tree.traverse(strategy))}          # set as data to the tree     tree.set_node_data(feature=strategy, data=order, inplace=True)          # draw the tree showing the 'levelorder' feature on nodes     c, a, m = tree.draw(layout='d', node_sizes=18, node_labels=strategy, node_mask=False);          # add label     a.label.text = f'\"{strategy}\" traversal'     return c In\u00a0[6]: Copied! <pre>get_traversal_drawing(tree, \"levelorder\")\n</pre> get_traversal_drawing(tree, \"levelorder\") Out[6]: 11121314910567834120r0r1r2r3r4r5r6r7\"levelorder\" traversal In\u00a0[7]: Copied! <pre>get_traversal_drawing(tree, \"preorder\")\n</pre> get_traversal_drawing(tree, \"preorder\") Out[7]: 45781011131436291120r0r1r2r3r4r5r6r7\"preorder\" traversal In\u00a0[8]: Copied! <pre>get_traversal_drawing(tree, \"postorder\")\n</pre> get_traversal_drawing(tree, \"postorder\") Out[8]: 01347811122569101314r0r1r2r3r4r5r6r7\"postorder\" traversal In\u00a0[9]: Copied! <pre>get_traversal_drawing(tree, \"idxorder\")\n</pre> get_traversal_drawing(tree, \"idxorder\") Out[9]: 01234567891011121314r0r1r2r3r4r5r6r7\"idxorder\" traversal In\u00a0[10]: Copied! <pre># node idx 0 represents the first node in an idxorder traversal\ntree[3]\n</pre> # node idx 0 represents the first node in an idxorder traversal tree[3] Out[10]: <pre>&lt;Node(idx=3, name='r3')&gt;</pre> In\u00a0[11]: Copied! <pre># node idx 10 represents the 11th node in an idxorder traversal\ntree[10]\n</pre> # node idx 10 represents the 11th node in an idxorder traversal tree[10] Out[11]: <pre>&lt;Node(idx=10)&gt;</pre> In\u00a0[12]: Copied! <pre>bigtree = toytree.rtree.rtree(ntips=300)\n</pre> bigtree = toytree.rtree.rtree(ntips=300) In\u00a0[13]: Copied! <pre>%%timeit\n# select tip nodes from the idxorder cache\n[i.name for i in bigtree[:bigtree.ntips]]\n</pre> %%timeit # select tip nodes from the idxorder cache [i.name for i in bigtree[:bigtree.ntips]] <pre>40.5 \u00b5s \u00b1 465 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> In\u00a0[14]: Copied! <pre>%%timeit\n# perform a new traversal to visit each node\nnames = []\nfor node in bigtree.traverse(strategy=\"idxorder\"):\n    if node.is_leaf():\n        names.append(node.name)\n</pre> %%timeit # perform a new traversal to visit each node names = [] for node in bigtree.traverse(strategy=\"idxorder\"):     if node.is_leaf():         names.append(node.name) <pre>352 \u00b5s \u00b1 5.18 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n</pre> In\u00a0[15]: Copied! <pre># trees are iterable and return nodes in idxorder\nfor node in tree:\n    pass\n\n# same as above\nfor node in tree[:]:\n    pass\n\n# nodes can be indexed using their idxorder idx labels\nfor idx in range(tree.nnodes):\n    node = tree[idx]\n\n# to iterate idxorder in reverse (root to tips)\nfor node in tree[::-1]:\n    pass\n</pre> # trees are iterable and return nodes in idxorder for node in tree:     pass  # same as above for node in tree[:]:     pass  # nodes can be indexed using their idxorder idx labels for idx in range(tree.nnodes):     node = tree[idx]  # to iterate idxorder in reverse (root to tips) for node in tree[::-1]:     pass In\u00a0[16]: Copied! <pre># for tip nodes\nfor idx in range(tree.ntips):\n    pass\n\n# for tip nodes\nfor node in tree[:tree.ntips]:\n    pass\n\n# for tip nodes\nfor node in tree:\n    if not node.is_leaf():\n        pass\n\n# tips in reverse order of how they will be plotted\nfor node in tree[:tree.ntips][::-1]:\n    pass\n\n# tips in reverse order of how they will be plotted\nfor node in tree[:tree.ntips:-1]:\n    pass\n</pre> # for tip nodes for idx in range(tree.ntips):     pass  # for tip nodes for node in tree[:tree.ntips]:     pass  # for tip nodes for node in tree:     if not node.is_leaf():         pass  # tips in reverse order of how they will be plotted for node in tree[:tree.ntips][::-1]:     pass  # tips in reverse order of how they will be plotted for node in tree[:tree.ntips:-1]:     pass In\u00a0[17]: Copied! <pre># for internal nodes\nfor idx in range(tree.ntips, tree.nnodes):\n    pass\n\n# for internal nodes\nfor node in tree[tree.ntips: tree.nnodes]:\n    pass\n\n# for internal nodes\nfor node in tree[:]:\n    if not node.is_leaf():\n        pass\n\n# for reverse order: root to last internal\nfor idx in range(tree.nnodes - 1, tree.ntips - 1, -1):\n    node = tree[idx]\n\n# for reverse order: root to last internal\nfor node in tree[tree.nnodes: tree.ntips:-1]:\n    pass\n</pre> # for internal nodes for idx in range(tree.ntips, tree.nnodes):     pass  # for internal nodes for node in tree[tree.ntips: tree.nnodes]:     pass  # for internal nodes for node in tree[:]:     if not node.is_leaf():         pass  # for reverse order: root to last internal for idx in range(tree.nnodes - 1, tree.ntips - 1, -1):     node = tree[idx]  # for reverse order: root to last internal for node in tree[tree.nnodes: tree.ntips:-1]:     pass"},{"location":"traversal/#traversal-ordermethods","title":"Traversal order/methods\u00b6","text":"<p>A key property of a tree data structure is the process of traversal, by which each Node is visited exactly once in a determined order. Traversal algorithms make it possible to calculate information on trees fast and efficiently, typically by performing calculations on parts of the tree which can be re-used in later calculations. Examples of this include summing branch lengths during traversal to measure distances between nodes, or the way in which Felsenstein's pruning algorithm calculates parsimony or likelihood scores while moving up a tree from tips towards the root.</p> <p>This section introduces different traversal algorithms, shows how they are implemented in <code>toytree</code>, and provides some demonstrations of how traversal can be used to write efficient functions. We also discuss the cached 'idxorder' traversal of <code>ToyTree</code> objects and show how this allows for fast and intuitive access to nodes in most situtations, as further demonstrated in the Node Query/Selection section.</p>"},{"location":"traversal/#why-traverse","title":"Why traverse?\u00b6","text":"<p>A <code>ToyTree</code> represents a container around a collection of connected <code>Node</code> objects. You can imagine that this collection of nodes could be stored in a variety of ways, such as a list or dictionary mapping names to nodes. But, either of these approaches would involve linearizing the node collection, rather than treating it hierarchically. And in each case, it would be necessary to choose the order in which to store the nodes, which raises the question of which order is the most useful, intuitive, or memorable.</p> <p>A traversal algorithm represents a set of rules for consistently iterating over Nodes in a tree to visit each Node exactly once. There are several common traversal algorithms designed to traverse trees, which we will cover shortly.</p> <p>Different strategies have advantages in different scenarios, such as when calculating data for a child that depends on the state of its parent, or vice versa. Similarly, when performing a search process over a tree that can be terminated when a particular target is found, it is more efficient to use a traversal strategy that is more likely to encounter the target earlier. Most algorithms for computing statistics on trees, fitting evolutionary models to trees, or searching trees involves a traversal. Learning the most common traversal strategies is thus valuable towards understanding how these methods work, and for developing new tree-based methods.</p> <p>The <code>traverse()</code> function of a <code>ToyTree</code> can be used to implement a tree traversal. This is a generator function, meaning it returns a generator that can be unpacked by iteration, and only generates each subsequent node in the traversal when requested.</p>"},{"location":"traversal/#traversal-strategies","title":"Traversal strategies\u00b6","text":"<p>Below I show the main traversal strategies in <code>toytree</code>: \"levelorder\", \"preorder\", \"postorder\", and \"idxorder\". Below is a custom function written to return a plot to visualize each traversal order shown as node labels on a tree.</p>"},{"location":"traversal/#levelorder-root-to-tips","title":"levelorder (root to tips)\u00b6","text":"<p>A levelorder traversal (also called a breadth-first search; BFS) is an algorithm that starts at the root and visits all Nodes at a given depth descended from the root before moving to the next level. (Note: depth here refers to distance in number of nodes, not branch lengths). The Nodes in each level are visited in left to right order in toytree, but the opposite could just as easily be implemented. The primary utility of this traversal strategy is that it is topologically sorted, such that a parent is always visited before any of its children.</p>"},{"location":"traversal/#preorder-root-to-tips","title":"preorder (root to tips)\u00b6","text":"<p>A preorder traversal is an example of a Depth-first search algorithm. It starts at the root Node and explores as far as possible along each descendant subtree before backtracking. The default in toytree is to visit the left subtree before the right subtree, such that the algorithm could be summarized as NLR (Node, left subtree, right subtree). The primary utility of this traversal strategy is that it is topologically sorted, such that a parent is always visited before any of its children. This property is also shared with levelorder traversal. The primary concern in distinguishing between these two strategies is if you plan to stop the traversal when a certain Node is found (e.g., to prevent having to traverse a very large set of Nodes), in which case the two will differ in the order in which they may find the stopping Node.</p>"},{"location":"traversal/#postorder-tips-to-root","title":"postorder (tips to root)\u00b6","text":"<p>A postorder traversal is also a Depth-first search algorithm, similar to preorder traversal, however it yields nodes from this traversal very differently. It starts by traversing down the left subtree from the root until it reaches a tip Node (i.e., no more left subtrees descend from the current Node), it then checks for a right subtree (sister), and then visits the current Node. As with other algorithms, it could similarly be designed to visit right before left. Given the implementation in toytree, this algorithm could be summarized as LRN (left subtree, right subtree, Node). The primary utility of this traversal strategy is that it is topologically sorted, such that all children are always visited before their parent. This is especially useful for algorithms where parent values are calculated dependent on their child values. In a phylogenetic context, this involves algorithms for calculating likelihoods of data observed at the tips, for inferring ancestral state reconstructions, node depth/height calculations, and many more.</p>"},{"location":"traversal/#idxorder-tips-to-root","title":"idxorder (tips to root)\u00b6","text":"<p>This is a custom traversal order used by toytree. It could similarly be called \"tips-first-then-postorder\" traversal, because it works by first visiting the tip Nodes from left to right, and then proceeds by visiting internal nodes in a postorder manner (left then right subtrees, then their parent). This traversal strategy turns out be particularly convenient for working with phylogenetic trees, since the tip Nodes represent the actual extant samples in our dataset, and are therefore usually of greatest interest. This strategy is also topologically sorted, such that children are always visited before their parents.</p> <p>This traversal thus makes it easier to select and find the tip Nodes by knowing that the first ntips Nodes in a tree will be the tips. This is not the case in any of the other tree traversal algorithms above.</p>"},{"location":"traversal/#using-a-cached-traversal","title":"Using a cached traversal\u00b6","text":"<p>Although we just learned that tree traversal algorithms are widely useful for working with tree data structures, I am now going to going to argue a slightly contrary point, which is that, for the purpose of writing super-efficient code, you should try to limit the number of tree traversals that must be performed.</p> <p>This is to say, if a tree isn't changed in some way (e.g., by modifying the topology or edge lengths), then a single tree traversal can be performed to cache the information about the tree structure (e.g., a specific traversal order), and any subsequent operations can make use of this cached information rather than traversing the entire tree again. This can make code run much faster since fetching information from a cache (e.g., a dictionary) is pretty much the fastest thing you can do in Python; much faster than traversing an entire tree. Of course, if the tree does change in some way (e.g., it is re-rooted) then a tree traversal will need to be performed to store the new structure and update the cached information again.</p> <p>This is one of the key properties of the <code>ToyTree</code> class. It stores a cached representation of the 'idxorder' traversal of the nodes, and this cache is automatically updated when the tree structure is modified. This makes it easy to write functions that can access all or a subset of nodes, such as just the tips, or just the internal nodes, for quickly traverse all nodes in a postorder-type traversal. This cache is the source of node \"idx\" labels.</p>"},{"location":"traversal/#speed-comparison","title":"Speed Comparison\u00b6","text":"<p>To make this point more clearly, let's walk through an example. Let's say that we want to access the names of every leaf Node in a tree. The two examples below compare selecting tip nodes from the cached idxorder versus performing a traversal of the entire tree. Both approaches are very fast, even on a large tree, but the cached traversal method is about 6X faster. This difference is not a big deal in this example, but it is good to be aware of, since some methods may require thousands of traversals over a tree.</p>"},{"location":"traversal/#common-traversals","title":"Common traversals\u00b6","text":"<p>Below are some common code snippets used to traverse all or parts of a tree:</p>"},{"location":"traversal/#iterate-over-all-nodes","title":"iterate over all nodes\u00b6","text":""},{"location":"traversal/#iterate-over-leaf-nodes","title":"iterate over leaf nodes\u00b6","text":"<p>The strategies below can be used to traverse over leaf nodes (not internal nodes) efficiently.</p>"},{"location":"traversal/#iterate-over-internal-nodes","title":"iterate over internal nodes\u00b6","text":"<p>The strategies below can be used to traverse over internal nodes in a tree (not leaf nodes) efficiently.</p>"},{"location":"tree-annotations/","title":"Tree annotations","text":"<p>The <code>.annotate</code> subpackage offers a clean, readable way to edit an existing tree as an alternative to modifying each argument in the <code>.draw()</code> method. The funcitons provided in this subpackage work by adding marks on top of the most recent <code>canvas</code> created by Toytree. It can be accessed direclty from a tree object (e.g., tree.annotate.{function}()), but some functions require additional arguments to specify axes, styles, etc.</p> <p>Since this subpackage contains very simple modifications that can be quickly added on top of existing trees, we encourage you to share with us any functions you make that may fit in this subpackage! These can be shared via Github at https://github.com/eaton-lab/toytree/discussions</p> In\u00a0[1]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np In\u00a0[2]: Copied! <pre>#add_axes_box_outline\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n\n\ntree.annotate.add_axes_box_outline(axes=axes)\n</pre> #add_axes_box_outline  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw()   tree.annotate.add_axes_box_outline(axes=axes)  Out[2]: <pre>&lt;toyplot.coordinates.Cartesian at 0x210a26ad6d0&gt;</pre> r0r1r2r3r4r5-1.0-0.50.00.50246 In\u00a0[3]: Copied! <pre>#add_edge_labels\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\nm1 = tree.annotate.add_edge_labels(\n    axes,\n    labels=tree.get_node_data(\"idx\"),\n    color='blue',\n    style={'font-size': 16, 'baseline-shift': 8}\n)\n</pre> #add_edge_labels  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() m1 = tree.annotate.add_edge_labels(     axes,     labels=tree.get_node_data(\"idx\"),     color='blue',     style={'font-size': 16, 'baseline-shift': 8} ) r0r1r2r3r4r5678 In\u00a0[4]: Copied! <pre>#add_edge_markers\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\nm1 = tree.annotate.add_edge_markers(\n     axes,\n     marker='s',\n     size=9,\n     color='red',\n     style={'stroke': 'white', 'stroke-width': 2.5}\n )\n</pre> #add_edge_markers  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() m1 = tree.annotate.add_edge_markers(      axes,      marker='s',      size=9,      color='red',      style={'stroke': 'white', 'stroke-width': 2.5}  ) r0r1r2r3r4r5 In\u00a0[5]: Copied! <pre>#add_node_markers\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n# add markers to all Nodes\nm1 = tree.annotate.add_node_markers(\n    axes,\n    marker='s',\n    size=9,\n    color='red',\n    style={'stroke': 'white', 'stroke-width': 2.5}\n)\n# add markers to only a few Nodes\nm2 = tree.annotate.add_node_markers(\n    axes, marker=\"&gt;\", size=20, mask=tree.get_node_mask(9, 10)\n)\n</pre> #add_node_markers  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() # add markers to all Nodes m1 = tree.annotate.add_node_markers(     axes,     marker='s',     size=9,     color='red',     style={'stroke': 'white', 'stroke-width': 2.5} ) # add markers to only a few Nodes m2 = tree.annotate.add_node_markers(     axes, marker=\"&gt;\", size=20, mask=tree.get_node_mask(9, 10) ) r0r1r2r3r4r5 In\u00a0[6]: Copied! <pre>#add_node_labels\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\nm1 = tree.annotate.add_node_labels(\n    axes,\n    labels=tree.get_node_data(\"idx\"),\n    color='blue',\n    style={'font-size': 16, 'baseline-shift': 8}\n)\n</pre> #add_node_labels  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() m1 = tree.annotate.add_node_labels(     axes,     labels=tree.get_node_data(\"idx\"),     color='blue',     style={'font-size': 16, 'baseline-shift': 8} )  r0r1r2r3r4r5678910 In\u00a0[7]: Copied! <pre>#add_node_bars\n\ntree = toytree.rtree.unittree(10, treeheight=1e5)\nc, a, m = tree.draw()\nnode_height = tree.get_node_data(\"height\").values\ntree.annotate.add_node_bars(\n    axes=a,\n    bar_min=node_height * 0.5,\n    bar_max=node_height * 1.5,\n    size=0.33, z_index=-1, color='purple', opacity=0.4,\n)\n</pre> #add_node_bars  tree = toytree.rtree.unittree(10, treeheight=1e5) c, a, m = tree.draw() node_height = tree.get_node_data(\"height\").values tree.annotate.add_node_bars(     axes=a,     bar_min=node_height * 0.5,     bar_max=node_height * 1.5,     size=0.33, z_index=-1, color='purple', opacity=0.4, ) Out[7]: <pre>&lt;toytree.drawing.src.mark_annotation.AnnotationRect at 0x210a540f2f0&gt;</pre> r0r1r2r3r4r5r6r7r8r9 In\u00a0[8]: Copied! <pre>#add_tip_markers\n\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n# add markers to all Nodes\nm1 = tree.annotate.add_tip_markers(\n    axes,\n    marker='s',\n    size=9,\n    color='red',\n    style={'stroke': 'white', 'stroke-width': 2.5}\n)\n# add markers to only a few Nodes\nm2 = tree.annotate.add_tip_markers(\n    axes, marker=\"&gt;\", size=20, mask=tree.get_node_mask(9)\n)\n</pre> #add_tip_markers  tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw() # add markers to all Nodes m1 = tree.annotate.add_tip_markers(     axes,     marker='s',     size=9,     color='red',     style={'stroke': 'white', 'stroke-width': 2.5} ) # add markers to only a few Nodes m2 = tree.annotate.add_tip_markers(     axes, marker=\"&gt;\", size=20, mask=tree.get_node_mask(9) ) r0r1r2r3r4r5 In\u00a0[12]: Copied! <pre>#add_axes_scale_bar\n\nimport toytree\n\ntree = toytree.rtree.unittree(ntips = 10)\ncanvas, axes, mark = tree.draw()\ntree.annotate.add_axes_scale_bar(axes)\n</pre> #add_axes_scale_bar  import toytree  tree = toytree.rtree.unittree(ntips = 10) canvas, axes, mark = tree.draw() tree.annotate.add_axes_scale_bar(axes) Out[12]: <pre>&lt;toyplot.coordinates.Cartesian at 0x210a3067d10&gt;</pre> r0r1r2r3r4r5r6r7r8r910.50 In\u00a0[10]: Copied! <pre>#add_node_pie_charts\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n\n# generate random pie-like (proportion) data array\nncategories = 3\narr = np.random.random(size=(tree.nnodes, ncategories))\narr = (arr.T / arr.sum(axis=1)).T\n\n# add pie charts to all internal Nodes\ntree.annotate.add_node_pie_charts(\n    axes=axes, data=arr, size=20, mask=(0, 1, 1),\n    istroke_width=0.75, istroke=\"black\", rotate=-45,\n)\n</pre> #add_node_pie_charts tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw()  # generate random pie-like (proportion) data array ncategories = 3 arr = np.random.random(size=(tree.nnodes, ncategories)) arr = (arr.T / arr.sum(axis=1)).T  # add pie charts to all internal Nodes tree.annotate.add_node_pie_charts(     axes=axes, data=arr, size=20, mask=(0, 1, 1),     istroke_width=0.75, istroke=\"black\", rotate=-45, ) Out[10]: <pre>&lt;toytree.drawing.src.mark_pie.PieChartMark at 0x210a542ad20&gt;</pre> r0r1r2r3r4r5 In\u00a0[11]: Copied! <pre>#add_edge_pie_charts\ntree = toytree.rtree.unittree(6, seed=123)\ncanvas, axes, m0 = tree.draw()\n\n# generate random pie-like (proportion) data array\nncategories = 3\narr = np.random.random(size=(tree.nnodes, ncategories))\narr = (arr.T / arr.sum(axis=1)).T\n\n# add pie charts to all internal Nodes\ntree.annotate.add_edge_pie_charts(\n    axes=axes, data=arr, size=20, mask=(0, 1, 1),\n    istroke_width=0.75, istroke=\"black\", rotate=-45,\n)\n</pre> #add_edge_pie_charts tree = toytree.rtree.unittree(6, seed=123) canvas, axes, m0 = tree.draw()  # generate random pie-like (proportion) data array ncategories = 3 arr = np.random.random(size=(tree.nnodes, ncategories)) arr = (arr.T / arr.sum(axis=1)).T  # add pie charts to all internal Nodes tree.annotate.add_edge_pie_charts(     axes=axes, data=arr, size=20, mask=(0, 1, 1),     istroke_width=0.75, istroke=\"black\", rotate=-45, ) Out[11]: <pre>&lt;toytree.drawing.src.mark_pie.PieChartMark at 0x210a4e736b0&gt;</pre> r0r1r2r3r4r5"},{"location":"tree-annotations/#tree-annotations","title":"Tree annotations\u00b6","text":""},{"location":"tree-annotations/#current-available-annotations","title":"Current available annotations:\u00b6","text":""},{"location":"tree-annotations/#node-and-edge-markslabels","title":"Node and edge marks/labels\u00b6","text":"<ul> <li>add_edge_labels</li> <li>add_edge_markers</li> <li>add_node_markers</li> <li>add_node_labels</li> <li>add_tip_markers</li> <li>add_node_bars</li> </ul>"},{"location":"tree-annotations/#axes-annotations","title":"Axes annotations\u00b6","text":"<ul> <li>add_axes_box_outline</li> <li>add_axes_scale_bar</li> </ul>"},{"location":"tree-annotations/#datagraph-annotations","title":"Data/graph annotations\u00b6","text":"<ul> <li>add_node_pie_charts</li> <li>add_edge_pie_charts</li> </ul>"},{"location":"tree-annotations/#quick-examples","title":"Quick examples\u00b6","text":""},{"location":"tree-distance/","title":"tree distances","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># example trees\ntree1 = toytree.rtree.unittree(ntips=8, seed=123)\ntree2 = toytree.rtree.unittree(ntips=8, seed=987)\ntoytree.mtree([tree1, tree2]).draw();\n</pre> # example trees tree1 = toytree.rtree.unittree(ntips=8, seed=123) tree2 = toytree.rtree.unittree(ntips=8, seed=987) toytree.mtree([tree1, tree2]).draw(); r0r1r2r3r4r5r6r7r0r1r2r3r4r5r6r7 In\u00a0[3]: Copied! <pre>toytree.distance.get_treedist_quartets(tree1, tree2)\n</pre> toytree.distance.get_treedist_quartets(tree1, tree2) Out[3]: <pre>Q                              70.000000\nS                              57.000000\nD                              13.000000\nU                               0.000000\nR1                              0.000000\nR2                              0.000000\nN                              70.000000\ndo_not_conflict                 0.185714\nexplicitly_agree                0.185714\nstrict_joint_assertions         0.185714\nsemistrict_joint_assertions     0.185714\nsteel_and_penny                 0.185714\nsymmetric_difference            0.185714\nsymmetric_divergence            0.628571\nsimilarity_to_reference         0.185714\nmarczewski_steinhaus            0.313253\ndtype: float64</pre> In\u00a0[23]: Copied! <pre>toytree.distance.get_treedist_rf(tree1, tree2, normalize=True)\n</pre> toytree.distance.get_treedist_rf(tree1, tree2, normalize=True) Out[23]: <pre>0.4</pre> In\u00a0[5]: Copied! <pre>toytree.distance.get_treedist_rfi(tree1, tree2, normalize=True)\n</pre> toytree.distance.get_treedist_rfi(tree1, tree2, normalize=True) Out[5]: <pre>0.3825066230466303</pre> In\u00a0[6]: Copied! <pre>toytree.distance.get_treedist_rfg_ms(tree1, tree2, normalize=False)\n</pre> toytree.distance.get_treedist_rfg_ms(tree1, tree2, normalize=False) Out[6]: <pre>3.0</pre> In\u00a0[7]: Copied! <pre>toytree.distance.get_treedist_rfg_msi(tree1, tree2, normalize=True)\n</pre> toytree.distance.get_treedist_rfg_msi(tree1, tree2, normalize=True) Out[7]: <pre>0.2672083416810132</pre> In\u00a0[8]: Copied! <pre>toytree.distance.get_treedist_rfg_mci(tree1, tree2, normalize=True)\n</pre> toytree.distance.get_treedist_rfg_mci(tree1, tree2, normalize=True) Out[8]: <pre>0.2672083416810132</pre> In\u00a0[22]: Copied! <pre># BUGFIX in progress.\n# toytree.distance.get_treedist_rfg_spi(tree1, tree2, normalize=True)\n</pre> # BUGFIX in progress. # toytree.distance.get_treedist_rfg_spi(tree1, tree2, normalize=True)"},{"location":"tree-distance/#tree-distance-metrics","title":"Tree distance metrics\u00b6","text":"<p>A number of tree distance metrics are implemented in toytree to calculate the difference between two trees based on a number of criteria.</p>"},{"location":"tree-distance/#quartet-tree-distance","title":"Quartet tree distance\u00b6","text":"<p>This returns a <code>pandas.Series</code> object with many tree distance metrics computed from the quartet set. You can select any individual stat from this Series by name. The arg <code>similarity=True</code> can be used to report similarity as opposed to dissimilarity scores. The quartet data in the result table includes the following metrics and statistics computed from them:</p> <p>Q = Total possible quartets S = Resolved in the same way between the two trees D = Resolved differently between the two trees R1 = Unresolved in tree 1, resolved in tree 2 R2 = Unresolved in tree 2, resolved in tree 1 U =  Unresolved in both trees N = S + D + R1 + R2 + U$</p> <p>Estabrook GF, McMorris FR, Meacham CA (1985). \u201cComparison of undirected phylogenetic trees based on subtrees of four evolutionary units.\u201d Systematic Zoology, 34(2), 193--200. doi:10.2307/2413326 .</p>"},{"location":"tree-distance/#robinson-foulds-distances","title":"Robinson-Foulds distances\u00b6","text":""},{"location":"tree-distance/#rf","title":"RF\u00b6","text":"<p>The Robinson-Foulds (RF) distance is a metric that measures the normalized* count of bipartitions induced by one tree, but not the other tree. In other words, it is the symmmetric difference between two bipart sets divided by the total number of bipartitions in both sets. Larger values indicate that the two trees are more different. *To show the normalized score, use <code>normalize=True</code>.</p>"},{"location":"tree-distance/#rfi-information-corrected","title":"RFi (information-corrected)\u00b6","text":"<p>The information-corrected Robinson-Foulds distance (RFI) measures the sum of the <code>phylogenetic information</code> of edges that are different between two trees. <code>Information</code> is calculated as the probability that a randomly sampled binary tree of the same size contains the split. Splits that contain less information (e.g. a cherry vs a deep split) are more likely to arise by chance, and thus contribute less to the metric. <code>normalize=True</code> normalizes the score relative to the sum of phylogenetic information present in both subtrees.</p>"},{"location":"tree-distance/#rfg_ms-matching-split","title":"RFg_ms (matching split)\u00b6","text":"<p>Return the Matching Split Distance.</p>"},{"location":"tree-distance/#rfg_msi-matching-split-info","title":"RFg_msi (matching split info)\u00b6","text":"<p>Return the Matching Split Information Distance.</p>"},{"location":"tree-distance/#rfg_mci-mutual-clustering-info","title":"RFg_mci (mutual clustering info)\u00b6","text":"<p>Generalized Robinson-Foulds Distance based on Mutual Clustering Information. This is the recommended tree distance metric according to Smith 2020.</p> <p>Smith, Martin R. (2020). \"Information theoretic Generalized Robinson-Foulds metrics for comparing phylogenetic trees\". Bioinformatics. 36 (20): 5007\u20135013. doi:10.1093/bioinformatics/btaa614.</p>"},{"location":"tree-distance/#rfg_spi-shared-phylo-info","title":"RFg_spi (shared phylo info)\u00b6","text":"<p>Generalized Robinson-Foulds Distance based on Shared Phylogenetic Infomration</p>"},{"location":"tree-styles/","title":"builtin tree styles","text":"In\u00a0[2]: Copied! <pre>import toytree\ntree = toytree.rtree.baltree(ntips=10)\n</pre> import toytree tree = toytree.rtree.baltree(ntips=10) In\u00a0[4]: Copied! <pre>tree.draw(tree_style='s');  # simple-style\n</pre> tree.draw(tree_style='s');  # simple-style 0123456789101112131415161718r0r1r2r3r4r5r6r7r8r9 In\u00a0[5]: Copied! <pre>tree.draw(tree_style='c');  # coalescent-style\n</pre> tree.draw(tree_style='c');  # coalescent-style r0r1r2r3r4r5r6r7r8r900.51 In\u00a0[6]: Copied! <pre>tree.draw(tree_style='r');  # R-style\n</pre> tree.draw(tree_style='r');  # R-style r0r1r2r3r4r5r6r7r8r9 In\u00a0[7]: Copied! <pre>tree.draw(tree_style='p');  # population-style\n</pre> tree.draw(tree_style='p');  # population-style 0123456789101112131415161718r0r1r2r3r4r5r6r7r8r900.51 In\u00a0[8]: Copied! <pre>tree.draw(tree_style='d');  # dark-style\n</pre> tree.draw(tree_style='d');  # dark-style r0r1r2r3r4r5r6r7r8r9 In\u00a0[9]: Copied! <pre>tree.draw(tree_style='o');  # umlaut-style\n</pre> tree.draw(tree_style='o');  # umlaut-style r0r1r2r3r4r5r6r7r8r9 <p>You can think of setting a <code>tree_style</code> as changing the baseline style on top of which additional drawing arguments can still be added. For example, here we select the \"dark\" tree style, which changes the default edge and tip colors, and on top of this we can still specify a change to the layout, node marker type, node size, and/or other drawing options.</p> In\u00a0[11]: Copied! <pre># tree_style is a baseline on top of which additional styles can be added\ntree.draw(tree_style='d', layout='d', node_markers=\"s\", node_sizes=8, height=250);\n</pre> # tree_style is a baseline on top of which additional styles can be added tree.draw(tree_style='d', layout='d', node_markers=\"s\", node_sizes=8, height=250); r0r1r2r3r4r5r6r7r8r9 In\u00a0[36]: Copied! <pre>from toytree.style.src.style_types import TreeStyleU\nTreeStyleU()\n</pre> from toytree.style.src.style_types import TreeStyleU TreeStyleU() Out[36]: <pre>{\ntree_style: None,\nheight: None,\nwidth: None,\nlayout: 'r',\nedge_type: 'p',\nedge_colors: None,\nedge_widths: None,\nnode_mask: None,\nnode_colors: None,\nnode_sizes: 0.0,\nnode_markers: 'o',\nnode_hover: None,\nnode_labels: False,\nnode_as_edge_data: False,\ntip_labels: True,\ntip_labels_colors: None,\ntip_labels_angles: None,\ntip_labels_align: None,\nedge_style: {\n    stroke: (0.145, 0.145, 0.145, 1.0),\n    stroke_width: 2.0,\n    stroke_opacity: None,\n    stroke_linecap: 'round',\n    stroke_dasharray: None,\n},\nnode_style: {\n    fill: 'white',\n    fill_opacity: None,\n    stroke: None,\n    stroke_width: 1.5,\n    stroke_opacity: None,\n},\nnode_labels_style: {\n    fill: (0.145, 0.145, 0.145, 1.0),\n    fill_opacity: 1.0,\n    font_size: 9,\n    font_weight: 300,\n    font_family: 'Helvetica',\n    anchor_shift: 0,\n    baseline_shift: 0,\n    text_anchor: 'middle',\n},\ntip_labels_style: {\n    fill: (0.145, 0.145, 0.145, 1.0),\n    fill_opacity: None,\n    font_size: 12,\n    font_weight: 300,\n    font_family: 'Helvetica',\n    anchor_shift: 15,\n    baseline_shift: 0,\n    text_anchor: 'start',\n},\nedge_align_style: {\n    stroke: (0.66, 0.66, 0.66, 1),\n    stroke_width: 2,\n    stroke_opacity: 0.75,\n    stroke_linecap: 'round',\n    stroke_dasharray: '2,4',\n},\nuse_edge_lengths: True,\nscale_bar: False,\npadding: 15.0,\nxbaseline: 0.0,\nybaseline: 0.0,\nshrink: 0.0,\nadmixture_edges: None,\n}</pre>"},{"location":"tree-styles/#builtin-tree-styles","title":"Builtin Tree Styles\u00b6","text":"<p>There are innumerous ways to style toytree drawings by combining different arguments to the <code>.draw</code> function. As a convenience, we also provide a number of pre-built tree styles that represent collections of style arguments that can be set using a single command.</p>"},{"location":"tree-styles/#example-styles","title":"Example styles\u00b6","text":""},{"location":"tree-styles/#viewing-tree-style-defaults","title":"Viewing tree style defaults\u00b6","text":"<p>In order to see the base settings for a particular builtin tree style, you can import and view an object like below.</p>"},{"location":"vcv/","title":"vcv matrix, etc","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre>tree = toytree.rtree.unittree(ntips=8, treeheight=10)\n</pre> tree = toytree.rtree.unittree(ntips=8, treeheight=10) In\u00a0[7]: Copied! <pre>vcv = tree.pcm.get_vcv_matrix_from_tree(df=True)\nvcv\n</pre> vcv = tree.pcm.get_vcv_matrix_from_tree(df=True) vcv Out[7]: r0 r1 r2 r3 r4 r5 r6 r7 r0 10.0 7.5 5.0 5.0 2.5 0.0 0.0 0.0 r1 7.5 10.0 5.0 5.0 2.5 0.0 0.0 0.0 r2 5.0 5.0 10.0 7.5 2.5 0.0 0.0 0.0 r3 5.0 5.0 7.5 10.0 2.5 0.0 0.0 0.0 r4 2.5 2.5 2.5 2.5 10.0 0.0 0.0 0.0 r5 0.0 0.0 0.0 0.0 0.0 10.0 2.5 2.5 r6 0.0 0.0 0.0 0.0 0.0 2.5 10.0 5.0 r7 0.0 0.0 0.0 0.0 0.0 2.5 5.0 10.0 In\u00a0[8]: Copied! <pre>corr = tree.pcm.get_corr_matrix_from_tree(df=True)\ncorr\n</pre> corr = tree.pcm.get_corr_matrix_from_tree(df=True) corr Out[8]: r0 r1 r2 r3 r4 r5 r6 r7 r0 1.00 0.75 0.50 0.50 0.25 0.00 0.00 0.00 r1 0.75 1.00 0.50 0.50 0.25 0.00 0.00 0.00 r2 0.50 0.50 1.00 0.75 0.25 0.00 0.00 0.00 r3 0.50 0.50 0.75 1.00 0.25 0.00 0.00 0.00 r4 0.25 0.25 0.25 0.25 1.00 0.00 0.00 0.00 r5 0.00 0.00 0.00 0.00 0.00 1.00 0.25 0.25 r6 0.00 0.00 0.00 0.00 0.00 0.25 1.00 0.50 r7 0.00 0.00 0.00 0.00 0.00 0.25 0.50 1.00 In\u00a0[9]: Copied! <pre>dist = toytree.pcm.get_distance_matrix_from_vcv_matrix(vcv)\ndist\n</pre> dist = toytree.pcm.get_distance_matrix_from_vcv_matrix(vcv) dist Out[9]: r0 r1 r2 r3 r4 r5 r6 r7 r0 0.0 5.0 10.0 10.0 15.0 20.0 20.0 20.0 r1 5.0 0.0 10.0 10.0 15.0 20.0 20.0 20.0 r2 10.0 10.0 0.0 5.0 15.0 20.0 20.0 20.0 r3 10.0 10.0 5.0 0.0 15.0 20.0 20.0 20.0 r4 15.0 15.0 15.0 15.0 0.0 20.0 20.0 20.0 r5 20.0 20.0 20.0 20.0 20.0 0.0 15.0 15.0 r6 20.0 20.0 20.0 20.0 20.0 15.0 0.0 10.0 r7 20.0 20.0 20.0 20.0 20.0 15.0 10.0 0.0 In\u00a0[18]: Copied! <pre># returns tree from the vcv\ntre = toytree.pcm.get_tree_from_vcv_matrix(vcv)\n\n# root and draw the tree\ntoytree.mod.root_on_minimal_ancestor_deviation(tre).draw();\n</pre> # returns tree from the vcv tre = toytree.pcm.get_tree_from_vcv_matrix(vcv)  # root and draw the tree toytree.mod.root_on_minimal_ancestor_deviation(tre).draw(); r5r6r7r4r0r1r2r3"},{"location":"vcv/#variance-covariance-matrix-and-related-methods","title":"Variance-covariance matrix and related methods\u00b6","text":""},{"location":"vcv/#vcv-matrix","title":"VCV matrix\u00b6","text":"<p>The variance-covariance matrix (VCV) represents the sum lengths of shared edges between pairs of samples as covariances (off-diagonals) and sum root-to-tip edge lengths of each sample as variances (diagonals). This matrix thus represents the tree structure in a numeric way that is used internally in many comparative methods, such as modeling trait evolution on phylogenies. The default option is to return a VCV with expected variances and covariances under a Brownian motion model of evolution.</p>"},{"location":"vcv/#correlation-matrix","title":"correlation matrix\u00b6","text":"<p>The correlation matrix is computed from the VCV and is a standardized measure of similarity used internally by some phylogenetic comparative methods.</p>"},{"location":"vcv/#vcv-to-distance-matrix","title":"VCV to distance matrix\u00b6","text":"<p>Because the VCV contains all information about a trees edges, it can also be converted to a distance matrix of those edges using the Euclidean distance. Note this method is available only from the module-level API is it does not rely a ToyTree object.</p>"},{"location":"vcv/#tree-from-vcv-matrix","title":"tree from vcv matrix\u00b6","text":"<p>This converts the vcv to a distance matrix and returns an unrooted neighbor-joining distance tree. Below I infer the root and draw the resulting tree.</p>"},{"location":"write_trees/","title":"writing tree data","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np In\u00a0[3]: Copied! <pre># get a balanced 4-tip tree\ntree = toytree.rtree.baltree(ntips=4)\n\n# write the tree to serialized newick format\ntree.write()\n</pre> # get a balanced 4-tip tree tree = toytree.rtree.baltree(ntips=4)  # write the tree to serialized newick format tree.write() Out[3]: <pre>'((r0:0.5,r1:0.5):0.5,(r2:0.5,r3:0.5):0.5);'</pre> <p>Take Home</p> <p>       Write tree data to a serialized text format (Newick, NHX, Nexus) using tree.write(...).   </p> In\u00a0[4]: Copied! <pre># add internal node names as \"A\"\ntree.set_node_data(\"name\", {4: \"A\", 5: \"B\", 6: \"C\"}, inplace=True)\n\n# add internal node support values as 100\ntree.set_node_data(\"support\", {4: 100, 5: 90}, inplace=True)\n\n# add X as node feature with random float values\ntree.set_node_data(\"X\", np.random.normal(0, 2, tree.nnodes), inplace=True)\n\n# show the tree data\ntree.get_node_data()\n</pre> # add internal node names as \"A\" tree.set_node_data(\"name\", {4: \"A\", 5: \"B\", 6: \"C\"}, inplace=True)  # add internal node support values as 100 tree.set_node_data(\"support\", {4: 100, 5: 90}, inplace=True)  # add X as node feature with random float values tree.set_node_data(\"X\", np.random.normal(0, 2, tree.nnodes), inplace=True)  # show the tree data tree.get_node_data() Out[4]: idx name height dist support X 0 0 r0 0.0 0.5 NaN 3.241786 1 1 r1 0.0 0.5 NaN 0.669912 2 2 r2 0.0 0.5 NaN -3.078850 3 3 r3 0.0 0.5 NaN 1.993329 4 4 A 0.5 0.5 100.0 -2.234693 5 5 B 0.5 0.5 90.0 2.277798 6 6 C 1.0 0.0 NaN 0.931252 In\u00a0[3]: Copied! <pre># Newick str from using default arguments to write()\ntree.write()\n</pre> # Newick str from using default arguments to write() tree.write() Out[3]: <pre>'((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);'</pre> In\u00a0[4]: Copied! <pre># writes to file path, returns None\ntree.write(path=\"/tmp/test.nwk\")\n</pre> # writes to file path, returns None tree.write(path=\"/tmp/test.nwk\") In\u00a0[5]: Copied! <pre># write topology only set these args to None\ntree.write(path=None, dist_formatter=None, internal_labels=None)\n</pre> # write topology only set these args to None tree.write(path=None, dist_formatter=None, internal_labels=None) Out[5]: <pre>'((r0,r1),(r2,r3));'</pre> In\u00a0[6]: Copied! <pre># short-hand for simplest tree serialization\ntree.write(None, None, None)\n</pre> # short-hand for simplest tree serialization tree.write(None, None, None) Out[6]: <pre>'((r0,r1),(r2,r3));'</pre> In\u00a0[7]: Copied! <pre># hide edge lengths\ntree.write(dist_formatter=None, internal_labels=None)\n</pre> # hide edge lengths tree.write(dist_formatter=None, internal_labels=None) Out[7]: <pre>'((r0,r1),(r2,r3));'</pre> In\u00a0[8]: Copied! <pre># format edge lengths to show two fixed floating points\ntree.write(dist_formatter=\"%.2f\", internal_labels=None)\n</pre> # format edge lengths to show two fixed floating points tree.write(dist_formatter=\"%.2f\", internal_labels=None) Out[8]: <pre>'((r0:0.50,r1:0.50):0.50,(r2:0.50,r3:0.50):0.50);'</pre> In\u00a0[9]: Copied! <pre># format edge lengths to show max 4 floating points\ntree.write(dist_formatter=\"%.4g\", internal_labels=None)\n</pre> # format edge lengths to show max 4 floating points tree.write(dist_formatter=\"%.4g\", internal_labels=None) Out[9]: <pre>'((r0:0.5,r1:0.5):0.5,(r2:0.5,r3:0.5):0.5);'</pre> In\u00a0[10]: Copied! <pre># format edge lengths as integers\ntree.write(dist_formatter=\"%d\", internal_labels=None)\n</pre> # format edge lengths as integers tree.write(dist_formatter=\"%d\", internal_labels=None) Out[10]: <pre>'((r0:0,r1:0):0,(r2:0,r3:0):0);'</pre> In\u00a0[11]: Copied! <pre># None excludes internal labels\ntree.write(dist_formatter=None, internal_labels=None)\n</pre> # None excludes internal labels tree.write(dist_formatter=None, internal_labels=None) Out[11]: <pre>'((r0,r1),(r2,r3));'</pre> In\u00a0[12]: Copied! <pre># use support floats as internal labels\ntree.write(dist_formatter=None, internal_labels=\"support\")\n</pre> # use support floats as internal labels tree.write(dist_formatter=None, internal_labels=\"support\") Out[12]: <pre>'((r0,r1)100,(r2,r3)90);'</pre> In\u00a0[13]: Copied! <pre># use name str as internal labels\ntree.write(dist_formatter=None, internal_labels=\"name\")\n</pre> # use name str as internal labels tree.write(dist_formatter=None, internal_labels=\"name\") Out[13]: <pre>'((r0,r1)A,(r2,r3)B)C;'</pre> In\u00a0[14]: Copied! <pre># use other existing feature in tree as internal labels\ntree.write(dist_formatter=None, internal_labels=\"X\")\n</pre> # use other existing feature in tree as internal labels tree.write(dist_formatter=None, internal_labels=\"X\") Out[14]: <pre>'((r0,r1)-2.2019018558,(r2,r3)-1.51247041326)0.0903984949236;'</pre> In\u00a0[15]: Copied! <pre># None applies no string formatting\ntree.write(internal_labels_formatter=None)\n</pre> # None applies no string formatting tree.write(internal_labels_formatter=None) Out[15]: <pre>'((r0:0.5,r1:0.5):0.5,(r2:0.5,r3:0.5):0.5);'</pre> In\u00a0[16]: Copied! <pre># float format the 'support' values as max 12 floating points\ntree.write(internal_labels=\"support\", internal_labels_formatter=\"%.12g\")\n</pre> # float format the 'support' values as max 12 floating points tree.write(internal_labels=\"support\", internal_labels_formatter=\"%.12g\") Out[16]: <pre>'((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);'</pre> In\u00a0[17]: Copied! <pre># float format the 'support' values w/ 2 fixed floating points\ntree.write(internal_labels=\"support\", internal_labels_formatter=\"{:.2f}\")\n</pre> # float format the 'support' values w/ 2 fixed floating points tree.write(internal_labels=\"support\", internal_labels_formatter=\"{:.2f}\") Out[17]: <pre>'((r0:0.5,r1:0.5)100.00:0.5,(r2:0.5,r3:0.5)90.00:0.5);'</pre> In\u00a0[18]: Copied! <pre># float format the 'support' values as ints\ntree.write(internal_labels=\"support\", internal_labels_formatter=\"%d\")\n</pre> # float format the 'support' values as ints tree.write(internal_labels=\"support\", internal_labels_formatter=\"%d\") Out[18]: <pre>'((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);'</pre> In\u00a0[19]: Copied! <pre># see the features of a tree\ntree.features\n</pre> # see the features of a tree tree.features Out[19]: <pre>('idx', 'name', 'height', 'dist', 'support', 'X')</pre> In\u00a0[20]: Copied! <pre># see which features are edge (not node) data\ntree.edge_features\n</pre> # see which features are edge (not node) data tree.edge_features Out[20]: <pre>{'dist', 'support'}</pre> In\u00a0[21]: Copied! <pre># write NHX w/ \"X\" as node feature\ntree.write(features=[\"X\"])\n</pre> # write NHX w/ \"X\" as node feature tree.write(features=[\"X\"]) Out[21]: <pre>'((r0[&amp;X=0.608116507902]:0.5,r1[&amp;X=-1.12762954173]:0.5)100[&amp;X=-2.2019018558]:0.5,(r2[&amp;X=-3.42995006373]:0.5,r3[&amp;X=-1.19754491671]:0.5)90[&amp;X=-1.51247041326]:0.5)[&amp;X=0.0903984949236];'</pre> In\u00a0[22]: Copied! <pre># write NHX w/ \"support\" as edge feature\ntree.write(features=[\"support\"])\n</pre> # write NHX w/ \"support\" as edge feature tree.write(features=[\"support\"]) Out[22]: <pre>'((r0:0.5,r1:0.5)100:0.5[&amp;support=100],(r2:0.5,r3:0.5)90:0.5[&amp;support=90]);'</pre> In\u00a0[23]: Copied! <pre># write NHX string with one node metadata feature  \ntree.write(features=[\"X\"], features_formatter=\"%.3f\")\n</pre> # write NHX string with one node metadata feature   tree.write(features=[\"X\"], features_formatter=\"%.3f\") Out[23]: <pre>'((r0[&amp;X=0.608]:0.5,r1[&amp;X=-1.128]:0.5)100[&amp;X=-2.202]:0.5,(r2[&amp;X=-3.430]:0.5,r3[&amp;X=-1.198]:0.5)90[&amp;X=-1.512]:0.5)[&amp;X=0.090];'</pre> In\u00a0[24]: Copied! <pre># write tree in Newick format wrapped in Nexus\nnexus = tree.write(nexus=True)\nprint(nexus)\n</pre> # write tree in Newick format wrapped in Nexus nexus = tree.write(nexus=True) print(nexus) <pre>#NEXUS\nbegin trees;\n    translate\n        0 r0,\n        1 r1,\n        2 r2,\n        3 r3,\n    ;\n    tree 0 = [&amp;R] ((0:0.5,1:0.5)100:0.5,(2:0.5,3:0.5)90:0.5);\nend;\n</pre> In\u00a0[25]: Copied! <pre># write tree in NHX format wrapped in Nexus\nnexus = tree.write(features=[\"support\", \"name\", \"X\"], nexus=True, features_formatter=\"%.2f\")\nprint(nexus)\n</pre> # write tree in NHX format wrapped in Nexus nexus = tree.write(features=[\"support\", \"name\", \"X\"], nexus=True, features_formatter=\"%.2f\") print(nexus) <pre>#NEXUS\nbegin trees;\n    translate\n        0 r0,\n        1 r1,\n        2 r2,\n        3 r3,\n    ;\n    tree 0 = [&amp;R] ((0[&amp;name=r0,X=0.61]:0.5,1[&amp;name=r1,X=-1.13]:0.5)100[&amp;name=A,X=-2.20]:0.5[&amp;support=100.00],(2[&amp;name=r2,X=-3.43]:0.5,3[&amp;name=r3,X=-1.20]:0.5)90[&amp;name=B,X=-1.51]:0.5[&amp;support=90.00])[&amp;name=C,X=0.09];\nend;\n</pre> In\u00a0[26]: Copied! <pre># write tree to file as Nexus\ntree.write(path=\"/tmp/test.nex\", nexus=True)\n</pre> # write tree to file as Nexus tree.write(path=\"/tmp/test.nex\", nexus=True) In\u00a0[27]: Copied! <pre># create a MultiTree\nmtree = toytree.mtree([tree, tree, tree])\n</pre> # create a MultiTree mtree = toytree.mtree([tree, tree, tree]) In\u00a0[28]: Copied! <pre># write multi-Newick\nprint(mtree.write())\n</pre> # write multi-Newick print(mtree.write()) <pre>((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);\n((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);\n((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);\n</pre>"},{"location":"write_trees/#writing-tree-data-io","title":"Writing tree data (I/O)\u00b6","text":"<p>Tree data can be serialized into a <code>str</code> as Newick, NHX, or NEXUS format using the <code>.write()</code> function, available as <code>toytree.io.write(tree, ...)</code> or from a ToyTree object as <code>tree.write(...)</code>. This function accepts several additional arguments to optionally format float data or include additional metadata, and to write the <code>str</code> result to a file path.</p>"},{"location":"write_trees/#example-data","title":"Example data\u00b6","text":"<p>To demonstrate, let's start by generating a <code>ToyTree</code> with several types of node and edge data to use for examples. Here we are assigning names to all internal nodes, support values to internal nodes/edges except the root, and a feature named \"X\" with a random float value to every node.</p>"},{"location":"write_trees/#the-write-function","title":"The write function\u00b6","text":"<p>The default arguments to the <code>.write()</code> function return a newick string with edge lengths (if present) formatted as <code>\"%.12g\"</code>, with internal labels as <code>\"support\"</code> values (if present) formatted as <code>\"%.12g\"</code>, and no additional features (metadata). However, all of these options can be modified, as demonstrated below.</p>"},{"location":"write_trees/#path-save-to-disk","title":"path: save to disk\u00b6","text":"<p>The first argument to <code>write()</code> is <code>path</code>, which accepts a file path as a <code>str</code>, <code>Path</code>, or None. If a <code>path</code> is entered then the data will be written to the designated file path and None is returned. If <code>path=None</code> then nothing is written to file and the serialized tree data <code>str</code> will be returned (like above). This can be useful when you want to store the <code>str</code> data as a variable and do something with it. I use the default arg <code>path=None</code> throughout the rest of this document after this example for demonstration.</p>"},{"location":"write_trees/#newick","title":"Newick\u00b6","text":"<p>As we saw above, the default output format of <code>.write</code> is a Newick str, and when called with the default arguments it writes the dist edge lengths as well as internal node labels. By modifying these arguments you can either suppress these additional data or modify their formatting.</p>"},{"location":"write_trees/#dist_formatter-edge-lengths","title":"dist_formatter: edge lengths\u00b6","text":"<p>The <code>dist_formatter</code> argument can be used to include or exclude edge lengths, and to format the edge lengths if they are included. By setting <code>dist_formatter=None</code> edge lengths are not shown. Formatting of branch lengths takes a Python formatting string in one of two supported formats, using percent sign or curly brackets, e.g., <code>\"%.12g\"</code> or <code>\"{:.12g}\"</code>. See the Python documentation for further explanation of Python string formatting (or this resource). Here I set <code>internal_labels=None</code> just to hide internal labels to make it easier to see the edge lengths.</p>"},{"location":"write_trees/#internal_labels","title":"internal_labels\u00b6","text":"<p>As discussed in the Parsing tree data docs, the internal label in a newick string can be ambiguous in its usage for storing either internal node names, edge support values, or possibly other types of data. The <code>internal_labels</code> arg takes a str feature name as an argument. A <code>ToyTree</code> always has \"name\" and \"support\" features that can be selected, and if empty, they will be ignored. Here I set <code>dist_formatter=None</code> just to hide edge lengths to make it easier to see the internal_labels.</p>"},{"location":"write_trees/#internal_labels_formatter","title":"internal_labels_formatter\u00b6","text":"<p>Similar to the <code>dist_formatter</code> arg above, you can similarly apply string formatting to <code>internal_labels</code> when they are floats. This has no effect on internal names, but is useful for support, or other features.</p>"},{"location":"write_trees/#write-nhx","title":"Write NHX\u00b6","text":"<p>The extended New Hampshire format (NHX) is simply an extension of the Newick format with metadata stored inside square brackets after nodes and/or edges. The data/features in a <code>ToyTree</code> represent any data stored to one or more <code>Node</code> objects of the tree (see Data/Features). These data may have been generated by some analysis tool, or could be stored manually in <code>toytree</code>. You can view the features of a <code>ToyTree</code> using <code>get_node_data()</code>, which shows data for each Node for each feature. You can view the features by calling <code>.features</code> and see which subset of features apply to edges by calling <code>.edge_features</code>. This is important to note because the <code>.write()</code> function will append edge features as metadata to edges, and node features as metadata to nodes in the NHX format.</p>"},{"location":"write_trees/#features","title":"features\u00b6","text":""},{"location":"write_trees/#features_formatting","title":"features_formatting\u00b6","text":""},{"location":"write_trees/#write-nexus","title":"Write NEXUS\u00b6","text":"<p>Converting tree data into NEXUS format is trivial, simply add the <code>nexus=True</code> argument to write. You can still use any of the formatting options above to format the Newick/NHX string, but it will now be written inside a \"trees\" block, with names translated into integers, with a translation section, and with a \"#NEXUS\" header.</p>"},{"location":"write_trees/#write-multitrees","title":"Write MultiTrees\u00b6","text":"<p>MultiTrees have a <code>.write()</code> function that works very similarly to the <code>ToyTree.write</code> but applies to each tree in order. A multi- Newick file contains trees separated by newline characters, whereas a multi Nexus file contains trees labels by increasing number in the trees block.</p>"}]}